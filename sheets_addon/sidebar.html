<html>
    <head>
        <title>Gramble by Examble</title>
        <?!= include('grambleWrapped'); ?>
        <?!= include('style'); ?>
    </head>
    <body>
        <script>
            function letterFromNumber(n) { // number -> string
                var letter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(n % 26)
                var concat = Math.round(n / 26);
                return concat > 0 ? letterFromNumber(concat-1) + letter : letter;
            };

            function getA1Notation(sheet, row, col) {
                if (sheet == "") {
                    return `${letterFromNumber(col)}${(row+1)}`;
                }
                return `${sheet}!${letterFromNumber(col)}${(row+1)}`;
            }

            var previousSheetName = "";
            var previousSymbol = ""; // the symbol that the user selected is stored even
                                          // between grammar reloads, so that they're not surprised
                                          // when they reload, start sampling again, and get a different
                                          // symbol than just a moment before.

            var devEnv = undefined;  // SidebarDevEnvironment
            var project = undefined; // Project
            var CURRENT_TAPES = [];
            var CURRENT_INPUTS = {};

            class SidebarDevEnvironment {

                constructor(cellsBySheet) {
                    this.cellsBySheet = cellsBySheet; // {[key: string}: string[][]
                    this.errorMsgs = []; // list of [sheet, row, col, shortMsg, msg, level]
                }

                hasSource(sheetName) { 
                    return (sheetName in this.cellsBySheet);
                }

                loadSource(sheetName) {
                    if (!(this.hasSource(sheetName))) {
                        return [];
                    }
                    return this.cellsBySheet[sheetName];
                }

                markError(sheet, row, col, shortMsg, msg, level = "error") {
                    this.errorMsgs.push([sheet, row, col, shortMsg, msg, level]);
                }

                markHeader(sheet, row, col, color) { }
                markContent(sheet, row, col, color) { }
                markCommand(sheet, row, col) { }
                markComment(sheet, row, col) { }
                markSymbol(sheet, row, col) { }
                highlight() { }

            }

            function scriptRunPromise() {
                const gs = {};
                const keys = Object.keys(google.script.run);
                for (let i=0; i < keys.length; i++) {
                    gs[keys[i]] = (function(key) {
                    return function(...args) {
                        return new Promise(function(resolve, reject) {
                        google.script.run
                            .withSuccessHandler(resolve)
                            .withFailureHandler(reject)[key]
                            .apply(google.script.run, args);
                        });
                    };
                    })(keys[i]);
                }
                return gs;
            }

            function removeElementsByClass(className) {
                var inputsToRemove = document.getElementsByClassName(className);
                while(inputsToRemove.length > 0){
                    inputsToRemove[0].parentNode.removeChild(inputsToRemove[0]);
                }

            }

            var reloadGrammarLock = false;
            async function reloadGrammar() {
                
                if (reloadGrammarLock) {
                    return;
                }

                reloadGrammarLock = true;

                // hide or remove everything in the control panel except "Loading..."
                const controlTable = document.getElementById("controlTable");
                controlTable.style.visibility = "collapse";
                const inputTable = document.getElementById("inputTable");
                inputTable.style.visibility = "collapse";
                const sampleTable = document.getElementById("sampleTable");
                sampleTable.style.visibility = "collapse";
                removeElementsByClass("tapeInputTr");
                removeElementsByClass("errorButton");
                const resultsTable  = document.getElementById("resultsTable"); 
                resultsTable.innerHTML = "";
                resultsTable.style.visibility = "collapse";
                const loadingP = document.getElementById("loadingP");
                loadingP.style.display = "block";

                // ask for the latest data from GSuite
                const responseFromGSuite = await scriptRunPromise().getAllCells();
                
                if (!responseFromGSuite["success"]) {
                    throw new Error("Failed to communicate with Google Sheets backend: " +
                        `${responseFromGSuite["message"]}`);
                }

                const currentSheetName = responseFromGSuite["payload"]["startSheet"];
                const cellsBySheet = responseFromGSuite["payload"]["sheets"];

                // if there's not yet been a previous symbol chosen, or if the user
                // is syncing a different sheet from before, reset the previousSymbol
                // to the sheet name.
                if (previousSymbol == "" || currentSheetName != previousSheetName) {
                    previousSymbol = currentSheetName;
                }

                previousSheetName = currentSheetName;
                
                devEnv = new SidebarDevEnvironment(cellsBySheet);
                project = new gramble.Project(devEnv);
                project.addSheet(currentSheetName);
                project.runChecks();

                createErrorButtons(devEnv.errorMsgs, currentSheetName);
                reloadSymbols(currentSheetName);
                reloadInputs();

                reloadGrammarLock = false;

                loadingP.style.display = "none";
                controlTable.style.visibility = "visible";
                
                const select = document.getElementById("selectSymbol"); 
                const currentSymbol = select.value;
                if (currentSymbol == "" || currentSymbol == undefined) {
                    // this happens when no symbols happen to be defined in the
                    // active document
                    return;
                }
                inputTable.style.visibility = "visible";
                sampleTable.style.visibility = "visible";
                resultsTable.style.visibility = "visible";
            }

            function createErrorButtons(errorMsgs, currentSheetName) {


                if (errorMsgs.length == 0) {
                    return;
                }

                
                const errorArea = document.getElementById("errorArea");
                
                for (const [sheet, row, col, shortMsg, msg, lvl] of errorMsgs) {

                    if (lvl != "error") {
                        continue;
                    }

                    const button = document.createElement('button');
                    button.classList.add('errorButton');
                    var cellName = getA1Notation("", row, col);
                    if (sheet != currentSheetName) {
                        cellName = `${sheet}!${cellName}`; 
                    }
                    button.innerHTML = `${cellName}: ${shortMsg}`;
                    button.title = msg;
                    button.onclick = async function() {
                        await scriptRunPromise().scrollToCell(sheet, row, col);
                        return false;
                    };
                    errorArea.appendChild(button);
                }
            }

            
            function reloadSymbols(currentSheetName) {

                if (project == undefined) {
                    throw new Error("Trying to reload symbols without a project");
                }

                const select = document.getElementById("selectSymbol"); 
                select.innerHTML = "";
                
                var options = project.allSymbols();
                for (const option of options) {
                    const el = document.createElement('option');

                    var optionText = option;
                    const pieces = option.split(".");
                    if (pieces[pieces.length-1] == "__MAIN__") {
                        optionText = pieces.slice(0, pieces.length-1).join(".");
                    } 
                    el.textContent = optionText;
                    el.value = option;
                    select.appendChild(el);
                    if (optionText.toLowerCase() == previousSymbol.toLowerCase() ||
                        el.value.toLowerCase() == previousSymbol.toLowerCase()) {
                        el.selected = true;
                    }

                } 
            }

            function reloadInputs() {

                const select = document.getElementById("selectSymbol"); 
                const currentSymbol = select.value;
                
                if (currentSymbol == "" || currentSymbol == undefined) {
                    return;
                }

                CURRENT_TAPES = project.getTapeNames(currentSymbol);

                const inputTable = document.getElementById("inputTable");
                for (const [tapeName, color] of CURRENT_TAPES) {
                    const tr = document.createElement("tr");
                    tr.classList.add("tapeInputTr");
                    tr.style.backgroundColor = color;
                    const labelTd = document.createElement("td");
                    labelTd.classList.add("labelTd");
                    const label = document.createElement("label");
                    label.htmlFor = `input_${tapeName}`;
                    label.innerHTML = tapeName;
                    labelTd.appendChild(label);
                    tr.appendChild(labelTd);
                    const inputTd = document.createElement("td");
                    const input = document.createElement("input");
                    input.classList.add("tapeInput");
                    input.type = "text";
                    input.id = `input_${tapeName}`;
                    input.name = `input_${tapeName}`;
                    inputTd.appendChild(input);
                    tr.appendChild(inputTd);
                    inputTable.append(tr);
                }
            }
            
            function reloadResults() {

                var resultsTable  = document.getElementById("resultsTable"); 
                resultsTable.innerHTML = "";

                var symbolName = document.getElementById("selectSymbol").value;

                if (symbolName == "" || symbolName == undefined) {
                    return;
                }

                CURRENT_INPUTS = {};
                for (const [tapeName, color] of CURRENT_TAPES) {
                    const input = document.getElementById(`input_${tapeName}`);
                    const value = input.value.trim();
                    if (value.length == 0) {
                        continue;
                    }
                    CURRENT_INPUTS[tapeName] = value;
                }

                var startTime = Date.now();
                const results = project.sample(symbolName, 5, CURRENT_INPUTS);
                console.log(`Generated results, elapsed time = ${Date.now()-startTime}ms`);

                for (var i = 0; i < results.length; i++) {
                    displayRecord(results[i], resultsTable);
                }
            }

            function displayRecord(record, table) {

                
                for (const [key, color] of CURRENT_TAPES) {

                    if (!record.hasOwnProperty(key)) {
                        continue;
                    }

                    var tr = table.insertRow();
                    tr.classList.add("resultsTr");
                    tr.style.backgroundColor = color;
                    
                    var keyCell = tr.insertCell();
                    keyCell.classList.add("resultsKey");
                    keyCell.appendChild(document.createTextNode(key));

                    var valueCell = tr.insertCell();
                    valueCell.classList.add("resultsValue");
                    valueCell.appendChild(document.createTextNode(record[key]));
                }

                var blankRow = table.insertRow();
                blankRow.classList.add("resultsBlankTr");
                var blankCell = blankRow.insertCell();
                blankCell = blankRow.insertCell();
                blankCell.appendChild(document.createTextNode("\u00A0"));
                blankCell.classList.add("resultsBlank");
            }

            function resultsToTable(labels, entries) {
                return [
                    labels,
                    ...entries.map(row => labels.map(label => row[label]))
                ];
            }
            
            function resultsToCSV(labels, entries) {
                const replacer = (key, value) => value === null ? '' : value 
                return [
                    labels.join(','), // header row first
                    ...entries.map(row => labels.map(label => JSON.stringify(row[label], replacer)).join(','))
                ].join('\n');
            }

            function getCurrentInputs() {
                const results = {};
                for (const [tapeName, color] of CURRENT_TAPES) {
                    const input = document.getElementById(`input_${tapeName}`);
                    const value = input.value.trim();
                    if (value.length == 0) {
                        continue;
                    }
                    results[tapeName] = value;
                }
                return results;
            }

            function getCurrentSymbolName() {

                // determine what symbol to generate from
                const symbolSelect = document.getElementById("selectSymbol"); 
                var symbolName = symbolSelect.value;

                if (symbolName == "" || symbolName == undefined) {
                    return;
                }

                if (symbolName.endsWith(".__MAIN__")) {
                    symbolName = symbolName.substr(0, symbolName.length-9);
                }

                return symbolName;

            }

            function downloadResults() {

                const symbolName = getCurrentSymbolName();

                // determine what tape names are relevant to this symbol
                const tapeInfo = project.getTapeNames(symbolName);
                const tapeNames = tapeInfo.map(([k, v]) => k);

                const inputs = getCurrentInputs();
                
                var startTime = Date.now();
                const results = project.generate(symbolName, inputs);
                console.log(`Generated results, elapsed time = ${Date.now()-startTime}ms`);
                
                // determine what format to output in
                var formatSelect = document.getElementById("downloadFormatSelect");
                const downloadFormat = formatSelect.value;

                var filename, text;
                // convert the results to the appropriate format
                if (downloadFormat == "json") {
                    filename = `${symbolName}_output.json`;
                    text = JSON.stringify(results, null, 2);
                } else if (downloadFormat == "csv") {
                    filename = `${symbolName}_output.csv`;
                    text = resultsToCSV(tapeNames, results);
                }

                // create a temporary link element to download from
                var element = document.createElement('a');
                element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
                return false;
            }

            async function generateToNewSheet() {
                
                const symbolName = getCurrentSymbolName();

                const inputs = getCurrentInputs();
                
                var startTime = Date.now();
                const results = project.generate(symbolName, inputs);
                console.log(`Generated results, elapsed time = ${Date.now()-startTime}ms`);
                
                // determine what tape names are relevant to this symbol
                const tapeInfo = project.getTapeNames(symbolName);
                const tapeNames = tapeInfo.map(([k, v]) => k);

                const resultsTable = resultsToTable(tapeNames, results)
                const sheetName = symbolName + "_generated";
                await scriptRunPromise().makeNewSheet(symbolName, sheetName, resultsTable);
            }

            
            async function sampleToNewSheet() {
                
                const symbolName = getCurrentSymbolName();

                const inputs = getCurrentInputs();
                
                var startTime = Date.now();
                const results = project.sample(symbolName, 50, inputs);
                console.log(`Generated results, elapsed time = ${Date.now()-startTime}ms`);
                
                // determine what tape names are relevant to this symbol
                const tapeInfo = project.getTapeNames(symbolName);
                const tapeNames = tapeInfo.map(([k, v]) => k);

                const resultsTable = resultsToTable(tapeNames, results)
                const sheetName = symbolName + "_sampled";
                await scriptRunPromise().makeNewSheet(symbolName, sheetName, resultsTable);
            }

            window.onload = async function() {
                
                try {
                    await reloadGrammar();

                    document.getElementById("reloadButton").onclick = async function(ev) {
                        await reloadGrammar();
                    }

                    const selector = document.getElementById("selectSymbol")
                    selector.onchange = function(ev) {
                        previousSymbol = selector.value;
                        removeElementsByClass("tapeInputTr");
                        reloadInputs();                     
                        var resultsTable  = document.getElementById("resultsTable"); 
                        resultsTable.innerHTML = "";
                    };
                    
                    document.getElementById("sampleButton").onclick = async function(ev) {
                        await reloadResults();
                    }

                } catch(err) {
                    alert(err);
                }

            };
        </script>

        <table id="controlTable">
            <!-- <td colspan="2"><button id="highlightButton">Highlight</button></td></tr>-->
            <tr><td colspan="2"><button id="reloadButton" class="sidebarButton">Sync &amp; validate</button></td></tr>
            <tr id="errorTr"><td colspan="2" id="errorArea"> </td></tr>
        </table>
        <table id="inputTable">
            <tr id="selectTr"><td>Input:</td><td class="wideTd"><select id="selectSymbol"> </select></td></tr>
        </table>

        <table id="sampleTable">
            <tr>
                <td>
                    <button id="downloadButton" class="sidebarButton" onclick="downloadResults()">Generate &amp; download</button>
                </td>
                <td>
                    <select id="downloadFormatSelect">
                        <option value="csv">CSV</option>
                        <option value="json">JSON</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td colspan="2">
                    <button id="generateToNewSheetButton" class="sidebarButton" onclick="generateToNewSheet()">Generate to new sheet</button>
                </td>
            </tr>
            <tr>
                <td colspan="2">
                    <button id="sampleToNewSheetButton" class="sidebarButton" onclick="sampleToNewSheet()">Sample to new sheet</button>
                </td>
            </tr>
            <tr><td colspan="2"><button id="sampleButton" class="sidebarButton">Sample here</button></td></tr>
        </table>

        <p id="loadingP">Loading...</p>

        <table id="resultsTable"> </table>


    </body>
</html>