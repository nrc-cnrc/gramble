<script>
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.gramble = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * @license BitSet.js v5.1.1 2/1/2020
 * http://www.xarg.org/2014/03/javascript-bit-array/
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(root) {

  'use strict';

  /**
   * The number of bits of a word
   * @const
   * @type number
   */
  var WORD_LENGTH = 32;

  /**
   * The log base 2 of WORD_LENGTH
   * @const
   * @type number
   */
  var WORD_LOG = 5;

  /**
   * Calculates the number of set bits
   *
   * @param {number} v
   * @returns {number}
   */
  function popCount(v) {

    // Warren, H. (2009). Hacker`s Delight. New York, NY: Addison-Wesley

    v -= ((v >>> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
    return (((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24);
  }

  /**
   * Divide a number in base two by B
   *
   * @param {Array} arr
   * @param {number} B
   * @returns {number}
   */
  function divide(arr, B) {

    var r = 0;

    for (var i = 0; i < arr.length; i++) {
      r *= 2;
      var d = (arr[i] + r) / B | 0;
      r = (arr[i] + r) % B;
      arr[i] = d;
    }
    return r;
  }

  /**
   * Parses the parameters and set variable P
   *
   * @param {Object} P
   * @param {string|BitSet|Array|Uint8Array|number=} val
   */
  function parse(P, val) {

    if (val == null) {
      P['data'] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      P['_'] = 0;
      return;
    }

    if (val instanceof BitSet) {
      P['data'] = val['data'];
      P['_'] = val['_'];
      return;
    }

    switch (typeof val) {

      case 'number':
        P['data'] = [val | 0];
        P['_'] = 0;
        break;

      case 'string':

        var base = 2;
        var len = WORD_LENGTH;

        if (val.indexOf('0b') === 0) {
          val = val.substr(2);
        } else if (val.indexOf('0x') === 0) {
          val = val.substr(2);
          base = 16;
          len = 8;
        }

        P['data'] = [];
        P['_'] = 0;

        var a = val.length - len;
        var b = val.length;

        do {

          var num = parseInt(val.slice(a > 0 ? a : 0, b), base);

          if (isNaN(num)) {
            throw SyntaxError('Invalid param');
          }

          P['data'].push(num | 0);

          if (a <= 0)
            break;

          a -= len;
          b -= len;
        } while (1);

        break;

      default:

        P['data'] = [0];
        var data = P['data'];

        if (val instanceof Array) {

          for (var i = val.length - 1; i >= 0; i--) {

            var ndx = val[i];

            if (ndx === Infinity) {
              P['_'] = -1;
            } else {
              scale(P, ndx);
              data[ndx >>> WORD_LOG] |= 1 << ndx;
            }
          }
          break;
        }

        if (Uint8Array && val instanceof Uint8Array) {

          var bits = 8;

          scale(P, val.length * bits);

          for (var i = 0; i < val.length; i++) {

            var n = val[i];

            for (var j = 0; j < bits; j++) {

              var k = i * bits + j;

              data[k >>> WORD_LOG] |= (n >> j & 1) << k;
            }
          }
          break;
        }
        throw SyntaxError('Invalid param');
    }
  }

  /**
   * Module entry point
   *
   * @constructor
   * @param {string|BitSet|number=} param
   * @returns {BitSet}
   */
  function BitSet(param) {

    if (!(this instanceof BitSet)) {
      return new BitSet(param);
    }
    parse(this, param);
    this['data'] = this['data'].slice();
  }

  function scale(dst, ndx) {

    var l = ndx >>> WORD_LOG;
    var d = dst['data'];
    var v = dst['_'];

    for (var i = d.length; l >= i; l--) {
      d.push(v);
    }
  }

  var P = {
    'data': [], // Holds the actual bits in form of a 32bit integer array.
    '_': 0 // Holds the MSB flag information to make indefinitely large bitsets inversion-proof
  };

  BitSet.prototype = {
    'data': [],
    '_': 0,
    /**
     * Set a single bit flag
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * bs1.set(3, 1);
     *
     * @param {number} ndx The index of the bit to be set
     * @param {number=} value Optional value that should be set on the index (0 or 1)
     * @returns {BitSet} this
     */
    'set': function(ndx, value) {

      ndx |= 0;

      scale(this, ndx);

      if (value === undefined || value) {
        this['data'][ndx >>> WORD_LOG] |= (1 << ndx);
      } else {
        this['data'][ndx >>> WORD_LOG] &= ~(1 << ndx);
      }
      return this;
    },
    /**
     * Get a single bit flag of a certain bit position
     *
     * Ex:
     * bs1 = new BitSet();
     * var isValid = bs1.get(12);
     *
     * @param {number} ndx the index to be fetched
     * @returns {number} The binary flag
     */
    'get': function(ndx) {

      ndx |= 0;

      var d = this['data'];
      var n = ndx >>> WORD_LOG;

      if (n >= d.length) {
        return this['_'] & 1;
      }
      return (d[n] >>> ndx) & 1;
    },
    /**
     * Creates the bitwise NOT of a set.
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * res = bs1.not();
     *
     * @returns {BitSet} A new BitSet object, containing the bitwise NOT of this
     */
    'not': function() { // invert()

      var t = this['clone']();
      var d = t['data'];
      for (var i = 0; i < d.length; i++) {
        d[i] = ~d[i];
      }

      t['_'] = ~t['_'];

      return t;
    },
    /**
     * Creates the bitwise AND of two sets.
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = new BitSet(10);
     *
     * res = bs1.and(bs2);
     *
     * @param {BitSet} value A bitset object
     * @returns {BitSet} A new BitSet object, containing the bitwise AND of this and value
     */
    'and': function(value) {// intersection

      parse(P, value);

      var T = this['clone']();
      var t = T['data'];
      var p = P['data'];

      var pl = p.length;
      var p_ = P['_'];
      var t_ = T['_'];

      // If this is infinite, we need all bits from P
      if (t_ !== 0) {
        scale(T, pl * WORD_LENGTH - 1);
      }

      var tl = t.length;
      var l = Math.min(pl, tl);
      var i = 0;

      for (; i < l; i++) {
        t[i] &= p[i];
      }

      for (; i < tl; i++) {
        t[i] &= p_;
      }

      T['_'] &= p_;

      return T;
    },
    /**
     * Creates the bitwise OR of two sets.
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = new BitSet(10);
     *
     * res = bs1.or(bs2);
     *
     * @param {BitSet} val A bitset object
     * @returns {BitSet} A new BitSet object, containing the bitwise OR of this and val
     */
    'or': function(val) { // union

      parse(P, val);

      var t = this['clone']();
      var d = t['data'];
      var p = P['data'];

      var pl = p.length - 1;
      var tl = d.length - 1;

      var minLength = Math.min(tl, pl);

      // Append backwards, extend array only once
      for (var i = pl; i > minLength; i--) {
        d[i] = p[i];
      }

      for (; i >= 0; i--) {
        d[i] |= p[i];
      }

      t['_'] |= P['_'];

      return t;
    },
    /**
     * Creates the bitwise XOR of two sets.
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = new BitSet(10);
     *
     * res = bs1.xor(bs2);
     *
     * @param {BitSet} val A bitset object
     * @returns {BitSet} A new BitSet object, containing the bitwise XOR of this and val
     */
    'xor': function(val) { // symmetric difference

      parse(P, val);

      var t = this['clone']();
      var d = t['data'];
      var p = P['data'];

      var t_ = t['_'];
      var p_ = P['_'];

      var i = 0;

      var tl = d.length - 1;
      var pl = p.length - 1;

      // Cut if tl > pl
      for (i = tl; i > pl; i--) {
        d[i] ^= p_;
      }

      // Cut if pl > tl
      for (i = pl; i > tl; i--) {
        d[i] = t_ ^ p[i];
      }

      // XOR the rest
      for (; i >= 0; i--) {
        d[i] ^= p[i];
      }

      // XOR infinity
      t['_'] ^= p_;

      return t;
    },
    /**
     * Creates the bitwise AND NOT (not confuse with NAND!) of two sets.
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = new BitSet(10);
     *
     * res = bs1.notAnd(bs2);
     *
     * @param {BitSet} val A bitset object
     * @returns {BitSet} A new BitSet object, containing the bitwise AND NOT of this and other
     */
    'andNot': function(val) { // difference

      return this['and'](new BitSet(val)['flip']());
    },
    /**
     * Flip/Invert a range of bits by setting
     *
     * Ex:
     * bs1 = new BitSet();
     * bs1.flip(); // Flip entire set
     * bs1.flip(5); // Flip single bit
     * bs1.flip(3,10); // Flip a bit range
     *
     * @param {number=} from The start index of the range to be flipped
     * @param {number=} to The end index of the range to be flipped
     * @returns {BitSet} this
     */
    'flip': function(from, to) {

      if (from === undefined) {

        var d = this['data'];
        for (var i = 0; i < d.length; i++) {
          d[i] = ~d[i];
        }

        this['_'] = ~this['_'];

      } else if (to === undefined) {

        scale(this, from);

        this['data'][from >>> WORD_LOG] ^= (1 << from);

      } else if (0 <= from && from <= to) {

        scale(this, to);

        for (var i = from; i <= to; i++) {
          this['data'][i >>> WORD_LOG] ^= (1 << i);
        }
      }
      return this;
    },
    /**
     * Clear a range of bits by setting it to 0
     *
     * Ex:
     * bs1 = new BitSet();
     * bs1.clear(); // Clear entire set
     * bs1.clear(5); // Clear single bit
     * bs1.clear(3,10); // Clear a bit range
     *
     * @param {number=} from The start index of the range to be cleared
     * @param {number=} to The end index of the range to be cleared
     * @returns {BitSet} this
     */
    'clear': function(from, to) {

      var data = this['data'];

      if (from === undefined) {

        for (var i = data.length - 1; i >= 0; i--) {
          data[i] = 0;
        }
        this['_'] = 0;

      } else if (to === undefined) {

        from |= 0;

        scale(this, from);

        data[from >>> WORD_LOG] &= ~(1 << from);

      } else if (from <= to) {

        scale(this, to);

        for (var i = from; i <= to; i++) {
          data[i >>> WORD_LOG] &= ~(1 << i);
        }
      }
      return this;
    },
    /**
     * Gets an entire range as a new bitset object
     *
     * Ex:
     * bs1 = new BitSet();
     * bs1.slice(4, 8);
     *
     * @param {number=} from The start index of the range to be get
     * @param {number=} to The end index of the range to be get
     * @returns {BitSet} A new smaller bitset object, containing the extracted range
     */
    'slice': function(from, to) {

      if (from === undefined) {
        return this['clone']();
      } else if (to === undefined) {

        to = this['data'].length * WORD_LENGTH;

        var im = Object.create(BitSet.prototype);

        im['_'] = this['_'];
        im['data'] = [0];

        for (var i = from; i <= to; i++) {
          im['set'](i - from, this['get'](i));
        }
        return im;

      } else if (from <= to && 0 <= from) {

        var im = Object.create(BitSet.prototype);
        im['data'] = [0];

        for (var i = from; i <= to; i++) {
          im['set'](i - from, this['get'](i));
        }
        return im;
      }
      return null;
    },
    /**
     * Set a range of bits
     *
     * Ex:
     * bs1 = new BitSet();
     *
     * bs1.setRange(10, 15, 1);
     *
     * @param {number} from The start index of the range to be set
     * @param {number} to The end index of the range to be set
     * @param {number} value Optional value that should be set on the index (0 or 1)
     * @returns {BitSet} this
     */
    'setRange': function(from, to, value) {

      for (var i = from; i <= to; i++) {
        this['set'](i, value);
      }
      return this;
    },
    /**
     * Clones the actual object
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = bs1.clone();
     *
     * @returns {BitSet|Object} A new BitSet object, containing a copy of the actual object
     */
    'clone': function() {

      var im = Object.create(BitSet.prototype);
      im['data'] = this['data'].slice();
      im['_'] = this['_'];

      return im;
    },
    /**
     * Gets a list of set bits
     *
     * @returns {Array}
     */
    'toArray': Math['clz32'] ?
    function() {

      var ret = [];
      var data = this['data'];

      for (var i = data.length - 1; i >= 0; i--) {

        var num = data[i];

        while (num !== 0) {
          var t = 31 - Math['clz32'](num);
          num ^= 1 << t;
          ret.unshift((i * WORD_LENGTH) + t);
        }
      }

      if (this['_'] !== 0)
        ret.push(Infinity);

      return ret;
    } :
    function() {

      var ret = [];
      var data = this['data'];

      for (var i = 0; i < data.length; i++) {

        var num = data[i];

        while (num !== 0) {
          var t = num & -num;
          num ^= t;
          ret.push((i * WORD_LENGTH) + popCount(t - 1));
        }
      }

      if (this['_'] !== 0)
        ret.push(Infinity);

      return ret;
    },
    /**
     * Overrides the toString method to get a binary representation of the BitSet
     *
     * @param {number=} base
     * @returns string A binary string
     */
    'toString': function(base) {

      var data = this['data'];

      if (!base)
        base = 2;

      // If base is power of two
      if ((base & (base - 1)) === 0 && base < 36) {

        var ret = '';
        var len = 2 + Math.log(4294967295/*Math.pow(2, WORD_LENGTH)-1*/) / Math.log(base) | 0;

        for (var i = data.length - 1; i >= 0; i--) {

          var cur = data[i];

          // Make the number unsigned
          if (cur < 0)
            cur += 4294967296 /*Math.pow(2, WORD_LENGTH)*/;

          var tmp = cur.toString(base);

          if (ret !== '') {
            // Fill small positive numbers with leading zeros. The +1 for array creation is added outside already
            ret += '0'.repeat(len - tmp.length - 1);
          }
          ret += tmp;
        }

        if (this['_'] === 0) {

          ret = ret.replace(/^0+/, '');

          if (ret === '')
            ret = '0';
          return ret;

        } else {
          // Pad the string with ones
          ret = '1111' + ret;
          return ret.replace(/^1+/, '...1111');
        }

      } else {

        if ((2 > base || base > 36))
          throw SyntaxError('Invalid base');

        var ret = [];
        var arr = [];

        // Copy every single bit to a new array
        for (var i = data.length; i--; ) {

          for (var j = WORD_LENGTH; j--; ) {

            arr.push(data[i] >>> j & 1);
          }
        }

        do {
          ret.unshift(divide(arr, base).toString(base));
        } while (!arr.every(function(x) {
          return x === 0;
        }));

        return ret.join('');
      }
    },
    /**
     * Check if the BitSet is empty, means all bits are unset
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * bs1.isEmpty() ? 'yes' : 'no'
     *
     * @returns {boolean} Whether the bitset is empty
     */
    'isEmpty': function() {

      if (this['_'] !== 0)
        return false;

      var d = this['data'];

      for (var i = d.length - 1; i >= 0; i--) {
        if (d[i] !== 0)
          return false;
      }
      return true;
    },
    /**
     * Calculates the number of bits set
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * var num = bs1.cardinality();
     *
     * @returns {number} The number of bits set
     */
    'cardinality': function() {

      if (this['_'] !== 0) {
        return Infinity;
      }

      var s = 0;
      var d = this['data'];
      for (var i = 0; i < d.length; i++) {
        var n = d[i];
        if (n !== 0)
          s += popCount(n);
      }
      return s;
    },
    /**
     * Calculates the Most Significant Bit / log base two
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * var logbase2 = bs1.msb();
     *
     * var truncatedTwo = Math.pow(2, logbase2); // May overflow!
     *
     * @returns {number} The index of the highest bit set
     */
    'msb': Math['clz32'] ?
    function() {

      if (this['_'] !== 0) {
        return Infinity;
      }

      var data = this['data'];

      for (var i = data.length; i-- > 0;) {

        var c = Math['clz32'](data[i]);

        if (c !== WORD_LENGTH) {
          return (i * WORD_LENGTH) + WORD_LENGTH - 1 - c;
        }
      }
      return Infinity;
    } :
    function() {

      if (this['_'] !== 0) {
        return Infinity;
      }

      var data = this['data'];

      for (var i = data.length; i-- > 0;) {

        var v = data[i];
        var c = 0;

        if (v) {

          for (; (v >>>= 1) > 0; c++) {
          }
          return (i * WORD_LENGTH) + c;
        }
      }
      return Infinity;
    },
    /**
     * Calculates the number of trailing zeros
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * var ntz = bs1.ntz();
     *
     * @returns {number} The index of the lowest bit set
     */
    'ntz': function() {

      var data = this['data'];

      for (var j = 0; j < data.length; j++) {
        var v = data[j];

        if (v !== 0) {

          v = (v ^ (v - 1)) >>> 1; // Set v's trailing 0s to 1s and zero rest

          return (j * WORD_LENGTH) + popCount(v);
        }
      }
      return Infinity;
    },
    /**
     * Calculates the Least Significant Bit
     *
     * Ex:
     * bs1 = new BitSet(10);
     *
     * var lsb = bs1.lsb();
     *
     * @returns {number} The index of the lowest bit set
     */
    'lsb': function() {

      var data = this['data'];

      for (var i = 0; i < data.length; i++) {

        var v = data[i];
        var c = 0;

        if (v) {

          var bit = (v & -v);

          for (; (bit >>>= 1); c++) {

          }
          return WORD_LENGTH * i + c;
        }
      }
      return this['_'] & 1;
    },
    /**
     * Compares two BitSet objects
     *
     * Ex:
     * bs1 = new BitSet(10);
     * bs2 = new BitSet(10);
     *
     * bs1.equals(bs2) ? 'yes' : 'no'
     *
     * @param {BitSet} val A bitset object
     * @returns {boolean} Whether the two BitSets have the same bits set (valid for indefinite sets as well)
     */
    'equals': function(val) {

      parse(P, val);

      var t = this['data'];
      var p = P['data'];

      var t_ = this['_'];
      var p_ = P['_'];

      var tl = t.length - 1;
      var pl = p.length - 1;

      if (p_ !== t_) {
        return false;
      }

      var minLength = tl < pl ? tl : pl;
      var i = 0;

      for (; i <= minLength; i++) {
        if (t[i] !== p[i])
          return false;
      }

      for (i = tl; i > pl; i--) {
        if (t[i] !== p_)
          return false;
      }

      for (i = pl; i > tl; i--) {
        if (p[i] !== t_)
          return false;
      }
      return true;
    },
    [Symbol.iterator]: function () {

      var d = this['data'];
      var ndx = 0;

      if (this['_'] === 0) {

        // Find highest index with something meaningful
        var highest = 0;
        for (var i = d.length - 1; i >= 0; i--) {
          if (d[i] !== 0) {
            highest = i;
            break;
          }
        }

        return {
          'next': function () {
            var n = ndx >>> WORD_LOG;

            return {
              'done': n > highest || n === highest && (d[n] >>> ndx) === 0,
              'value': n > highest ? 0 : (d[n] >>> ndx++) & 1
            };
          }
        };

      } else {
        // Endless iterator!
        return {
          'next': function () {
            var n = ndx >>> WORD_LOG;

            return {
              'done': false,
              'value': n < d.length ? (d[n] >>> ndx++) & 1 : 1,
            };
          }
        };
      }
    }
  };

  BitSet['fromBinaryString'] = function(str) {

    return new BitSet('0b' + str);
  };

  BitSet['fromHexString'] = function(str) {

    return new BitSet('0x' + str);
  };

  BitSet['Random'] = function(n) {

    if (n === undefined || n < 0) {
      n = WORD_LENGTH;
    }

    var m = n % WORD_LENGTH;

    // Create an array, large enough to hold the random bits
    var t = [];
    var len = Math.ceil(n / WORD_LENGTH);

    // Create an bitset instance
    var s = Object.create(BitSet.prototype);

    // Fill the vector with random data, uniformally distributed
    for (var i = 0; i < len; i++) {
      t.push(Math.random() * 4294967296 | 0);
    }

    // Mask out unwanted bits
    if (m > 0) {
      t[len - 1] &= (1 << m) - 1;
    }

    s['data'] = t;
    s['_'] = 0;
    return s;
  };

  if (typeof define === 'function' && define['amd']) {
    define([], function() {
      return BitSet;
    });
  } else if (typeof exports === 'object') {
    Object.defineProperty(exports, "__esModule", { 'value': true });
    BitSet['default'] = BitSet;
    BitSet['BitSet'] = BitSet;
    module['exports'] = BitSet;
  } else {
    root['BitSet'] = BitSet;
  }

})(this);

},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Empty = exports.Rep = exports.Emb = exports.Rename = exports.Proj = exports.Not = exports.Join = exports.Uni = exports.Seq = exports.Lit = exports.State = exports.Project = void 0;
const stateMachine_1 = require("./stateMachine");
Object.defineProperty(exports, "State", { enumerable: true, get: function () { return stateMachine_1.State; } });
Object.defineProperty(exports, "Lit", { enumerable: true, get: function () { return stateMachine_1.Lit; } });
Object.defineProperty(exports, "Seq", { enumerable: true, get: function () { return stateMachine_1.Seq; } });
Object.defineProperty(exports, "Uni", { enumerable: true, get: function () { return stateMachine_1.Uni; } });
Object.defineProperty(exports, "Join", { enumerable: true, get: function () { return stateMachine_1.Join; } });
Object.defineProperty(exports, "Not", { enumerable: true, get: function () { return stateMachine_1.Not; } });
Object.defineProperty(exports, "Proj", { enumerable: true, get: function () { return stateMachine_1.Proj; } });
Object.defineProperty(exports, "Rename", { enumerable: true, get: function () { return stateMachine_1.Rename; } });
Object.defineProperty(exports, "Emb", { enumerable: true, get: function () { return stateMachine_1.Emb; } });
Object.defineProperty(exports, "Rep", { enumerable: true, get: function () { return stateMachine_1.Rep; } });
Object.defineProperty(exports, "Empty", { enumerable: true, get: function () { return stateMachine_1.Empty; } });
const sheetParser_1 = require("./sheetParser");
Object.defineProperty(exports, "Project", { enumerable: true, get: function () { return sheetParser_1.Project; } });

},{"./sheetParser":3,"./stateMachine":4}],3:[function(require,module,exports){
"use strict";
/**
 * This file describes the parser that turns spreadsheets into abstract
 * syntax trees, for later compilation into formulas of a programming language.
 * It's agnostic as to exactly what that programming language is; to adapt
 * it to a particular language, implement Compiler<T> where T is the base class
 * of formulas in that language.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = exports.EnclosureComponent = exports.GrammarComponent = exports.CellComponent = exports.constructHeader = exports.SlashHeader = exports.FlagHeader = exports.NotHeader = exports.MaybeHeader = exports.CommentHeader = exports.LiteralHeader = exports.EmbedHeader = exports.Header = exports.TabularComponent = exports.CellPosition = void 0;
const stateMachine_1 = require("./stateMachine");
const util_1 = require("./util");
const DEFAULT_SATURATION = 0.1;
const DEFAULT_VALUE = 1.0;
/**
 * A convenience class encapsulating information about where a cell
 * is.  Every component of the abstract syntax tree has one of these;
 * if it's a cell, that's just its position on a spreadsheet; if it's a
 * complex component, it's the position of its first cell.
 *
 * By convention we treat the spreadsheet itself as a component with
 * its first cell at -1, -1.
 */
class CellPosition {
    constructor(sheet, row = -1, col = -1) {
        this.sheet = sheet;
        this.row = row;
        this.col = col;
    }
    toString() {
        return `${this.sheet}:${this.row}:${this.col}`;
    }
}
exports.CellPosition = CellPosition;
const DUMMY_POSITION = new CellPosition("?", -1, -1);
class TabularComponent {
    constructor(text, position) {
        this.text = text;
        this.position = position;
    }
    mark(devEnv) { }
    markError(devEnv, shortMsg, msg) {
        devEnv.markError(this.position.sheet, this.position.row, this.position.col, shortMsg, msg, "error");
    }
    markWarning(devEnv, shortMsg, msg) {
        devEnv.markError(this.position.sheet, this.position.row, this.position.col, shortMsg, msg, "warning");
    }
}
exports.TabularComponent = TabularComponent;
/**
 * A Header is a cell in the top row of a table, consisting of one of
 *
 * * the name of a tape, like "text" or "gloss"
 * * a unary operator like "maybe" followed by a valid Header (e.g. "maybe text")
 * * two valid Headers joined by a slash (e.g. "text/gloss")
 * * a valid Header in parentheses (e.g. "(text)")
 * * a comment (e.g. "% text")
 *
 * (We treat commented-out headers specially, because they turn everything
 * in their column into no-ops.)
 *
 * Header objects are responsible for:
 *
 * * providing a static parse method that takes a list of input tokens and returns
 *   lists of [Header, remnant] pairs.  These are combined into a quick-n-dirty
 *   parser-combinator engine at the bottom of this file.  (If you want to understand
 *   how this works, google for "parser combinators"; it's an old trick to quickly
 *   write a recursive descent parser in plain code, without using a parsing library.)
 *
 * * compiling the cells beneath them into States, and merging them (usually by
 *   concatenation) with cells to their right.
 *
 * * knowing what colors the foreground and background of the header cell should be
 */
class Header extends TabularComponent {
    constructor(text) {
        super(text, DUMMY_POSITION);
    }
    getColor(saturation = DEFAULT_SATURATION, value = DEFAULT_VALUE) {
        return util_1.RGBtoString(...util_1.HSVtoRGB(this.hue, saturation, value));
    }
    mark(devEnv) {
        const color = this.getColor(0.1);
        devEnv.markHeader(this.position.sheet, this.position.row, this.position.col, color);
    }
    compile(cell, namespace) {
        throw new Error('Not implemented');
    }
    merge(state, other) {
        return stateMachine_1.Seq(state, other);
    }
    compileAndMerge(cell, namespace, rightNeighbor) {
        const compiledCell = this.compile(cell, namespace);
        if (rightNeighbor == undefined) {
            return compiledCell;
        }
        compiledCell.state = this.merge(compiledCell.state, rightNeighbor);
        return compiledCell;
    }
}
exports.Header = Header;
/**
 * AtomicHeader is the ancestor class of all single-token headers, like "embed" and
 * literals (e.g. "text").
 */
class AtomicHeader extends Header {
    get hue() {
        const str = this.text + "abcde"; // otherwise short strings are boring colors
        var hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return (hash & 0xFF) / 255;
    }
    static *parseTarget(target, constructor, input) {
        if (input.length == 0 || input[0] != target) {
            return;
        }
        yield [new constructor(input[0]), input.slice(1)];
    }
}
/**
 * EmbedHeaders lead to the complilation of EmbedStates.
 */
class EmbedHeader extends AtomicHeader {
    compile(cell, namespace) {
        const compiledCell = new EmbedComponent(this, cell);
        compiledCell.state = stateMachine_1.Emb(cell.text, namespace);
        return compiledCell;
    }
    static *parse(input) {
        yield* super.parseTarget("embed", EmbedHeader, input);
    }
}
exports.EmbedHeader = EmbedHeader;
/**
 * LiteralHeaders are references to a particular tape name (e.g. "text")
 */
class LiteralHeader extends AtomicHeader {
    compile(cell, namespace) {
        const compiledCell = new HeadedCellComponent(this, cell);
        compiledCell.state = stateMachine_1.Lit(this.text, cell.text);
        return compiledCell;
    }
    static *parse(input) {
        if (input.length == 0 || ALL_RESERVED.indexOf(input[0]) != -1) {
            return;
        }
        yield [new LiteralHeader(input[0]), input.slice(1)];
    }
}
exports.LiteralHeader = LiteralHeader;
/**
 * Commented-out headers also comment out any cells below them; the cells just act as
 * Empty() states.
 *
 * Note that "%" is not a unary operator the way others are; the *parse method
 * for this doesn't bother parsing any remnant, and just effectively consumes everything.
 * If the programmer is failing to construct a header, for example, and comments it
 * out in the meantime, we don't want to keep parsing it and fail, we just want
 * to accept that whatever in this line isn't a header, it's a comment.
 */
class CommentHeader extends Header {
    get hue() {
        return 0;
    }
    mark(devEnv) {
        devEnv.markComment(this.position.sheet, this.position.row, this.position.col);
    }
    compile(cell, namespace) {
        return new CommentComponent(cell);
    }
    static *parse(input) {
        if (input.length == 0 || input[0] != "%") {
            return;
        }
        yield [new CommentHeader('%'), []];
    }
}
exports.CommentHeader = CommentHeader;
/**
 * The ancestor class of unary header operators like "maybe", "not", and "@"
 * (the joining operator that we use to implement flags).
 */
class UnaryHeader extends Header {
    constructor(text, child) {
        super(text);
        this.child = child;
    }
    get hue() {
        return this.child.hue;
    }
    compile(cell, namespace) {
        const childCell = this.child.compile(cell, namespace);
        const compiledCell = new UnaryHeadedCellComponent(this, cell, childCell);
        compiledCell.state = childCell.state;
        return compiledCell;
    }
    static *parseTarget(target, constructor, childParser, input) {
        if (input.length == 0 || input[0] != target) {
            return;
        }
        for (const [child, rem] of childParser(input.slice(1))) {
            yield [new constructor(target, child), rem];
        }
    }
}
/**
 * Header that constructs optional parsers, e.g. "maybe text"
 */
class MaybeHeader extends UnaryHeader {
    static *parse(input) {
        yield* super.parseTarget("maybe", MaybeHeader, NON_COMMENT_EXPR, input);
    }
    compile(cell, namespace) {
        const childCell = this.child.compile(cell, namespace);
        const compiledCell = new UnaryHeadedCellComponent(this, cell, childCell);
        compiledCell.state = stateMachine_1.Maybe(childCell.state);
        return compiledCell;
    }
}
exports.MaybeHeader = MaybeHeader;
/**
 * Header that constructs negations, e.g. "not text"
 */
class NotHeader extends UnaryHeader {
    static *parse(input) {
        yield* super.parseTarget("not", NotHeader, NON_COMMENT_EXPR, input);
    }
    compile(cell, namespace) {
        const childCell = this.child.compile(cell, namespace);
        const compiledCell = new UnaryHeadedCellComponent(this, cell, childCell);
        compiledCell.state = stateMachine_1.Maybe(childCell.state);
        return compiledCell;
    }
}
exports.NotHeader = NotHeader;
/**
 * A FlagHeader handles headers like "@x"; it joins x:X with whatever
 * follows rather than concatenating it.
 *
 * Note that FlagHeader binds more tightly than other unary operators,
 * e.g. while "maybe" in "maybe text/gloss" has "text/gloss" as its child,
 * "@" in "@text/gloss" only has "@" as its child.
 */
class FlagHeader extends UnaryHeader {
    merge(state, other) {
        return stateMachine_1.Join(state, other);
    }
    static *parse(input) {
        yield* super.parseTarget("@", FlagHeader, SUBEXPR, input);
    }
}
exports.FlagHeader = FlagHeader;
class BinaryHeader extends Header {
    constructor(text, child1, child2) {
        super(text);
        this.child1 = child1;
        this.child2 = child2;
    }
    get hue() {
        return this.child1.hue;
    }
    static *parseTarget(target, input) {
        if (input.length == 0) {
            return;
        }
        for (const [t1, rem1] of SUBEXPR(input)) {
            if (rem1.length == 0 || rem1[0] != target) {
                return;
            }
            for (const [t2, rem2] of NON_COMMENT_EXPR(rem1.slice(1))) {
                yield [new SlashHeader(t1, t2), rem2];
            }
        }
    }
}
class SlashHeader extends BinaryHeader {
    constructor(child1, child2) {
        super("/", child1, child2);
        this.child1 = child1;
        this.child2 = child2;
    }
    /**
     * This isn't ordinarily called, usually compileAndMerge handles compilation
     * of SlashHeader.  But
     * when another header has a SlashHeader child, like "@(x/y)", this would
     * be called.
     */
    compile(cell, namespace) {
        const childCell1 = this.child1.compile(cell, namespace);
        const childCell2 = this.child2.compile(cell, namespace);
        const compiledCell = new BinaryHeadedCellComponent(this, cell, childCell1, childCell2);
        compiledCell.state = stateMachine_1.Seq(childCell1.state, childCell2.state);
        return compiledCell;
    }
    compileAndMerge(cell, namespace, rightNeighbor) {
        const childCell2 = this.child2.compileAndMerge(cell, namespace, rightNeighbor);
        const childCell1 = this.child1.compileAndMerge(cell, namespace, childCell2.state);
        const compiledCell = new BinaryHeadedCellComponent(this, cell, childCell1, childCell2);
        compiledCell.state = childCell1.state;
        return compiledCell;
    }
    static *parse(input) {
        yield* super.parseTarget("/", input);
    }
}
exports.SlashHeader = SlashHeader;
const SYMBOL = ["(", ")", "%", "/", '@'];
const RESERVED = ["embed", "maybe", "not"];
const ALL_RESERVED = [...SYMBOL, ...RESERVED];
const SUBEXPR = Alt([LiteralHeader.parse,
    EmbedHeader.parse,
    FlagHeader.parse,
    Parens]);
const NON_COMMENT_EXPR = Alt([MaybeHeader.parse,
    NotHeader.parse,
    SlashHeader.parse,
    SUBEXPR]);
const EXPR = Alt([CommentHeader.parse,
    NON_COMMENT_EXPR]);
function Alt(children) {
    return function* (input) {
        for (const child of children) {
            yield* child(input);
        }
    };
}
function* Parens(input) {
    if (input.length == 0 || input[0] != "(") {
        return;
    }
    for (const [t, rem] of NON_COMMENT_EXPR(input.slice(1))) {
        if (rem.length == 0 || rem[0] != ")") {
            return;
        }
        yield [t, rem.slice(1)];
    }
}
const tokenizer = new RegExp("\\s+|(" +
    SYMBOL.map(s => "\\" + s).join("|") +
    ")");
function tokenize(text) {
    return text.split(tokenizer).filter((s) => s !== undefined && s !== '');
}
/**
 * This is the main function that the rest of the libraries interact with;
 * they provide a string and (hopefully) get a parser in return.
 */
function constructHeader(headerText, pos = DUMMY_POSITION) {
    const pieces = tokenize(headerText);
    var result = [...EXPR(pieces)];
    // result is a list of [header, remaining_tokens] pairs.  
    // we only want results where there are no remaining tokens.
    result = result.filter(([t, r]) => r.length == 0);
    if (result.length == 0) {
        // if there are no results, the programmer made a syntax error
        throw new Error(`Cannot parse header: ${headerText}`);
    }
    if (result.length > 1) {
        // the grammar above should be unambiguous, so we shouldn't get 
        // multiple results, but just in case...
        throw new Error(`Ambiguous header, cannot parse: ${headerText}.` +
            " This probably isn't your fault.");
    }
    result[0][0].position = pos;
    return result[0][0];
}
exports.constructHeader = constructHeader;
class CellComponent extends TabularComponent {
    constructor(text, position) {
        super(text, position);
    }
    toString() {
        return `${this.text}:${this.position}`;
    }
}
exports.CellComponent = CellComponent;
/**
 * A GrammarComponent is a component of our tabular syntax tree
 * that is associated with a grammar -- that is, a [State] of the
 * state machine.
 *
 * At construction, GrammarComponents do not have any specific state
 * yet, they're all associated with [TrivialState]s until they compile()
 * is called on them, at which point their state is calculated.  (This is
 * because GrammarComponents are constructed as soon as their first cell is,
 * but the grammar they represent typically depends on cells to the right
 * and below them.)
 */
class GrammarComponent extends TabularComponent {
    constructor() {
        super(...arguments);
        this.state = stateMachine_1.Empty();
        /**
         * The previous sibling of the component (i.e. the component that shares
         * the same parent, but appeared before this component, usually directly
         * above this one).
         *
         * Only EnclosureComponents have siblings, but it's more convenient
         * to define it here so that certain clients (like unit tests) don't have
         * to deal with the templating aspects.
         */
        this.sibling = undefined;
        /**
         * The last-defined child of the component (i.e. of all the components
         * enclosed by this component, the last one.)  As [SheetParser] builds the
         * tree, this value will change; when a new child is added, it's set to the
         * parent's child and the previous child (if any) becomes the new child's
         * sibling.
         */
        this.child = undefined;
    }
    compile(namespace, devEnv) { }
    runChecks(namespace, devEnv) {
        if (this.sibling != undefined) {
            this.sibling.runChecks(namespace, devEnv);
        }
        if (this.child != undefined) {
            this.child.runChecks(namespace, devEnv);
        }
    }
}
exports.GrammarComponent = GrammarComponent;
const BINARY_OPS = {
    "or": stateMachine_1.Uni,
    "concat": stateMachine_1.Seq,
    "join": stateMachine_1.Join,
};
const BUILT_IN_OPS = new Set([...Object.keys(BINARY_OPS),
    "table",
    "test",
    "testnot"]);
/* There are some reserved words like "maybe" that aren't built in ops, but
 * for sanity's sake you still can't use them as symbols */
const RESERVED_WORDS = new Set([...BUILT_IN_OPS,
    "maybe",
    "not",
    "embed"]);
/**
 * An enclosure represents a single-cell unit containing a command or identifier (call that the "startCell"),
 * and a rectangular region describing further details (like the parameters of the command,
 * or what is to be assigned to the identifier).
 *
 * An enclosure contains all cells to the right of it, and the cells below the cells to the right
 * (more precisely, a enclosure with its startCell in (r,c) contains all cells (x,y) where x >= r
 * and y > c), until a non-empty cell is encountered that is below the startCell or in a column before
 * the startCell.
 *
 * For example, if I is the ID cell, E are cells contained in the enclosure, X is the cell that "breaks"
 * the enclosure, and O are cells not contained in the enclosure:
 *
 * 0 0 0 0
 * 0 I E E E E
 *     E E E E
 *     E E E E
 *   X 0 0 0 0
 *     0 0 0 0
 *
 * Enclosures can be nested, and often are.  E.g., below, 2 contains all the A's, 3
 * contains all the B's, and 1 contains 2 and 3.
 *
 * 1 2 A A A A A
 *     A A A A A
 *
 *   3 B B B B
 *     B B B B
 *
 * Each enclosure keeps reference only to its last child.  Previous children are kept
 * as "sibling" references within that child.  Above, 3 is 1's child, and 2 is 3's
 * sibling.  Tables are also children; the table consisting of A's is 2's child.
 * For the most part, and operator like 3 will be a binary operation where
 * 2 and the B table are its params.  (For example, 3 might represent "or", and thus
 * the union of the grammar represented by 2 and the grammar represented by the B table.
 *
 */
class EnclosureComponent extends GrammarComponent {
    constructor(startCell) {
        super(startCell.text, startCell.position);
        this.startCell = startCell;
        this.specRow = -1;
        this.parent = undefined;
        this.specRow = startCell.position.row;
    }
    mark(devEnv) {
        devEnv.markCommand(this.position.sheet, this.position.row, this.position.col);
    }
    addHeader(header, devEnv) {
        // can only add a header if there aren't any child enclosures yet.
        // well, we could, but it makes a particular kind of syntax error
        // hard to spot
        if (this.child == undefined) {
            this.child = new ContentsComponent(header.text, header.position);
        }
        if (!(this.child instanceof ContentsComponent)) {
            throw new Error("Closure already has a child; cannot add a header to it.");
        }
        this.child.addHeader(header, devEnv);
    }
    addContent(cell, devEnv) {
        if (!(this.child instanceof ContentsComponent)) {
            throw new Error("Trying to add content to a non-table");
        }
        this.child.addContent(cell, devEnv);
    }
    compile(namespace, devEnv) {
        // we only ever end up in this base EncloseComponent compile if it wasn't
        // a known operator.
        this.markError(devEnv, "Unknown operator", `Operator ${this.text} not recognized.`);
    }
    addChild(child, devEnv) {
        if (this.child instanceof ContentsComponent) {
            throw new Error("Can't add an operator to a line that already has headers.");
        }
        if (this.child != undefined && this.child.position.col != child.position.col) {
            child.markWarning(devEnv, "Unexpected operator", "This operator is in an unexpected column.  Did you mean for it " +
                `to be in column ${this.child.position.col}, ` +
                `so that it's under the operator in cell ${this.child.position}?`);
        }
        child.parent = this;
        child.sibling = this.child;
        this.child = child;
        return child;
    }
    toString() {
        return `Enclosure(${this.position})`;
    }
    get sheet() {
        if (this.parent == undefined) {
            throw new Error("Stack empty; something has gone very wrong");
        }
        return this.parent.sheet;
    }
}
exports.EnclosureComponent = EnclosureComponent;
class AssignmentComponent extends EnclosureComponent {
    compile(namespace, devEnv) {
        // first compile the previous sibling.  note that all siblings
        // of an assignment statement should be an assignment statement, since
        // being an assignment statement is, by definition, having a sheet component
        // as your immediate parent.
        if (this.sibling != undefined) {
            this.sibling.compile(namespace, devEnv);
        }
        if (RESERVED_WORDS.has(this.text)) {
            // oops, assigning to a reserved word
            this.markError(devEnv, "Assignment to reserved word", "This cell has to be a symbol name for an assignment statement, but you're assigning to the " +
                `reserved word ${this.text}.  Choose a different symbol name.`);
            if (this.child != undefined) {
                // compile the child just in case there are useful errors to display
                this.child.compile(namespace, devEnv);
            }
            return;
        }
        if (this.sibling != undefined && !(this.sibling instanceof AssignmentComponent)) {
            this.sibling.markError(devEnv, "Wayward operator", "The result of this operator does not get assigned to anything.");
        }
        if (this.child == undefined) {
            // oops, empty "right side" of the assignment!
            this.markWarning(devEnv, "Missing content", `This looks like an assignment to a symbol ${this.text}, ` +
                "but there's nothing to the right of it.");
            return;
        }
        this.child.compile(namespace, devEnv);
        this.state = this.child.state;
        if (namespace.hasSymbol(this.text)) {
            // oops, trying to assign to a symbol that already is assigned to!
            this.markError(devEnv, "Redefining existing symbol", `You've already assigned something to the symbol ${this.text}`);
            return;
        }
        namespace.addSymbol(this.text, this.child.state);
    }
}
class BinaryOpComponent extends EnclosureComponent {
    compile(namespace, devEnv) {
        const op = BINARY_OPS[this.text];
        if (this.child == undefined) {
            this.markError(devEnv, `Missing argument to '${this.text}'`, `'${this.text}' is missing a second argument; ` +
                "something should be in the cell to the right.");
            return;
        }
        if (this.sibling == undefined) {
            this.markError(devEnv, `Missing argument to '${this.text}'`, `'${this.text}' is missing a first argument; ` +
                "something should be in a cell above this.");
            return;
        }
        this.sibling.compile(namespace, devEnv);
        this.child.compile(namespace, devEnv);
        this.state = op(this.sibling.state, this.child.state);
    }
}
class TableComponent extends EnclosureComponent {
    compile(namespace, devEnv) {
        if (this.child == undefined) {
            this.markError(devEnv, "Empty table", "'table' seems to be missing a table; " +
                "something should be in the cell to the right.");
            return;
        }
        if (this.sibling != undefined) {
            this.sibling.compile(namespace, devEnv);
            // we don't do anything with the sibling, but we
            // compile it anyway in case there are errors in it the
            // programmer may want to know about
            this.markError(devEnv, "Table overwrite warning", "'table' here will obliterate the preceding " +
                `content at ${this.sibling.position}.`);
        }
        this.child.compile(namespace, devEnv);
        this.state = this.child.state;
    }
}
class AbstractTestSuiteComponent extends EnclosureComponent {
    constructor() {
        super(...arguments);
        this.tests = [];
    }
    /**
     * "test" is an operator that takes two tables, one above (spatially speaking)
     * and one to the right, and makes sure that each line of the one to the right
     * has an output when semijoined to the table above.
     *
     * Test doesn't make any change to the State it returns; adding a "test" below
     * a grammar returns the exact same grammar as otherwise.
     */
    compile(namespace, devEnv) {
        if (this.sibling == undefined) {
            this.markError(devEnv, "Wayward test", "There should be something above this 'test' command for us to test");
            return;
        }
        const sibling = this.sibling.compile(namespace, devEnv);
        if (this.child == undefined) {
            this.markWarning(devEnv, "Empty test", "'test' seems to be missing something to test; " +
                "something should be in the cell to the right.");
            this.state = this.sibling.state;
            return; // whereas usually we result in the empty grammar upon erroring, in this case
            // we don't want to let a flubbed "test" command obliterate the grammar
            // it was meant to test!
        }
        if (!(this.child instanceof ContentsComponent)) {
            this.markError(devEnv, "Cannot execute tests", "You can't nest another operator to the right of a test block, " +
                "it has to be a content table.");
            this.state = this.sibling.state;
            return;
        }
        this.child.compile(namespace, devEnv);
        this.tests = this.child.rows;
        this.state = this.sibling.state;
    }
}
class TestSuiteComponent extends AbstractTestSuiteComponent {
    runChecks(namespace, devEnv) {
        super.runChecks(namespace, devEnv);
        for (const test of this.tests) {
            // the appropriate operation here is the left semijoin between my state
            // and the test's state
            const testingState = stateMachine_1.Semijoin(this.state, test.state);
            const results = [...testingState.generate()];
            if (results.length == 0) {
                test.markError(devEnv, `Test failed: ${test.text}`, "This row cannot be generated by the grammar above.");
            }
        }
    }
}
class TestNotSuiteComponent extends AbstractTestSuiteComponent {
    constructor() {
        super(...arguments);
        this.tests = [];
    }
    runChecks(namespace, devEnv) {
        super.runChecks(namespace, devEnv);
        for (const test of this.tests) {
            // the appropriate operation here is the left semijoin between my state
            // and the test's state
            const testingState = stateMachine_1.Semijoin(this.state, test.state);
            const results = [...testingState.generate()];
            if (results.length != 0) {
                test.markError(devEnv, `Test failed: ${test.text}`, "This row can be generated by the grammar above.");
            }
        }
    }
}
/**
 * A [SheetComponent] is basically an EnclosureComponent without
 * a parent component; a sheet is always the outermost component of
 * any component tree.
 */
class SheetComponent extends EnclosureComponent {
    constructor(name) {
        super(new CellComponent(name, new CellPosition(name)));
        this.name = name;
    }
    addHeader(header) {
        throw new Error("This appears to be a header, but what is it a header for?");
    }
    compile(namespace, devEnv) {
        if (this.child == undefined) {
            return;
        }
        this.child.compile(namespace, devEnv);
        if (!(this.child instanceof AssignmentComponent)) {
            this.child.markError(devEnv, "Wayward operator", "The result of this operator does not get assigned to anything.");
        }
    }
    get sheet() {
        return this;
    }
}
/**
 * A ContentsComponent is a rectangular region of the grid consisting of a header row
 * and cells beneath each header.  For example,
 *
 *      text, gloss
 *      foo, run
 *      moo, jump
 *      goo, climb
 *
 * Each header indicates how each cell beneath it should be interpreted; "foo"
 * should be interpret as "text", whatever that happens to mean in the programming
 * language in question.  Note that these are not necessarily well-formed database
 * tables; it's entirely possible to get tables where the same
 * header appears multiple times.
 */
class ContentsComponent extends GrammarComponent {
    constructor() {
        super(...arguments);
        this.headersByCol = {};
        this.rows = [];
        this.firstHeader = undefined;
    }
    addHeader(header, devEnv) {
        // remember it by its column number, because that's how content
        // cells will be asking for it.
        this.headersByCol[header.position.col] = header;
    }
    addContent(cell, devEnv) {
        // make sure we have a header
        const header = this.headersByCol[cell.position.col];
        if (header == undefined) {
            if (cell.text.length != 0) {
                cell.markWarning(devEnv, `Ignoring cell: ${cell.text}`, "Cannot associate this cell with any valid header above; ignoring.");
            }
            return;
        }
        // make a table row if we need one
        if (this.rows.length == 0 ||
            cell.position.row != this.rows[this.rows.length - 1].position.row) {
            const newRow = new RowComponent(cell.text, cell.position);
            this.rows.push(newRow);
        }
        // add the content
        const lastRow = this.rows[this.rows.length - 1];
        lastRow.addContent(header, cell);
    }
    compile(namespace, devEnv) {
        this.rows.map(row => row.compile(namespace, devEnv));
        var rowStates = this.rows.map(row => row.state);
        rowStates = rowStates.filter(state => !(state instanceof stateMachine_1.TrivialState));
        this.state = stateMachine_1.Uni(...rowStates);
    }
    runChecks(ns, devEnv) {
        this.rows.map(row => row.runChecks(ns, devEnv));
    }
    toString() {
        return `Table(${this.position})`;
    }
}
class RowComponent extends GrammarComponent {
    constructor() {
        super(...arguments);
        this.uncompiledCells = [];
        this.compiledCells = [];
    }
    compile(namespace, devEnv) {
        var resultState = undefined;
        for (var i = this.uncompiledCells.length - 1; i >= 0; i--) {
            const [header, cell] = this.uncompiledCells[i];
            const compiledCell = header.compileAndMerge(cell, namespace, resultState);
            compiledCell.mark(devEnv);
            // if it was zero, ignore the result of the merge   
            if (cell.text.length > 0 && !(compiledCell.state instanceof stateMachine_1.TrivialState)) {
                resultState = compiledCell.state;
            }
            this.compiledCells = [compiledCell, ...this.compiledCells];
        }
        if (resultState == undefined) {
            // everything was comments or empty
            resultState = stateMachine_1.Empty();
        }
        this.state = resultState;
    }
    addContent(header, cell) {
        this.uncompiledCells.push([header, cell]);
    }
    runChecks(ns, devEnv) {
        this.compiledCells.map(cell => cell.runChecks(ns, devEnv));
    }
}
class SingleCellComponent extends GrammarComponent {
    constructor(cell) {
        super(cell.text, cell.position);
        this.cell = cell;
    }
}
class HeadedCellComponent extends SingleCellComponent {
    constructor(header, cell) {
        super(cell);
        this.header = header;
    }
    mark(devEnv) {
        const color = this.header.getColor(0.1);
        devEnv.markContent(this.position.sheet, this.position.row, this.position.col, color);
    }
    compile(namespace, devEnv) {
        throw new Error("Not implemented; shouldn't be calling this.");
    }
}
class CommentComponent extends SingleCellComponent {
    mark(devEnv) {
        devEnv.markComment(this.position.sheet, this.position.row, this.position.col);
    }
    compile(namespace, devEnv) { }
}
class UnaryHeadedCellComponent extends HeadedCellComponent {
    constructor(header, cell, child) {
        super(header, cell);
        this.child = child;
    }
    runChecks(ns, devEnv) {
        this.child.runChecks(ns, devEnv);
    }
}
class BinaryHeadedCellComponent extends HeadedCellComponent {
    constructor(header, cell, child1, child2) {
        super(header, cell);
        this.child1 = child1;
        this.child2 = child2;
    }
    runChecks(ns, devEnv) {
        this.child1.runChecks(ns, devEnv);
        this.child2.runChecks(ns, devEnv);
        if (this.child1 instanceof EmbedComponent || this.child2 instanceof EmbedComponent) {
            this.cell.markWarning(devEnv, "Embed inside slash header", "Why are you putting an 'embed' inside a slash header? That's weird.");
        }
    }
}
class EmbedComponent extends HeadedCellComponent {
    runChecks(ns, devEnv) {
        if (this.text.length == 0) {
            return;
        }
        const symbol = ns.get(this.cell.text);
        if (symbol == undefined) {
            this.cell.markError(devEnv, `Cannot find symbol ${this.cell.text}`, `Cannot find symbol ${this.cell.text}.`);
        }
    }
}
/**
 * Determines whether a line is empty
 * @param row A list of strings, representing the cell text along that row
 * @returns True if the line is empty
 */
function isLineEmpty(row) {
    if (row.length == 0) {
        return true;
    }
    for (let cellText of row) {
        if (cellText.trim().length != 0) {
            return false;
        }
    }
    return true;
}
function constructOp(cell, devEnv) {
    var newEnclosure;
    if (cell.position.col == 0) {
        newEnclosure = new AssignmentComponent(cell);
    }
    else if (cell.text in BINARY_OPS) {
        newEnclosure = new BinaryOpComponent(cell);
    }
    else if (cell.text == "table") {
        newEnclosure = new TableComponent(cell);
    }
    else if (cell.text == "test") {
        newEnclosure = new TestSuiteComponent(cell);
    }
    else if (cell.text == "testnot") {
        newEnclosure = new TestNotSuiteComponent(cell);
    }
    else {
        newEnclosure = new EnclosureComponent(cell);
    }
    newEnclosure.mark(devEnv);
    return newEnclosure;
}
/**
 * A SheetParser turns a grid of cells into abstract syntax tree (AST) components, which in
 * turn are interpreted or compiled into a computer language.  This parser is agnostic as to
 * what exactly these components represent or how they'll be handled later, it's just a parser
 * for a particular class of tabular languages.
 */
class Project {
    constructor(devEnv) {
        this.devEnv = devEnv;
        this.globalNamespace = new stateMachine_1.Namespace();
        this.defaultSheetName = '';
        this.sheets = {};
    }
    allSymbols() {
        return this.globalNamespace.allSymbols();
    }
    getSymbol(symbolName) {
        var ns;
        if (this.defaultSheetName != "") {
            ns = this.globalNamespace.getNamespace(this.defaultSheetName);
        }
        else {
            ns = this.globalNamespace;
        }
        return ns.get(symbolName);
    }
    getTapeNames(symbolName) {
        const startState = this.globalNamespace.get(symbolName);
        if (startState == undefined) {
            throw new Error(`Cannot find symbol ${symbolName}`);
        }
        const results = [];
        const stack = new stateMachine_1.CounterStack(2);
        for (const tapeName of startState.getRelevantTapes(stack)) {
            const header = constructHeader(tapeName, new CellPosition("?", -1, -1));
            results.push([tapeName, header.getColor(0.2)]);
        }
        return results;
    }
    parse(symbolName, inputs, maxResults = Infinity, randomize = false, maxRecursion = 4, maxChars = 1000) {
        var startState = this.getSymbol(symbolName);
        if (startState == undefined) {
            throw new Error(`Cannot find symbol ${symbolName}`);
        }
        const inputLiterals = [];
        for (const tapeName in inputs) {
            const value = inputs[tapeName];
            const inputLiteral = stateMachine_1.Lit(tapeName, value);
            inputLiterals.push(inputLiteral);
        }
        if (inputLiterals.length > 0) {
            const inputSeq = stateMachine_1.Seq(...inputLiterals);
            startState = stateMachine_1.Join(inputSeq, startState);
        }
        const gen = startState.generate(randomize, maxRecursion, maxChars);
        return util_1.iterTake(gen, maxResults);
    }
    generate(symbolName, maxResults = Infinity, randomize = false, maxRecursion = 4, maxChars = 1000) {
        const startState = this.getSymbol(symbolName);
        if (startState == undefined) {
            throw new Error(`Cannot find symbol ${symbolName}`);
        }
        const gen = startState.generate(randomize, maxRecursion, maxChars);
        return util_1.iterTake(gen, maxResults);
    }
    addSheetAux(sheetName) {
        if (sheetName in this.sheets) {
            // already loaded it, don't have to do anything
            return;
        }
        if (!this.devEnv.hasSource(sheetName)) {
            // this is an error, but we don't freak out about it here.
            // later on, we'll put errors on any cells for which we can't
            // resolve the reference.
            return;
        }
        const cells = this.devEnv.loadSource(sheetName);
        // parse the cells into an abstract syntax tree
        const sheetComponent = this.parseCells(sheetName, cells);
        // put the raw cells into the sheetComponent, for interfaces
        // that need them (like the sidebar of the GSuite add-on)
        //const 
        // Create a new namespace for this sheet and add it to the 
        // global namespace
        const sheetNamespace = new stateMachine_1.Namespace();
        this.globalNamespace.addNamespace(sheetName, sheetNamespace);
        // Compile it
        sheetComponent.compile(sheetNamespace, this.devEnv);
        // Store it in .sheets
        this.sheets[sheetName] = sheetComponent;
        for (const requiredSheet of this.globalNamespace.requiredNamespaces) {
            this.addSheetAux(requiredSheet);
        }
    }
    addSheet(sheetName) {
        // add this sheet and any sheets that it refers to
        this.addSheetAux(sheetName);
        // now run checks over the whole project
        for (const sheetName of Object.keys(this.sheets)) {
            const localNamespace = this.globalNamespace.getNamespace(sheetName);
            this.sheets[sheetName].runChecks(localNamespace, this.devEnv);
        }
        this.defaultSheetName = sheetName;
    }
    getSheet(sheetName) {
        if (!(sheetName in this.sheets)) {
            throw new Error(`Sheet ${sheetName} not found in project`);
        }
        return this.sheets[sheetName];
    }
    getDefaultSheet() {
        if (this.defaultSheetName == '') {
            throw new Error("Asking for the default sheet of a project to which no sheets have been added");
        }
        return this.getSheet(this.defaultSheetName);
    }
    getEnclosureOperators(cells) {
        const results = new Set(BUILT_IN_OPS);
        /* here is where we might also scan the files for definitions
        of new enclosure operators.  but we don't have the capability for
        custom operators yet. */
        return results;
    }
    parseCells(sheetName, cells) {
        const enclosureOps = this.getEnclosureOperators(cells);
        // topEnclosure refers to whatever enclosure is currently on top 
        // of the stack.  Since each enclosure knows what its parent is, we 
        // don't explicitly have to maintain a stack structure, we can just
        // use the .parent property of the current topEnclosure when we need
        // to pop.  We start with the one big enclosure that encompasses the 
        // whole sheet, with startCell (-1,-1)
        var topEnclosure = new SheetComponent(sheetName);
        // Now iterate through the cells, left-to-right top-to-bottom
        for (var rowIndex = 0; rowIndex < cells.length; rowIndex++) {
            const row = cells[rowIndex];
            if (isLineEmpty(row)) {
                continue;
            }
            const rowIsComment = row[0].trim().startsWith('%%');
            for (var colIndex = 0; colIndex < row.length; colIndex++) {
                const cellText = row[colIndex].trim();
                const position = new CellPosition(sheetName, rowIndex, colIndex);
                const cell = new CellComponent(cellText, position);
                if (rowIsComment) {
                    const comment = new CommentComponent(cell);
                    comment.mark(this.devEnv);
                    continue;
                }
                while (cellText.length > 0
                    && colIndex <= topEnclosure.position.col) {
                    // it breaks the previous enclosure; pop that off
                    if (topEnclosure.parent == undefined) {
                        throw new Error("The enclosure stack is empty somehow; " +
                            "something has gone very wrong.");
                    }
                    topEnclosure = topEnclosure.parent;
                    topEnclosure.specRow = rowIndex;
                }
                if (topEnclosure.specRow > -1 && rowIndex > topEnclosure.specRow) {
                    // we're inside an enclosure, after the header row
                    topEnclosure.addContent(cell, this.devEnv);
                    continue;
                }
                if (cellText.length == 0) {
                    // all of the following steps require there to be some explicit content
                    continue;
                }
                // either we're still in the spec row, or there's no spec row yet
                if (enclosureOps.has(cellText) || position.col == 0) {
                    // it's an operation, which starts a new enclosure
                    const newEnclosure = constructOp(cell, this.devEnv);
                    try {
                        topEnclosure = topEnclosure.addChild(newEnclosure, this.devEnv);
                    }
                    catch (e) {
                        cell.markError(this.devEnv, `Unexpected operator: ${cell.text}`, "This looks like an operator, but only a header can follow a header.");
                    }
                    continue;
                }
                // it's a header
                var header;
                try {
                    // parse the header into a Header object
                    header = constructHeader(cell.text, cell.position);
                    // color it properly in the interface
                    header.mark(this.devEnv);
                    topEnclosure.addHeader(header, this.devEnv);
                }
                catch (e) {
                    cell.markError(this.devEnv, `Invalid header: ${cell.text}`, "Attempted to parse this cell as a header, but could not.");
                }
            }
        }
        return topEnclosure.sheet;
    }
}
exports.Project = Project;

},{"./stateMachine":4,"./util":6}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Maybe = exports.Empty = exports.Rep = exports.Any = exports.Rename = exports.Proj = exports.Emb = exports.Not = exports.Semijoin = exports.Join = exports.Uni = exports.Seq = exports.Literalizer = exports.Lit = exports.NegationState = exports.RenameState = exports.ProjectionState = exports.EmbedState = exports.RepetitionState = exports.JoinState = exports.UnionState = exports.ConcatState = exports.TrivialState = exports.LiteralState = exports.AnyCharState = exports.State = exports.Namespace = exports.CounterStack = void 0;
const tapes_1 = require("./tapes");
/**
 * CounterStack
 *
 * A convenience class that works roughly like Python's collections.Counter.  Just
 * note that add() is non-destructive; it returns a new Counter without changing the original.
 * So use it like:
 *
 *  * counter = counter.add("verb");
 *
 * We use this to make sure we don't recurse an impractical number of times, like
 * infinitely.
 *
 * Infinite recursion is *correct* behavior for a grammar that's
 * genuinely infinite, but because this system is meant to be embedded in a
 * programming language meant for beginner programmers,
 * we default to allowing four recursions before stopping recursion.  Advanced
 * programmers will be able to turn this off and allow infinite recursion, but they
 * have to take an extra step to do so.
 */
class CounterStack {
    constructor(max = 4) {
        this.max = max;
        this.stack = {};
    }
    add(key) {
        const result = new CounterStack(this.max);
        result.stack[key] = 0;
        Object.assign(result.stack, this.stack);
        result.stack[key] += 1;
        return result;
    }
    get(key) {
        return (key in this.stack) ? this.stack[key] : 0;
    }
    exceedsMax(key) {
        return this.get(key) >= this.max;
    }
    tostring() {
        return JSON.stringify(this.stack);
    }
}
exports.CounterStack = CounterStack;
/**
 * Namespace
 *
 * A Namespace object associates symbols with names, and resolves references
 * to them.  They are nested; when a symbol cannot be resolved in the current
 * namespace, it's passed to the parent namespace which tries to resolve it.
 *
 * While these namespaces, structurally, form a tree, at the moment we only
 * actually support one level of nesting.  There is a global namespace associated
 * with a whole Project, and a child namespace for each source sheet within the
 * project.  Project sources are currently assumed to be flat: that is to say,
 * there's nothing like a "directory" or "nested module" structure at the moment.
 * (The reason for that is that we conceptualize a project as being composed
 * primarily within a spreadsheet editor like Google Sheets or Excel, and there
 * is no metaphor within a spreadsheet by which worksheets are grouped in a
 * directory-like structure.  From the POV of the spreadsheet user, worksheets
 * are unordered and not hierarchically structured, and so likewise Gramble
 * project source files are unordered and not hierarchically structured, too.)
 */
class Namespace {
    constructor(symbols = {}) {
        this.symbols = symbols;
        this.parent = undefined;
        this.childNamespaces = {};
        this.requiredNamespaces = new Set();
    }
    hasSymbol(name) {
        return name in this.symbols;
    }
    addSymbol(name, state) {
        if (name in this.symbols) {
            throw new Error(`Redefining symbol ${name}`);
        }
        this.symbols[name] = state;
    }
    allSymbols() {
        const result = Object.keys(this.symbols);
        for (const namespaceName in this.childNamespaces) {
            const childNamespace = this.childNamespaces[namespaceName];
            for (const symbol of childNamespace.allSymbols()) {
                result.push(`${namespaceName}.${symbol}`);
            }
        }
        return result;
    }
    addNamespace(name, namespace) {
        if (name in this.childNamespaces) {
            throw new Error(`Redefining namespace ${name}`);
        }
        this.childNamespaces[name] = namespace;
        namespace.parent = this;
    }
    getNamespace(name) {
        if (!(name in this.childNamespaces)) {
            throw new Error(`Cannot find namespace ${name}`);
        }
        return this.childNamespaces[name];
    }
    getNamePieces(namePieces) {
        if (namePieces.length == 1 && namePieces[0] in this.symbols) {
            return this.symbols[namePieces[0]];
        }
        if (namePieces[0] in this.childNamespaces) {
            const remainder = namePieces.slice(1);
            return this.childNamespaces[namePieces[0]].getNamePieces(remainder);
        }
        if (this.parent != undefined) {
            return this.parent.getNamePieces(namePieces);
        }
        return undefined;
    }
    get(name) {
        const pieces = name.split(".");
        return this.getNamePieces(pieces);
    }
    /**
     * When an EmbedState is constructed, it needs to "register" the symbol
     * name it is going to want later, so that we can (if necessary) load and
     * parse the source file that contains that symbol.
     */
    register(symbolName) {
        const pieces = symbolName.split(".");
        if (pieces.length == 1) {
            return;
        }
        if (pieces.length > 2) {
            // At some point we may want to allow registration of
            // symbols with nested namespaces, but right now that's
            // a whole can of worms.
            throw new Error(`${symbolName} is not a valid reference, ` +
                " because nested namespaces (e.g. X.Y.Z) are not currently supported.");
        }
        if (this.parent == undefined) {
            // I don't think this can actually happen.
            throw new Error("Something strange happened; trying to register " +
                "a symbol name in the global namespace");
        }
        this.parent.requiredNamespaces.add(pieces[0]);
    }
}
exports.Namespace = Namespace;
/**
 * State
 *
 * State is the basic class of the parser.  It encapsulate the current state of the parse; you can think
 * of it like a pointer into the state graph, if we were to ever construct that graph, which we don't.
 * Rather, a State encapsulates the *information* that that node would have represented.
 *
 * For example, imagine an automaton that recognizes the literal "hello".  We could implement this as an
 * explicit graph of nodes, where each node leads to the next by consuming a particular letter (state 0 leads
 * to 1 by consuming "h", state 1 leads to 2 by consuming "e", etc.).  Our pointer into this graph
 * basically represents two pieces of information, what the word is ("hello") and
 * how far into it we are.  We could also represent this information as an object { text: string, index: number }.
 * Rather than pre-compute each of these nodes, we can say that this object returns (upon matching) another
 * object {text: string, index: number+1}... until we exceed the length of the literal, of course.  This
 * idea, in general, allows us to avoid creating explicit state graphs that can be exponentially huge,
 * although it comes with its own pitfalls.
 *
 * For our purposes, a State is anything that can, upon being queried with a [tape, char] pair,
 * return the possible successor states it can get to.
 *
 * Many kinds of States have to contain references to other states (like an
 * [EmbedState], which lets us embed grammars inside other grammars, keeps a point to the current parse state inside
 * that embedded grammar).  The structure of State components ends up being roughly isomorphic to the grammar that it's
 * parsing (e.g. if the grammar is (A+(B|C)), then the start State that we begin in will have the same structure,
 * it'll be a [ConcatState] of (A and a [UnionState] of (B and C)).  Then as the parse goes on, the State will
 * simplify bit-by-bit, like once A is recognized, the current state will just be one corresponding to B|C, and
 * if B fails, the current state will just be C.
 *
 * For the purposes of the algorithm, there are three crucial functions of States:
 *
 *  * ndQuery(tape, char): What states can this state get to, compatible with a given tape/character
 *  * dQuery(tape, char): Calls ndQuery and rearranges the outputs so that any specific character can
 *                      only lead to one state.
 *  * accepting(): Whether this state is a final state, meaning it constitutes a complete parse
 */
class State {
    constructor() {
        this.relevantTapes = undefined;
    }
    /**
     * accepting
     *
     * Whether the state is accepting (i.e. indicates that we have achieved a complete parse).  (What is typically rendered as a "double circle"
     * in a state machine.) Note that, since this is a recursive state machine, getting to an accepting state doesn't necessarily
     * mean that the *entire* grammar has completed; we might just be in a subgrammar.  In this case, accepting() isn't the signal that we
     * can stop parsing, just that we've reached a complete parse within the subgrammar.  For example, [ConcatState] checks whether its left
     * child is accepting() to determine whether to move on and start parsing its right child.
     *
     * @param symbolStack A [CounterStack] that keeps track of symbols, used for preventing infinite recursion.
     * @returns true if the state is an accepting state (i.e., constitutes a complete parse)
     */
    accepting(symbolStack) {
        return false;
    }
    /**
     * deterministic Query
     *
     * Queries the state so that the results are deterministic (or more accurately, so that all returned
     * transitions are disjoint).  (There can still be multiple results; when we query ANY:ANY, for example.)
     *
     * This looks a bit complicated (and it kind of is) but what it's doing is handing off the query to
     * ndQuery, then combining results so that there's no overlap between the tokens.  For example, say ndQuery yields
     * two tokens X and Y, and they have no intersection.  Then we're good, we just yield those.  But if they
     * do have an intersection, we need to return three paths:
     *
     *    X&Y (leading to the UnionState of the states X and Y would have led to)
     *    X-Y (leading to the state X would have led to)
     *    Y-X (leading to the state Y would have led to)
     *
     * @param tape A Tape object identifying the name/type/vocabulary of the relevant tape
     * @param target A Token identifying what characters we need to match
     * @param symbolStack A [CounterStack] that keeps track of symbols (for embedding grammars), used for preventing infinite recursion
     * @returns A tuple <tape, match, matched, nextState>, where:
     *      * tape is the tape we matched on,
     *      * match is the intersection of the original target and our match,
     *      * matched is whether we actually made a match or ignored it (for being on the wrong tape)
     *      * nextState is the state the matched transition leads to
     */
    *dQuery(tape, target, symbolStack, randomize) {
        var results = [];
        var nextStates = [...this.ndQuery(tape, target, symbolStack, randomize)];
        for (var [tape, bits, matched, next] of nextStates) {
            if (tape.numTapes == 0) {
                results.push([tape, bits, matched, next]);
                continue;
            }
            var newResults = [];
            for (var [otherTape, otherBits, otherMatched, otherNext] of results) {
                if (tape.tapeName != otherTape.tapeName) {
                    newResults.push([otherTape, otherBits, otherMatched, otherNext]);
                    continue;
                }
                const intersection = bits.and(otherBits);
                if (!intersection.isEmpty()) {
                    const union = new UnionState(next, otherNext);
                    newResults.push([tape, intersection, matched || otherMatched, union]);
                }
                bits = bits.andNot(intersection);
                otherBits = otherBits.andNot(intersection);
                if (!otherBits.isEmpty()) {
                    newResults.push([otherTape, otherBits, otherMatched, otherNext]);
                }
            }
            results = newResults;
            if (!bits.isEmpty()) {
                results.push([tape, bits, matched, next]);
            }
        }
        yield* results;
    }
    /**
     * Performs a breadth-first traversal of the graph.  This will be the function that most
     * clients will be calling.
     *
     * Note that there's no corresponding "parse" function, only "generate".  To do parses, we
     * join the grammar with a grammar corresponding to the query.  E.g., if we wanted to parse
     * { text: "foo" } in grammar X, we would construct JoinState(LiteralState("text", "foo"), X).
     * The reason for this is that it allows us a diverse collection of query types for free, by
     * choosing an appropriate "query grammar" to join X with.
     *
     * @param [maxRecursion] The maximum number of times the grammar can recurse; for infinite recursion pass Infinity.
     * @param [maxChars] The maximum number of steps any one traversal can take (roughly == the total number of characters
     *                    output to all tapes)
     * @returns a generator of { tape: string } dictionaries, one for each successful traversal.
     */
    *generate(randomize = false, maxRecursion = 4, maxChars = 1000) {
        const allTapes = new tapes_1.TapeCollection();
        this.collectVocab(allTapes, []);
        const initialOutput = new tapes_1.MultiTapeOutput();
        var stateQueue = [[initialOutput, this]];
        const symbolStack = new CounterStack(maxRecursion);
        var chars = 0;
        while (stateQueue.length > 0 && chars < maxChars) {
            var nextQueue = [];
            for (const [prevOutput, prevState] of stateQueue) {
                if (prevState.accepting(symbolStack)) {
                    yield* prevOutput.toStrings();
                }
                for (const [tape, c, matched, newState] of prevState.dQuery(allTapes, tapes_1.ANY_CHAR, symbolStack, randomize)) {
                    if (!matched) {
                        throw new Error("Something went wrong, got all the way through without a match");
                    }
                    const nextOutput = prevOutput.add(tape, c);
                    nextQueue.push([nextOutput, newState]);
                }
            }
            stateQueue = nextQueue;
            chars++;
        }
    }
    /**
     * Collects all explicitly mentioned characters in the grammar for all tapes.
     *
     * @param tapes A TapeCollection for holding found characters
     * @param stateStack What symbols we've already collected from, to prevent inappropriate recursion
     * @returns vocab
     */
    collectVocab(tapes, stateStack) { }
    /**
     * Collects the names of all tapes relevant to this state.  The names are those
     * that this state would "see" (that is, if this state refers to a RenameState,
     * it uses the renamed tape name, not whatever that tape is referred to "inside"
     * the RenameState).
     *
     * This will be the same result as if we called "collectVocab" on this state with an empty
     * TapeCollection, but we don't go to the trouble of collecting the character vocabulary.
     */
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = new Set();
        }
        return this.relevantTapes;
    }
    caresAbout(tape) {
        if (tape.tapeName == "__ANY_TAPE__")
            return true;
        const symbolStack = new CounterStack(2);
        return this.getRelevantTapes(symbolStack).has(tape.tapeName);
    }
}
exports.State = State;
/**
 * Abstract base class for both LiteralState and AnyCharState,
 * since they share the same query algorithm template.
 *
 * In order to implement TextState, a descendant class must implement
 * firstToken() (giving the first token that needs to be matched) and
 * successor() (returning the state to which we would translate upon successful
 * matching of the token).
 */
class TextState extends State {
    constructor(tapeName) {
        super();
        this.tapeName = tapeName;
    }
    *ndQuery(tape, target, symbolStack) {
        const matchedTape = tape.matchTape(this.tapeName);
        if (matchedTape == undefined) {
            yield [tape, target, false, this];
            return;
        }
        if (this.accepting(symbolStack)) {
            return;
        }
        const bits = this.firstToken(matchedTape);
        const result = matchedTape.match(bits, target);
        const nextState = this.successor();
        yield [matchedTape, result, true, nextState];
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = new Set([this.tapeName]);
        }
        return this.relevantTapes;
    }
}
/**
 * The state that recognizes/emits any character on a specific tape;
 * implements the "dot" in regular expressions.
 */
class AnyCharState extends TextState {
    get id() {
        return `${this.tapeName}:(ANY)`;
    }
    firstToken(tape) {
        return tape.any();
    }
    successor() {
        return new TrivialState();
    }
}
exports.AnyCharState = AnyCharState;
/**
 * Recognizese/emits a literal string on a particular tape.
 * Inside, it's just a string like "foo"; upon successfully
 * matching "f" we construct a successor state looking for
 * "oo", and so on.
 *
 * The first time we construct a LiteralState, we just pass in
 * the text argument, and leave tokens empty.  (This is because,
 * at the initial point of construction of a LiteralState, we
 * don't know what the total character vocabulary of the grammar is
 * yet, and thus can't tokenize it into Tokens yet.)  On subsequent
 * constructions, like in successor(), we've already tokenized,
 * so we pass the remainder of the tokens into the tokens argument.
 * It doesn't really matter what we pass into text in subsequent
 * constructions, it's not used except for debugging, so we just pass
 * in the original text.
 */
class LiteralState extends TextState {
    constructor(tape, text, tokens = []) {
        super(tape);
        this.text = text;
        this.tokens = tokens;
    }
    get id() {
        return `${this.tapeName}:${this.text}[${this.text.length - this.tokens.length}]`;
    }
    accepting(symbolStack) {
        return this.tokens.length == 0;
    }
    collectVocab(tapes, stateStack) {
        this.tokens = tapes.tokenize(this.tapeName, this.text);
    }
    firstToken(tape) {
        return this.tokens[0];
    }
    successor() {
        const newTokens = this.tokens.slice(1);
        const newText = this.text;
        return new LiteralState(this.tapeName, newText, newTokens);
    }
}
exports.LiteralState = LiteralState;
/**
 * Recognizes the empty grammar.  This is occassionally
 * useful in implementing other states (e.g. when
 * you need a state that's accepting but won't go anywhere).
 */
class TrivialState extends State {
    constructor() {
        super();
    }
    get id() {
        return "0";
    }
    accepting(symbolStack) {
        return true;
    }
    *ndQuery(tape, target, symbolStack) { }
}
exports.TrivialState = TrivialState;
/**
 * The abstract base class of all States with two state children
 * (e.g. [JoinState], [ConcatState], [UnionState]).
 * States that conceptually might have infinite children (like Union)
 * we treat as right-recursive binary (see for
 * example the helper function [Uni] which converts lists of
 * states into right-braching UnionStates).
 */
class BinaryState extends State {
    constructor(child1, child2, relevantTapes = undefined) {
        super();
        this.child1 = child1;
        this.child2 = child2;
        this.relevantTapes = relevantTapes;
    }
    collectVocab(tapes, stateStack) {
        this.child1.collectVocab(tapes, stateStack);
        this.child2.collectVocab(tapes, stateStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            const child1tapes = this.child1.getRelevantTapes(stateStack);
            const child2tapes = this.child2.getRelevantTapes(stateStack);
            this.relevantTapes = new Set([...child1tapes, ...child2tapes]);
        }
        return this.relevantTapes;
    }
    get id() {
        return `${this.constructor.name}(${this.child1.id},${this.child2.id})`;
    }
    accepting(symbolStack) {
        return this.child1.accepting(symbolStack) && this.child2.accepting(symbolStack);
    }
}
/**
 * ConcatState represents the current state in a concatenation A+B of two grammars.  It
 * is a [BinaryState], meaning it has two children; sequences ABCDEF are constructed as
 * A+(B+(C+(D+(E+F)))).
 *
 * The one thing that makes ConcatState a bit tricky is that they're the only part of the grammar
 * where there is a precedence order, which in a naive implementation can lead to a deadlock situation.
 * For example, if we have ConcatState(LiteralState("A","a"), LiteralState("B","b")), then the material
 * on tape A needs to be emitted/matched before the material on tape B.  But then consider the opposite,
 * ConcatState(LiteralState("B","b"), LiteralState("A","a")).  That grammar describes the same database,
 * but looks for the material in opposite tape order.  If we join these two, the first is emitting on A and
 * waiting for a match, but the second can't match it because it'll only get there later.  There are several
 * possible solutions for this, but the simplest by far is to implement ConcatState so that it can always emit/match
 * on any tape that any of its children refer to.  Basically, it goes through its children, and if child1
 * returns but doesn't match (meaning it doesn't care about tape T), it asks child2.  Then it returns the
 * appropriate ConcatState consisting of the unmatched material.
 */
class ConcatState extends BinaryState {
    constructor(child1, child2, child1Done = false, relevantTapes = undefined) {
        super(child1, child2, relevantTapes);
        this.child1Done = child1Done;
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (!this.caresAbout(tape)) {
            // if neither child cares, just short circuit this rather than bother with all the rest
            yield [tape, target, false, this];
            return;
        }
        if (this.child1Done) {
            if (!this.child2.caresAbout(tape)) {
                return;
            }
            for (const [c2tape, c2text, c2matched, c2next] of this.child2.dQuery(tape, target, symbolStack, randomize)) {
                const successor = new ConcatState(this.child1, c2next, true, this.relevantTapes);
                yield [c2tape, c2text, c2matched, successor];
            }
            return;
        }
        // new simpler algorithm below
        if (this.child1.accepting(symbolStack)) {
            const successor = new ConcatState(this.child1, this.child2, true);
            yield* successor.dQuery(tape, target, symbolStack, randomize);
        }
        if (this.child1.caresAbout(tape)) {
            for (const [c1tape, c1text, c1matched, c1next] of this.child1.dQuery(tape, target, symbolStack, randomize)) {
                const successor = new ConcatState(c1next, this.child2, false, this.relevantTapes);
                yield [c1tape, c1text, c1matched, successor];
            }
            return;
        }
        // child2 must care, otherwise one of the previous conditions would have triggered
        for (const [c2tape, c2text, c2matched, c2next] of this.child2.dQuery(tape, target, symbolStack, randomize)) {
            const successor = new ConcatState(this.child1, c2next, false, this.relevantTapes);
            yield [c2tape, c2text, c2matched, successor];
        }
        // old, more circuitous, algorithm
        /*
        // We can yield from child2 if child1 is accepting, OR if child1 doesn't care about the requested tape,
        // but if child1 is accepting AND doesn't care about the requested tape, we don't want to yield twice;
        // that leads to duplicate results.  yieldedAlready is how we keep track of that.
        var yieldedAlready = false;

        for (const [c1tape, c1text, c1matched, c1next] of
                this.child1.dQuery(tape, target, symbolStack, randomize)) {

            if (c1matched) {
                const successor = new ConcatState(c1next, this.child2, false, this.relevantTapes);
                yield [c1tape, c1text, c1matched, successor];
                continue;
            }
   
            // child1 not interested in the requested tape, the first character on the tape must be
            // (if it exists at all) in child2.
            for (const [c2tape, c2text, c2matched, c2next] of
                    this.child2.dQuery(tape, target, symbolStack, randomize)) {
                const successor = new ConcatState(this.child1, c2next, false, this.relevantTapes);
                yield [c2tape, c2text, c2matched, successor];
                yieldedAlready = true;
            }
        }

        if (!yieldedAlready && this.child1.accepting(symbolStack)) {
            const successor = new ConcatState(this.child1, this.child2, true);
            yield* successor.dQuery(tape, target, symbolStack, randomize);
        }

        */
    }
}
exports.ConcatState = ConcatState;
/**
 * UnionStates are very simple, they just have a left child and a right child,
 * and upon querying they yield from the first and then yield from the second.
 *
 * So note that UnionStates are only around initally; they don't construct
 * successor UnionStates, their successors are just the successors of their children.
 */
class UnionState extends BinaryState {
    accepting(symbolStack) {
        return this.child1.accepting(symbolStack) || this.child2.accepting(symbolStack);
    }
    getChildren() {
        var children = [];
        if (this.child1 instanceof UnionState) {
            children = children.concat(this.child1.getChildren());
        }
        else {
            children.push(this.child1);
        }
        if (this.child2 instanceof UnionState) {
            children = children.concat(this.child2.getChildren());
        }
        else {
            children.push(this.child2);
        }
        return children;
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (!randomize) {
            yield* this.child1.dQuery(tape, target, symbolStack, randomize);
            yield* this.child2.dQuery(tape, target, symbolStack, randomize);
            return;
        }
        const children = this.getChildren();
        const child = children[Math.floor(Math.random() * children.length)];
        yield* child.dQuery(tape, target, symbolStack, randomize);
    }
}
exports.UnionState = UnionState;
/**
 * Convenience function that takes two generators, and yields from the
 * second only if it can't yield from the first.  This is handy in situations
 * like the implementation of join, where if we yielded from both we would
 * constantly be yielding the same states.
 */
function* iterPriorityUnion(iter1, iter2) {
    var yieldedAlready = false;
    for (const output of iter1) {
        yield output;
        yieldedAlready = true;
    }
    if (!yieldedAlready) {
        yield* iter2;
    }
}
/**
 * Implements a left semijoin (which we use for unit testing).
 *
 * To test that an entry E is in the grammar G, we execute
 *
 *      Semijoin(G, E)
 *
 * This requires that there be an entry in G that matches every field in E.
 * (There could be additional fields in the relevant entries in G that you don't
 * care about.  In practice it's difficult to anticipate all the different
 * fields that G might have in a complex grammar, to make sure E has all of them.)
 */
class SemijoinState extends BinaryState {
    /**
    * We factor out the logic into a separate function (one that doesn't specifically
    * refer to the child1/child2 properties of this object) because it's the same algorithm
    * used twice in a descendent class, JoinState.  A join is just the priority union of the
    * left and right semijoins, and the right semijoin is just the left semijoin with the
    * children reversed.  So we let the caller decide which child is "c1" and which is "c2" for
    * the purposes of the semijoin.
    */
    *ndQueryLeft(tape, target, c1, c2, symbolStack, randomize) {
        for (const [c1tape, c1target, c1matched, c1next] of c1.dQuery(tape, target, symbolStack, randomize)) {
            if (c1tape.numTapes == 0) {
                // c1 contained a ProjectionState that hides the original tape; move on without
                // asking c2 to match anything.
                const successor = this.successor(c1next, c2);
                yield [c1tape, c1target, c1matched, successor];
                continue;
            }
            for (const [c2tape, c2target, c2matched, c2next] of c2.dQuery(c1tape, c1target, symbolStack, randomize)) {
                const successor = this.successor(c1next, c2next);
                yield [c2tape, c2target, c1matched || c2matched, successor];
            }
        }
    }
    successor(newChild1, newChild2) {
        return new SemijoinState(newChild1, newChild2, this.relevantTapes);
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        yield* this.ndQueryLeft(tape, target, this.child1, this.child2, symbolStack, randomize);
    }
}
/**
 * The JoinState implements the natural join (in the relational algebra sense)
 * for two automata. This is a fundamental operation in the parser, as we implement
 * parsing as a traversal of a corresponding join state.  You can think of join(X,Y)
 * as yielding from the intersection of X and Y on tapes that they share, and the product
 * on tapes that they don't share.
 *
 * The algorithm is simplified by the fact that join(X, Y) can be implemented the union
 * of the left and right semijoins (or, put another way, the left semijoin of (X,Y) and
 * the left semijoin of (Y,X)).  The left semijoin (X,Y) just consists of querying X, then
 * taking the result of that and querying Y, and yielding the result of that.
 *
 * Because the ordinary union of these would lead to the same states twice, we use the
 * priority union instead.
 */
class JoinState extends SemijoinState {
    successor(newChild1, newChild2) {
        return new JoinState(newChild1, newChild2, this.relevantTapes);
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        const leftJoin = this.ndQueryLeft(tape, target, this.child1, this.child2, symbolStack, randomize);
        const rightJoin = this.ndQueryLeft(tape, target, this.child2, this.child1, symbolStack, randomize);
        if (this.child1.accepting(symbolStack)) {
            yield* iterPriorityUnion(rightJoin, leftJoin);
            return;
        }
        yield* iterPriorityUnion(leftJoin, rightJoin);
    }
}
exports.JoinState = JoinState;
/**
 * Abstract base class for states with only one child state.  Typically, UnaryStates
 * handle queries by forwarding on the query to their child, and doing something special
 * before or after.  For example, [EmbedStates] do a check a stack of symbol names to see
 * whether they've passed the allowable recursion limit, and [RenameState]s change what
 * the different tapes are named.
 *
 * Note that [UnaryState.child] is a getter, rather than storing an actual child.  This is
 * because [EmbedState] doesn't actually store its child, it grabs it from a symbol table instead.
 * (If it tried to take it as a param, or construct it during its own construction, this wouldn't
 * work, because the EmbedState's child can be that EmbedState itself.)
 */
class UnaryState extends State {
    get id() {
        return `${this.constructor.name}(${this.child.id})`;
    }
    collectVocab(tapes, stateStack) {
        this.child.collectVocab(tapes, stateStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = this.child.getRelevantTapes(stateStack);
        }
        return this.relevantTapes;
    }
    accepting(symbolStack) {
        return this.child.accepting(symbolStack);
    }
}
/**
 * RepetitionState implements the Kleene star, plus, question mark, and in general
 * repetitions between N and M times.  (E.g. x{2,3} matching x two or three times.)
 *
 * The slightly odd part of implementing RepetitionState, compared to other states, is that only
 * RepetitionState needs to remember the initial state of its child.  That is, all the
 * other UnaryStates only keep track of the current state of the child parse.  RepetitionState,
 * however, needs to be able to *restart* the child.  To do that, it
 * keeps around the original child state, so that it can construct its appropriate successor
 * when the current child state is finished.
 *
 * Note that the below algorithm is fairly similar to [ConcatState]; in the future
 * we might want to partially unify these the way we did [LiteralState] and [AnyCharState].
 */
class RepetitionState extends UnaryState {
    constructor(child, minRepetitions = 0, maxRepetitions = Infinity, index = 0, initialChild) {
        super();
        this.child = child;
        this.minRepetitions = minRepetitions;
        this.maxRepetitions = maxRepetitions;
        this.index = index;
        this.initialChild = initialChild;
    }
    collectVocab(tapes, stateStack) {
        this.initialChild.collectVocab(tapes, stateStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = this.initialChild.getRelevantTapes(stateStack);
        }
        return this.relevantTapes;
    }
    accepting(symbolStack) {
        return this.index >= this.minRepetitions &&
            this.index <= this.maxRepetitions &&
            this.child.accepting(symbolStack);
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (this.index > this.maxRepetitions) {
            return;
        }
        var yieldedAlready = false;
        if (this.child.accepting(symbolStack)) {
            // we just started, or the child is accepting, so our successor increases its index
            // and starts again with child.
            const successor = new RepetitionState(this.initialChild, this.minRepetitions, this.maxRepetitions, this.index + 1, this.initialChild);
            for (const result of successor.dQuery(tape, target, symbolStack, randomize)) {
                yield result;
                yieldedAlready = true;
            }
        }
        if (yieldedAlready) {
            return;
        }
        for (const [childTape, childText, childMatched, childNext] of this.child.dQuery(tape, target, symbolStack, randomize)) {
            if (!childMatched) { // child doesn't care, neither do we
                yield [childTape, childText, false, this];
                continue;
            }
            yield [childTape, childText, childMatched, new RepetitionState(childNext, this.minRepetitions, this.maxRepetitions, this.index, this.initialChild)];
        }
    }
}
exports.RepetitionState = RepetitionState;
/**
 * The parser that handles arbitrary subgrammars referred to by a symbol name; this is what makes
 * recursion possible.
 *
 * Like most such implementations, EmbedState's machinery serves to delay the construction of a child
 * state, since this child may be the EmbedState itself, or refer to this EmbedState by indirect recursion.
 * So instead of having a child at the start, it just has a symbol name and a reference to a symbol table.
 *
 * The successor states of the EmbedState may have an explicit child, though: the successors of that initial
 * child state.  (If we got the child from the symbol table every time, we'd just end up trying to match its
 * first letter again and again.)  We keep track of that through the _child member, which is initially undefined
 * but which we specify when constructing EmbedState's successor.
 */
class EmbedState extends UnaryState {
    constructor(symbolName, namespace, _child = undefined, relevantTapes = undefined) {
        super();
        this.symbolName = symbolName;
        this.namespace = namespace;
        this._child = _child;
        // need to register our symbol name with the namespace, in case
        // the referred-to symbol is defined in a file we haven't yet loaded.
        namespace.register(symbolName);
        this.relevantTapes = relevantTapes;
    }
    get id() {
        return `${this.constructor.name}(${this.symbolName})`;
    }
    collectVocab(tapes, stateStack) {
        if (stateStack.indexOf(this.symbolName) != -1) {
            return;
        }
        const newStack = [...stateStack, this.symbolName];
        this.child.collectVocab(tapes, newStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            if (stateStack.exceedsMax(this.symbolName)) {
                this.relevantTapes = new Set();
            }
            else {
                const newStack = stateStack.add(this.symbolName);
                this.relevantTapes = this.child.getRelevantTapes(newStack);
            }
        }
        return this.relevantTapes;
    }
    get child() {
        if (this._child == undefined) {
            this._child = this.namespace.get(this.symbolName);
            if (this._child == undefined) {
                //throw new Error(`Cannot find symbol name ${this.symbolName}`);
                this._child = Empty();
            }
        }
        return this._child;
    }
    accepting(symbolStack) {
        if (symbolStack.exceedsMax(this.symbolName)) {
            return false;
        }
        return this.child.accepting(symbolStack.add(this.symbolName));
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (symbolStack.exceedsMax(this.symbolName)) {
            return;
        }
        symbolStack = symbolStack.add(this.symbolName);
        for (const [childchildTape, childTarget, childMatched, childNext] of this.child.ndQuery(tape, target, symbolStack, randomize)) {
            const successor = new EmbedState(this.symbolName, this.namespace, childNext, this.relevantTapes);
            yield [childchildTape, childTarget, childMatched, successor];
        }
    }
}
exports.EmbedState = EmbedState;
/**
 * A state that implements Projection in the sense of relational algebra, only
 * exposing a subset of fields (read: tapes) of its child state.
 *
 * Note that the child state itself still has and operates on those fields/tapes.
 * For example, the Projection of a join can still fail when there's a conflict regarding
 * field T, even if the Projection hides field T.  We can think of the Project as encapsulating
 * the set of fields/tapes such that only a subset of its fields are exposed to the outside,
 * rather than removing those fields/tapes.
 */
class ProjectionState extends UnaryState {
    constructor(child, tapeRestriction) {
        super();
        this.child = child;
        this.tapeRestriction = tapeRestriction;
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = this.tapeRestriction;
        }
        return this.relevantTapes;
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (tape.tapeName != "__ANY_TAPE__" && !this.tapeRestriction.has(tape.tapeName)) {
            // if it's not a tape we care about, go nowhere
            yield [tape, target, false, this];
        }
        for (var [childTape, childTarget, childMatch, childNext] of this.child.dQuery(tape, target, symbolStack, randomize)) {
            if (childTape.tapeName != "__ANY_TAPE__" && !this.tapeRestriction.has(childTape.tapeName)) {
                // even if our child yields content on a restricted tape, 
                // we don't let our own parent know about it
                childTape = new tapes_1.TapeCollection();
                childTarget = tapes_1.NO_CHAR;
            }
            yield [childTape, childTarget, childMatch, new ProjectionState(childNext, this.tapeRestriction)];
        }
    }
}
exports.ProjectionState = ProjectionState;
/**
 * Implements the Rename operation from relational algebra.
 *
 */
class RenameState extends UnaryState {
    constructor(child, fromTape, toTape, relevantTapes = undefined) {
        super();
        this.child = child;
        this.fromTape = fromTape;
        this.toTape = toTape;
        this.relevantTapes = relevantTapes;
    }
    collectVocab(tapes, stateStack) {
        tapes = new tapes_1.RenamedTape(tapes, this.fromTape, this.toTape);
        this.child.collectVocab(tapes, stateStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            this.relevantTapes = new Set();
            for (const tapeName of this.child.getRelevantTapes(stateStack)) {
                if (tapeName == this.fromTape) {
                    this.relevantTapes.add(this.toTape);
                }
                else {
                    this.relevantTapes.add(tapeName);
                }
            }
        }
        return this.relevantTapes;
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        if (tape.tapeName == this.toTape || tape.tapeName == "__ANY_TAPE__") {
            tape = new tapes_1.RenamedTape(tape, this.fromTape, this.toTape);
        }
        for (var [childTape, childTarget, childMatched, childNext] of this.child.dQuery(tape, target, symbolStack, randomize)) {
            //assert(childTape instanceof RenamedTape);
            const trueChildTape = childTape.child;
            yield [trueChildTape, childTarget, childMatched, new RenameState(childNext, this.fromTape, this.toTape, this.relevantTapes)];
        }
    }
}
exports.RenameState = RenameState;
/**
 * Negation leads to problems, which is why many languages' regex modules
 * don't allow negation of arbitrary parts of the grammar, only of operators
 * like lookahead where negation is well-behaved.  However, negated parsers
 * are genuinely used in linguistic programming (for, e.g., phonological
 * constraints) and so we should have them.
 *
 * In general, we negate an automaton by:
 *
 *  * turning all accepting states into non-accepting states and vice-versa,
 *    which we can do easily in the accepting() function.
 *
 *  * introducing a new accepting state that the parse goes to if it "falls off"
 *    the automaton (e.g., if the automaton recognizes "foo", and get "q", then
 *    that's an acceptable negation, you need a state to accept that).  Here
 *    we implement this state by having "undefined" in place of a child.
 *
 * There are two snags that come up when (as we do) you try to avoid actually
 * constructing the graph.
 *
 * In general, negation of an automaton requires two things:
 *
 *  * the automaton is deterministic; we handle that by calling dQuery instead
 *    of ndQuery.
 *
 *  * the automaton to be negated doesn't have loops that are always
 *    accepting (because those become loops that are never accepting,
 *    and the traversal of them can go on forever).  Or put another way,
 *    a negated automaton can have useless states that will never lead
 *    to an output, that would be properly pruned in a concrete & determinized
 *    automaton, but that we can't be sure of when we evaluate the graph
 *    lazily because it's effectively "looking into the future".
 *
 * So the second one effectively requires construction and determinization of the
 * graph, but that can take enormous space... and because this is intended as a
 * programming language that is kind to beginners, we want a well-formed grammar to always
 * successfully compile.  So we're going to probably end up with a patchwork of partial solutions,
 * and beyond that guarantee that the traversal halts by simply capping the
 * maximum number of steps the automaton can take.  Not ideal, but should cover
 * most reasonable use cases.
 */
class NegationState extends State {
    constructor(child, relevantTapes = undefined) {
        super();
        this.child = child;
        this.relevantTapes = relevantTapes;
    }
    get id() {
        if (this.child == undefined) {
            return "~()";
        }
        return `~(${this.child.id})`;
    }
    collectVocab(tapes, stateStack) {
        if (this.child == undefined) {
            return;
        }
        this.child.collectVocab(tapes, stateStack);
    }
    getRelevantTapes(stateStack) {
        if (this.relevantTapes == undefined) {
            if (this.child == undefined) {
                this.relevantTapes = new Set();
            }
            else {
                this.relevantTapes = this.child.getRelevantTapes(stateStack);
            }
            if (this.relevantTapes.size > 1) {
                throw new Error("We do not currently support negations of grammars that reference 2+ tapes");
            }
        }
        return this.relevantTapes;
    }
    accepting(symbolStack) {
        if (this.child == undefined) {
            return true;
        }
        return !this.child.accepting(symbolStack);
    }
    *ndQuery(tape, target, symbolStack, randomize) {
        var remainderTapeName = [...this.getRelevantTapes(symbolStack)][0];
        var remainderTape = tape.matchTape(remainderTapeName);
        if (remainderTape == undefined) {
            yield [tape, target, false, this];
            return;
        }
        if (this.child == undefined) { // we've can't possibly match the child, so we're basically .* from now on
            yield [remainderTape, target, true, this];
            return;
        }
        var remainder = new tapes_1.Token(target.bits.clone());
        for (const [childTape, childText, childMatched, childNext] of this.child.dQuery(tape, target, symbolStack, randomize)) {
            remainder = remainder.andNot(childText);
            yield [childTape, childText, childMatched, new NegationState(childNext, this.relevantTapes)];
        }
        yield [remainderTape, remainder, true, new NegationState(undefined, this.relevantTapes)];
    }
}
exports.NegationState = NegationState;
/* CONVENIENCE FUNCTIONS FOR CONSTRUCTING GRAMMARS */
function Lit(tier, text) {
    return new LiteralState(tier, text);
}
exports.Lit = Lit;
function Literalizer(tier) {
    return function (text) {
        return Lit(tier, text);
    };
}
exports.Literalizer = Literalizer;
function Seq(...children) {
    if (children.length == 0) {
        return Empty();
    }
    if (children.length == 1) {
        return children[0];
    }
    return new ConcatState(children[0], Seq(...children.slice(1)));
}
exports.Seq = Seq;
function Uni(...children) {
    if (children.length == 0) {
        return Empty();
    }
    if (children.length == 1) {
        return children[0];
    }
    return new UnionState(children[0], Uni(...children.slice(1)));
}
exports.Uni = Uni;
/*
export function Pri(...children: State[]): State {
    return new PriorityUnionState(children);
} */
function Join(child1, child2) {
    return new JoinState(child1, child2);
    /* const left = new SemijoinState(child1, child2);
    const right = new SemijoinState(child2, child1);
    return new PriorityUnionState([left, right]); */
}
exports.Join = Join;
function Semijoin(child1, child2) {
    return new SemijoinState(child1, child2);
}
exports.Semijoin = Semijoin;
function Not(child) {
    return new NegationState(child);
}
exports.Not = Not;
function Emb(symbolName, namespace) {
    return new EmbedState(symbolName, namespace);
}
exports.Emb = Emb;
function Proj(child, ...tiers) {
    return new ProjectionState(child, new Set(tiers));
}
exports.Proj = Proj;
function Rename(child, fromTier, toTier) {
    return new RenameState(child, fromTier, toTier);
}
exports.Rename = Rename;
function Any(tier) {
    return new AnyCharState(tier);
}
exports.Any = Any;
function Rep(child, minReps = 0, maxReps = Infinity) {
    return new RepetitionState(new TrivialState(), minReps, maxReps, 0, child);
}
exports.Rep = Rep;
function Empty() {
    return new TrivialState();
}
exports.Empty = Empty;
function Maybe(child) {
    return Uni(child, Empty());
}
exports.Maybe = Maybe;

},{"./tapes":5}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenamedTape = exports.TapeCollection = exports.StringTape = exports.NO_CHAR = exports.ANY_CHAR = exports.Token = exports.Tape = exports.MultiTapeOutput = void 0;
const bitset_1 = require("bitset");
/**
 * Outputs
 *
 * The outputs of this algorithm are kept as tries, since that's the natural
 * shape of a set of outputs from a non-deterministic parsing algorithm.  (E.g., if
 * we've already output "fooba", and at the next state we could either output "r" or
 * "z", then just having "r" and "z" point to that previous output is both less effort
 * and less space than copying it twice and concatenating it.  Especially if "z" ends
 * up being a false path and we end up discarding it; that would mean we had copied/
 * concatenated for nothing.)
 *
 * It used to be that we just kept every tape output in one trie (like an output
 * might have characters on different tapes interleaved).  That's fine when it's guaranteed
 * that every concatenation succeeds (like for string concatenation), but when it's something like
 * flag concatenation (which can fail), that means we have to search backwards through the trie
 * to find the most recent output on the relevant tape.  So now, outputs are segregated by tape.
 * A SingleTapeOutput represents the output on a given tape, and then there's a separate object that
 * represents a collection of them (by keeping a pointer to the appropriate output along each tape).
 *
 * TODO: There's currently some conceptual duplication between these Outputs and the various Tape
 * objects, which store *information* about tapes (like their names and vocabs) without storing any
 * actual outputs onto those tapes.  Each Output is associated with a particular Tape, there are collections
 * of both corresponding to each other, etc.  We should eventually refactor these so that there's only
 * one hierarchy of objects, "tapes" to which you can write and also know their own information.
 */
class SingleTapeOutput {
    constructor(tape, token, prev = undefined) {
        this.tape = tape;
        this.token = token;
        this.prev = prev;
    }
    add(tape, token) {
        if (tape.tapeName != this.tape.tapeName) {
            throw new Error(`Incompatible tapes: ${tape.tapeName}, ${this.tape.tapeName}`);
        }
        return new SingleTapeOutput(tape, token, this);
    }
    *getStrings() {
        var results = [""];
        var currentTape = this;
        // step backward through the current object and its prevs, building the output strings from
        // right to left.  (you might think this would be more elegant to be done recursively, but it blows
        // the stack when stringifying long outputs.)
        while (currentTape != undefined) {
            const newResults = [];
            for (const c of currentTape.tape.fromBits(currentTape.tape.tapeName, currentTape.token.bits)) {
                for (const existingResult of results) {
                    newResults.push(c + existingResult);
                }
            }
            results = newResults;
            currentTape = currentTape.prev;
        }
        yield* results;
    }
}
/**
 * Multi tape output
 *
 * This stores a collection of outputs on different tapes, by storing a collection of pointers to them.
 * When you add a <tape, char> pair to it (say, <text,b>), you return a new MultiTapeOutput that now
 * points to a new SingleTapeOutput corresponding to "text" -- the new one with "b" added -- and keep
 * all the old pointers the same.
 */
class MultiTapeOutput {
    constructor() {
        this.singleTapeOutputs = new Map();
    }
    add(tape, token) {
        if (tape.numTapes == 0) {
            return this;
        }
        const result = new MultiTapeOutput();
        result.singleTapeOutputs = new Map(this.singleTapeOutputs);
        const prev = this.singleTapeOutputs.get(tape.tapeName);
        const newTape = new SingleTapeOutput(tape, token, prev);
        result.singleTapeOutputs.set(tape.tapeName, newTape);
        return result;
    }
    toStrings() {
        var results = [{}];
        for (const [tapeName, tape] of this.singleTapeOutputs) {
            var newResults = [];
            for (const str of tape.getStrings()) {
                for (const result of results) {
                    const newResult = Object.assign({}, result);
                    newResult[tapeName] = str;
                    newResults.push(newResult);
                }
            }
            results = newResults;
        }
        return results;
    }
}
exports.MultiTapeOutput = MultiTapeOutput;
/**
 * Tape
 *
 * This encapsulates information about a tape or set of tapes (like what its name is, what
 * its possible vocabulary is, what counts as concatenation and matching, etc.).  It doesn't,
 * however, encapsulate a tape in the sense of keeping a sequence of character outputs; that
 * would be encapsulated by the Output objects above.
 *
 * TODO: Refactor Outputs and Tapes so that they're all one kind of object, because currently
 * we're keeping a duplicated hierarchy in which the Output and Tape class hierarchies mirror
 * each other.
 */
class Tape {
    add(str1, str2) {
        throw new Error(`Not implemented`);
    }
    match(str1, str2) {
        throw new Error(`Not implemented`);
    }
    any() {
        throw new Error(`Not implemented`);
    }
    *plus(tapeName, other) {
        throw new Error(`Not implemented`);
    }
    *times(tapeName, other) {
        throw new Error(`Not implemented`);
    }
    tokenize(tapeName, str) {
        throw new Error(`Not implemented`);
    }
    get vocabSize() {
        return 0;
    }
}
exports.Tape = Tape;
/**
 * Token
 *
 * This encapsulates a token, so that parsers need not necessarily know how, exactly, a token is implemented.
 * Right now we only have one kind of token, strings implemented as BitSets, but eventually this should be an
 * abstract class with (e.g.) StringToken, maybe FlagToken, ProbToken and/or LogToken (for handling weights),
 * etc.
 *
 */
class Token {
    constructor(bits) {
        this.bits = bits;
    }
    and(other) {
        return new Token(this.bits.and(other.bits));
    }
    andNot(other) {
        return new Token(this.bits.andNot(other.bits));
    }
    isEmpty() {
        return this.bits.isEmpty();
    }
    stringify(tape) {
        return tape.fromBits(tape.tapeName, this.bits).join("|");
    }
}
exports.Token = Token;
exports.ANY_CHAR = new Token(new bitset_1.BitSet().flip());
exports.NO_CHAR = new Token(new bitset_1.BitSet());
/**
 * A tape containing strings; the basic kind of tape and (right now) the only one we really use.
 * (Besides a TapeCollection, which implements Tape but is really used for a different situation.)
 */
class StringTape extends Tape {
    constructor(tapeName, current = undefined, prev = undefined, strToIndex = new Map(), indexToStr = new Map()) {
        super();
        this.tapeName = tapeName;
        this.current = current;
        this.prev = prev;
        this.strToIndex = strToIndex;
        this.indexToStr = indexToStr;
    }
    get numTapes() {
        return 1;
    }
    get vocabSize() {
        return this.strToIndex.size;
    }
    /*
    public *plus(tapeName: string, other: BitSet): Gen<Tape> {
        if (tapeName != this.tapeName) {
            return;
        }
        yield new StringTape(this.tapeName, other,
                            this, this.strToIndex, this.indexToStr);
    }

    public *times(tapeName: string, other: BitSet): Gen<Tape> {
        if (tapeName != this.tapeName) {
            return;
        }
        const result = this.current.and(other);
        if (result.isEmpty()) {
            return;
        }
        yield new StringTape(this.tapeName, result, this.prev,
                            this.strToIndex, this.indexToStr);
    }
    */
    append(token) {
        return new StringTape(this.tapeName, token, this, this.strToIndex, this.indexToStr);
    }
    *getStrings() {
        var prevStrings = [""];
        if (this.prev != undefined) {
            prevStrings = [...this.prev.getStrings()];
        }
        if (this.current == undefined) {
            yield* prevStrings;
            return;
        }
        for (const s of prevStrings) {
            for (const c of this.fromBits(this.tapeName, this.current.bits)) {
                yield s + c;
            }
        }
    }
    matchTape(tapeName) {
        return (tapeName == this.tapeName) ? this : undefined;
    }
    any() {
        return new Token(new bitset_1.BitSet().flip());
    }
    add(str1, str2) {
        return [str1 + str2];
    }
    match(str1, str2) {
        return new Token(str1.bits.and(str2.bits));
    }
    tokenize(tapeName, str) {
        if (tapeName != this.tapeName) {
            throw new Error(`Trying to add a character from tape ${tapeName} to tape ${this.tapeName}`);
        }
        const results = [];
        for (const c of str.split("")) {
            var index = this.strToIndex.get(c);
            if (index == undefined) {
                index = this.registerToken(c);
            }
            const newToken = new Token(this.toBits(tapeName, c));
            results.push(newToken);
        }
        return results;
    }
    registerToken(token) {
        const index = this.strToIndex.size;
        this.strToIndex.set(token, index);
        this.indexToStr.set(index, token);
        return index;
    }
    toBits(tapeName, char) {
        if (tapeName != this.tapeName) {
            throw new Error(`Trying to get bits on tape ${tapeName} from tape ${this.tapeName}`);
        }
        const result = new bitset_1.BitSet();
        const index = this.strToIndex.get(char);
        if (index == undefined) {
            return result;
        }
        result.set(index);
        return result;
    }
    fromBits(tapeName, bits) {
        if (tapeName != this.tapeName) {
            throw new Error(`Trying to get bits on tape ${tapeName} from tape ${this.tapeName}`);
        }
        const result = [];
        for (const index of bits.toArray()) {
            const char = this.indexToStr.get(index);
            if (char == undefined) {
                break; // this is crucial, because BitSets are infinite and if
                // one was created by inversion, it could iterate forever here.
            }
            result.push(char);
        }
        return result;
    }
}
exports.StringTape = StringTape;
/**
 * A tape containing flags, roughly identical to a "U" flag in XFST/LEXC.
 * This uses a different method for "add" than a normal string tape; you can
 * always concatenate a string to a string, but trying to add a flag to a different
 * flag will fail.
 *
 * At the moment this isn't used anywhere.
 */
class FlagTape extends StringTape {
    add(oldResults, newResult) {
        if (oldResults == "" || oldResults == newResult) {
            return [newResult];
        }
        return [];
    }
    tokenize(tapeName, str) {
        var index = this.strToIndex.get(str);
        if (index == undefined) {
            index = this.registerToken(str);
        }
        return [new Token(this.toBits(tapeName, str))];
    }
}
/**
 * This contains information about all the tapes.  When we do a "free query" in the state machine,
 * what we're saying is "match anything on any tape".  Eventually, something's going to match on a particular
 * tape, so we have to have that information handy for all tapes.  (That is to say, something like a LiteralState
 * knows what tape it cares about only as a string, say, "text".  In a constrained query, we pass in a normal StringTape
 * object, and if it's the "text" tape, matchTape("text") succeeds and returns itself, and if it doesn't,
 * matchTape("text") fails.  In a free query, we pass in one of these objects, and when we matchTape("text"), we
 * return the StringTape corresponding to "text".  That's why we need an object that collects all of them, so we
 * can return the appropriate one when it's needed.)
 */
class TapeCollection extends Tape {
    constructor() {
        super(...arguments);
        this.tapes = new Map();
    }
    get numTapes() {
        return this.tapes.size;
    }
    addTape(tape) {
        this.tapes.set(tape.tapeName, tape);
    }
    getTapeNames() {
        return [...this.tapes.keys()];
    }
    get tapeName() {
        if (this.tapes.size == 0) {
            return "__NO_TAPE__";
        }
        return "__ANY_TAPE__";
    }
    tokenize(tapeName, str) {
        var tape = this.tapes.get(tapeName);
        if (tape == undefined) {
            tape = new StringTape(tapeName);
            this.tapes.set(tapeName, tape);
        }
        return tape.tokenize(tapeName, str);
    }
    matchTape(tapeName) {
        return this.tapes.get(tapeName);
    }
    toBits(tapeName, char) {
        const tape = this.tapes.get(tapeName);
        if (tape == undefined) {
            throw new Error(`Undefined tape: ${tapeName}`);
        }
        return tape.toBits(tapeName, char);
    }
    fromBits(tapeName, bits) {
        const tape = this.tapes.get(tapeName);
        if (tape == undefined) {
            throw new Error(`Undefined tape: ${tapeName}`);
        }
        return tape.fromBits(tapeName, bits);
    }
}
exports.TapeCollection = TapeCollection;
/**
 * RenamedTapes are necessary for RenameStates to work properly.
 *
 * From the point of view of any particular state, it believes that particular
 * tapes have particular names, e.g. "text" or "gloss".  However, because renaming is
 * an operator of our relational algebra, different states may be referred to by different
 * names in different parts of the grammar.
 *
 * (For example, consider a composition between two FSTS, {"up":"lr", "down":"ll"} and
 * {"up":"ll", "down":"lh"}.  In order to express their composition as a "join", we have to make it so that
 * the first "down" and the second "up" have the same name.  Renaming does that.
 *
 * The simplest way to get renaming, so that each state doesn't have to understand the name structure
 * of the larger grammar, is for RenameStates to wrap tapes in a simple adaptor class that makes it seem
 * as if an existing tape has a new name.  That way, any child of a RenameState can (for example) ask for the
 * vocabulary of the tape it thinks is called "down", even if outside of that RenameState the tape is called
 * "text".
 */
class RenamedTape extends Tape {
    constructor(child, fromTape, toTape) {
        super();
        this.child = child;
        this.fromTape = fromTape;
        this.toTape = toTape;
    }
    get tapeName() {
        const childName = this.child.tapeName;
        if (childName == this.toTape) {
            return this.fromTape;
        }
        return childName;
    }
    get numTapes() {
        return this.child.numTapes;
    }
    any() {
        return this.child.any();
    }
    add(str1, str2) {
        return this.child.add(str1, str2);
    }
    match(str1, str2) {
        return this.child.match(str1, str2);
    }
    adjustTapeName(tapeName) {
        return (tapeName == this.fromTape) ? this.toTape : tapeName;
    }
    matchTape(tapeName) {
        tapeName = this.adjustTapeName(tapeName);
        const newChild = this.child.matchTape(tapeName);
        if (newChild == undefined) {
            return undefined;
        }
        return new RenamedTape(newChild, this.fromTape, this.toTape);
    }
    tokenize(tapeName, str) {
        tapeName = this.adjustTapeName(tapeName);
        return this.child.tokenize(tapeName, str);
    }
    toBits(tapeName, char) {
        tapeName = this.adjustTapeName(tapeName);
        return this.child.toBits(tapeName, char);
    }
    fromBits(tapeName, bits) {
        tapeName = this.adjustTapeName(tapeName);
        return this.child.fromBits(tapeName, bits);
    }
}
exports.RenamedTape = RenamedTape;

},{"bitset":1}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setChain = exports.setIntersection = exports.RGBtoString = exports.HSVtoRGB = exports.iterTake = exports.shuffleArray = exports.meanAngleDeg = void 0;
function sum(a) {
    var s = 0;
    for (var i = 0; i < a.length; i++)
        s += a[i];
    return s;
}
function degToRad(a) {
    return Math.PI / 180 * a;
}
function meanAngleDeg(a) {
    return 180 / Math.PI * Math.atan2(sum(a.map(degToRad).map(Math.sin)) / a.length, sum(a.map(degToRad).map(Math.cos)) / a.length);
}
exports.meanAngleDeg = meanAngleDeg;
/* Randomize array in-place using Durstenfeld shuffle algorithm */
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
exports.shuffleArray = shuffleArray;
function iterTake(gen, n) {
    var i = 1;
    const results = [];
    if (n <= 0) {
        throw new Error("Invalid index");
    }
    for (const value of gen) {
        results.push(value);
        if (i++ == n) {
            break;
        }
    }
    return results;
}
exports.iterTake = iterTake;
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    r = 0;
    g = 0;
    b = 0;
    switch (i % 6) {
        case 0:
            r = v, g = t, b = p;
            break;
        case 1:
            r = q, g = v, b = p;
            break;
        case 2:
            r = p, g = v, b = t;
            break;
        case 3:
            r = p, g = q, b = v;
            break;
        case 4:
            r = t, g = p, b = v;
            break;
        case 5:
            r = v, g = p, b = q;
            break;
    }
    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);
    return [r, g, b];
}
exports.HSVtoRGB = HSVtoRGB;
function RGBtoString(r, g, b) {
    return "#" + r.toString(16) + g.toString(16) + b.toString(16);
}
exports.RGBtoString = RGBtoString;
function setIntersection(s1, s2) {
    return new Set([...s1].filter(i => s2.has(i)));
}
exports.setIntersection = setIntersection;
function setChain(sets) {
    const results = new Set();
    for (const set of sets) {
        for (const item of set) {
            results.add(item);
        }
    }
    return results;
}
exports.setChain = setChain;
class Iter {
    constructor(gen) {
        this.gen = gen;
    }
    next(...args) {
        return this.gen.next(...args);
    }
    return(value) {
        return this.gen.return(value);
    }
    throw(e) {
        return this.throw(e);
    }
    [Symbol.iterator]() {
        return this.gen[Symbol.iterator]();
    }
    map(f) {
        return iter(iterMap(this.gen, f));
    }
    map2nd(f) {
        const gen = this.gen;
        return iter(gen).map(([a, b]) => [a, f(b)]);
    }
    product(other) {
        return iter(iterProduct(this.gen, other));
    }
}
function iter(x) {
    return new Iter(x);
}
function iterChain(iters) {
    return iter(function* () {
        for (const iter of iters) {
            yield* iter;
        }
    }());
}
function iterFail() {
    return iter(function* () { }());
}
function* iterProduct(i1, i2) {
    for (const item1 of i1) {
        for (const item2 of i2) {
            yield [item1, item2];
        }
    }
}
function* iterMap(i, f) {
    for (const item of i) {
        yield f(item);
    }
}

},{}]},{},[2])(2)
});
</script>