(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.gramble = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify = promisify;
// Symbols is a better way to do this, but not all browsers have good support,
// so instead we'll just make do with a very unlikely string.
var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
/**
 * promisify()
 * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) --
 * into an ES6-compatible Promise. Promisify provides a default callback of the
 * form (error, result) and rejects when `error` is truthy.
 *
 * @param {function} original - The function to promisify
 * @return {function} A promisified version of `original`
 */

function promisify(original) {
  // Ensure the argument is a function
  if (typeof original !== "function") {
    throw new TypeError("Argument to promisify must be a function");
  } // If the user has asked us to decode argument names for them, honour that


  var argumentNames = original[customArgumentsToken]; // If the user has supplied a custom Promise implementation, use it.
  // Otherwise fall back to whatever we can find on the global object.

  var ES6Promise = promisify.Promise || Promise; // If we can find no Promise implemention, then fail now.

  if (typeof ES6Promise !== "function") {
    throw new Error("No Promise implementation found; do you need a polyfill?");
  }

  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new ES6Promise(function (resolve, reject) {
      // Append the callback bound to the context
      args.push(function callback(err) {
        if (err) {
          return reject(err);
        }

        for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          values[_key2 - 1] = arguments[_key2];
        }

        if (values.length === 1 || !argumentNames) {
          return resolve(values[0]);
        }

        var o = {};
        values.forEach(function (value, index) {
          var name = argumentNames[index];

          if (name) {
            o[name] = value;
          }
        });
        resolve(o);
      }); // Call the function.

      original.apply(_this, args);
    });
  };
} // Attach this symbol to the exported function, so users can use it


promisify.argumentNames = customArgumentsToken;
promisify.Promise = undefined; // Export the public API
},{}],2:[function(require,module,exports){
/* @license
Papa Parse
v5.2.0
https://github.com/mholt/PapaParse
License: MIT
*/
!function(e,t){"function"==typeof define&&define.amd?define([],t):"object"==typeof module&&"undefined"!=typeof exports?module.exports=t():e.Papa=t()}(this,function s(){"use strict";var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=n&&/blob:/i.test((f.location||{}).protocol),a={},h=0,b={parse:function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var r=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(i=f.URL||f.webkitURL||null,r=s.toString(),b.BLOB_URL||(b.BLOB_URL=i.createObjectURL(new Blob(["(",r,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var i,r;return t.onmessage=_,t.id=h++,a[t.id]=t}();return r.userStep=t.step,r.userChunk=t.chunk,r.userComplete=t.complete,r.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,void r.postMessage({input:e,config:t,workerId:r.id})}var n=null;b.NODE_STREAM_INPUT,"string"==typeof e?n=t.download?new l(t):new p(t):!0===e.readable&&U(e.read)&&U(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",v="\r\n",s='"',a=s+s,i=!1,r=null;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines);"string"==typeof t.newline&&(v=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s)}();var o=new RegExp(q(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if("object"==typeof e[0])return u(r||h(e[0]),e,i)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:h(e.data[0])),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error("Unable to serialize unrecognized input");function h(e){if("object"!=typeof e)return[];var t=[];for(var i in e)t.push(i);return t}function u(e,t,i){var r="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=y(e[a],a);0<t.length&&(r+=v)}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u="greedy"===i?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===i&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c])}u=""===d.join("").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(r+=m);var g=n&&s?e[p]:p;r+=y(t[o][g],p)}o<t.length-1&&(!i||0<h&&!f)&&(r+=v)}}return r}function y(e,t){if(null==e)return"";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var i=e.toString().replace(o,a),r="boolean"==typeof n&&n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1);return r?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=w,b.ParserHandle=i,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0!==h.length){var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if("skip"===s.action)return void u();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if("skip"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},b.parse(n.file,n.instanceConfig)}else U(o.complete)&&o.complete()}function u(){h.splice(0,1),e()}}}function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=E(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&U(this._config.beforeFirstChunk)){var i=this._config.beforeFirstChunk(e);void 0!==i&&(e=i)}this.isFirstChunk=!1,this._halted=!1;var r=this._partialLine+e;this._partialLine="";var n=this._handle.parse(r,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=r.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(U(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!U(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var r;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),u.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),n||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)r.setRequestHeader(t,e[t])}if(this._config.chunkSize){var i=this._start+this._config.chunkSize-1;r.setRequestHeader("Range","bytes="+this._start+"-"+i)}try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:r.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){var t=r.statusText||e;this._sendError(new Error(t))}}function c(e){var r,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),u.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((r=new FileReader).onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)):r=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var i=r.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:i}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(r.error)}}function p(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=i.substring(0,t),i=i.substring(t)):(e=i,i=""),this._finished=!i,this.parseChunk(e)}}}function g(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData("")},this),this._streamCleanUp=y(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function i(m){var a,o,h,r=Math.pow(2,53),n=-r,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)(e[-+]?\d+)?\s*$/,u=/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,t=this,i=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(U(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;i+=e.data.length,m.preview&&i>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function v(e){return"greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){if(c&&h&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),h=!1),m.skipEmptyLines)for(var e=0;e<c.data.length;e++)v(c.data[e])&&c.data.splice(e--,1);return _()&&function(){if(!c)return;function e(e){U(m.transformHeader)&&(e=m.transformHeader(e)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var i,r=m.header?{}:[];for(i=0;i<e.length;i++){var n=i,s=e[i];m.header&&(n=i>=l.length?"__parsed_extra":l[i]),m.transform&&(s=m.transform(s,n)),s=y(n,s),"__parsed_extra"===n?(r[n]=r[n]||[],r[n].push(s)):r[n]=s}return m.header&&(i>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+i,f+t):i<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+i,f+t)),r}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function y(e,t){return i=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[i]&&(m.dynamicTyping[i]=m.dynamicTypingFunction(i)),!0===(m.dynamicTyping[i]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<r)return!0}return!1}(t)?parseFloat(t):u.test(t)?new Date(t):""===t?null:t):t;var i}function k(e,t,i,r){var n={type:e,code:t,message:i};void 0!==r&&(n.row=r),c.errors.push(n)}this.parse=function(e,t,i){var r=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var i=new RegExp(q(t)+"([^]*?)"+q(t),"gm"),r=(e=e.replace(i,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<r[0].length;if(1===r.length||s)return"\n";for(var a=0,o=0;o<r.length;o++)"\n"===r[o][0]&&a++;return a>=r.length/2?"\r\n":"\r"}(e,r)),h=!1,m.delimiter)U(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,i,r,n){var s,a,o,h;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var u=0;u<n.length;u++){var f=n[u],d=0,l=0,c=0;o=void 0;for(var p=new w({comments:r,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(i&&v(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===h||h<l)&&1.99<l&&(a=d,s=f,h=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(h=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=E(m);return m.preview&&m.header&&s.preview++,a=e,o=new w(s),c=o.parse(a,t,i),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=U(m.chunk)?"":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,U(m.complete)&&m.complete(c),a=""}}function q(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function w(e){var O,D=(e=e||{}).delimiter,I=e.newline,T=e.comments,A=e.step,L=e.preview,F=e.fastMode,z=O=void 0===e.quoteChar?'"':e.quoteChar;if(void 0!==e.escapeChar&&(z=e.escapeChar),("string"!=typeof D||-1<b.BAD_DELIMITERS.indexOf(D))&&(D=","),T===D)throw new Error("Comment character same as delimiter");!0===T?T="#":("string"!=typeof T||-1<b.BAD_DELIMITERS.indexOf(T))&&(T=!1),"\n"!==I&&"\r"!==I&&"\r\n"!==I&&(I="\n");var M=0,j=!1;this.parse=function(a,t,i){if("string"!=typeof a)throw new Error("Input must be a string");var r=a.length,e=D.length,n=I.length,s=T.length,o=U(A),h=[],u=[],f=[],d=M=0;if(!a)return R();if(F||!1!==F&&-1===a.indexOf(O)){for(var l=a.split(I),c=0;c<l.length;c++){if(f=l[c],M+=f.length,c!==l.length-1)M+=I.length;else if(i)return R();if(!T||f.substring(0,s)!==T){if(o){if(h=[],b(f.split(D)),S(),j)return R()}else b(f.split(D));if(L&&L<=c)return h=h.slice(0,L),R(!0)}}return R()}for(var p=a.indexOf(D,M),g=a.indexOf(I,M),_=new RegExp(q(z)+q(O),"g"),m=a.indexOf(O,M);;)if(a[M]!==O)if(T&&0===f.length&&a.substring(M,M+s)===T){if(-1===g)return R();M=g+n,g=a.indexOf(I,M),p=a.indexOf(D,M)}else{if(-1!==p&&(p<g||-1===g)){if(!(p<m)){f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}var v=x(p,m,g);if(v&&void 0!==v.nextDelim){p=v.nextDelim,m=v.quoteSearch,f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}}if(-1===g)break;if(f.push(a.substring(M,g)),C(g+n),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0)}else for(m=M,M++;;){if(-1===(m=a.indexOf(O,m+1)))return i||u.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:h.length,index:M}),E();if(m===r-1)return E(a.substring(M,m).replace(_,O));if(O!==z||a[m+1]!==z){if(O===z||0===m||a[m-1]!==z){-1!==p&&p<m+1&&(p=a.indexOf(D,m+1)),-1!==g&&g<m+1&&(g=a.indexOf(I,m+1));var y=w(-1===g?p:Math.min(p,g));if(a[m+1+y]===D){f.push(a.substring(M,m).replace(_,O)),a[M=m+1+y+e]!==O&&(m=a.indexOf(O,M)),p=a.indexOf(D,M),g=a.indexOf(I,M);break}var k=w(g);if(a.substring(m+1+k,m+1+k+n)===I){if(f.push(a.substring(M,m).replace(_,O)),C(m+1+k+n),p=a.indexOf(D,M),m=a.indexOf(O,M),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0);break}u.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:h.length,index:M}),m++}}else m++}return E();function b(e){h.push(e),d=M}function w(e){var t=0;if(-1!==e){var i=a.substring(m+1,e);i&&""===i.trim()&&(t=i.length)}return t}function E(e){return i||(void 0===e&&(e=a.substring(M)),f.push(e),M=r,b(f),o&&S()),R()}function C(e){M=e,b(f),f=[],g=a.indexOf(I,M)}function R(e){return{data:h,errors:u,meta:{delimiter:D,linebreak:I,aborted:j,truncated:!!e,cursor:d+(t||0)}}}function S(){A(R()),h=[],u=[]}function x(e,t,i){var r={nextDelim:void 0,quoteSearch:void 0},n=a.indexOf(O,t+1);if(t<e&&e<n&&(n<i||-1===i)){var s=a.indexOf(D,n);if(-1===s)return r;n<s&&(n=a.indexOf(O,n+1)),r=x(s,n,i)}else r={nextDelim:e,quoteSearch:t};return r}},this.abort=function(){j=!0},this.getCharIndex=function(){return M}}function _(e){var t=e.data,i=a[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:v,resume:v};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&m(t.workerId,t.results)}function m(e,t){var i=a[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete a[e]}function v(){throw new Error("Not implemented.")}function E(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var i in e)t[i]=E(e[i]);return t}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return"function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var i=b.parse(t.input,t.config);i&&f.postMessage({workerId:b.WORKER_ID,results:i,finished:!0})}}),(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(u.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(u.prototype)).constructor=g,b});
},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromURLAsync = exports.fromURL = exports.fromDataAsync = exports.fromData = exports.fromTableAsync = exports.fromTable = exports.fromHTMLAsync = exports.fromHTML = exports.fromEmbedAsync = exports.fromEmbed = exports.ClientSideProject = void 0;
const spreadsheet_1 = require("./spreadsheet");
const papaparse_1 = require("papaparse");
const es6_promisify_1 = require("es6-promisify");
class ClientSideProject extends spreadsheet_1.Project {
    constructor() {
        super(...arguments);
        this.devEnv = new spreadsheet_1.BrowserDevEnvironment();
    }
    addParseResults(results, url, callback) {
        if (results.errors.length > 0) {
            const error = new Error("Error parsing CSV file: \n" + results.errors.join("\n"));
            callback(error, this);
            return;
        }
        this.addSheet(url, results.data, this.devEnv);
        this.devEnv.highlight();
        callback(null, this);
    }
}
exports.ClientSideProject = ClientSideProject;
function fromEmbed(elementID, callback) {
    const project = new ClientSideProject();
    var element = document.getElementById(elementID);
    if (element == null) {
        return;
    }
    var input = element.contentDocument.body.childNodes[0].innerHTML;
    var url = element.getAttribute('data');
    if (url == null) {
        url = "(unknown)";
    }
    papaparse_1.parse(input, {
        complete: (results) => project.addParseResults(results, url, callback)
    });
}
exports.fromEmbed = fromEmbed;
exports.fromEmbedAsync = es6_promisify_1.promisify(fromEmbed);
function fromHTML(elementID, callback) {
    const project = new ClientSideProject();
    var element = document.getElementById(elementID);
    if (element == null) {
        return;
    }
    var input = element.textContent;
    papaparse_1.parse(input, {
        complete: (results) => project.addParseResults(results, elementID, callback)
    });
}
exports.fromHTML = fromHTML;
exports.fromHTMLAsync = es6_promisify_1.promisify(fromHTML);
function fromTable(elementID, callback) {
    const project = new ClientSideProject();
    const element = document.getElementById(elementID);
    if (element == null) {
        return;
    }
    const input = element.textContent;
    const cells = Array.prototype.map.call(element.querySelectorAll('tr'), (tr) => {
        return Array.prototype.map.call(tr.querySelectorAll('td'), (td) => {
            return td.innerHTML;
        });
    });
    project.addSheet(elementID, cells, project.devEnv);
    callback(undefined, project);
}
exports.fromTable = fromTable;
exports.fromTableAsync = es6_promisify_1.promisify(fromTable);
function fromData(cells, callback) {
    const project = new ClientSideProject();
    project.addSheet("CurrentSheet", cells, project.devEnv);
    callback(undefined, project);
}
exports.fromData = fromData;
exports.fromDataAsync = es6_promisify_1.promisify(fromData);
function fromURL(url, callback) {
    //var input = document.getElementById('grammar').contentDocument.body.childNodes[0].innerHTML;  
    const project = new ClientSideProject();
    papaparse_1.parse(url, {
        download: true,
        complete: (results) => project.addParseResults(results, url, callback)
    });
}
exports.fromURL = fromURL;
exports.fromURLAsync = es6_promisify_1.promisify(fromURL);

},{"./spreadsheet":4,"es6-promisify":1,"papaparse":2}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = exports.TextDevEnvironment = exports.BrowserDevEnvironment = void 0;
const transducers_1 = require("./transducers");
const tierParser_1 = require("./tierParser");
/**
 * Determines whether a line is empty
 * @param row A list of strings, representing the cell text along that row
 * @returns True if the line is empty
 */
function isLineEmpty(row) {
    if (row.length == 0) {
        return true;
    }
    for (let cellText of row) {
        if (cellText.trim().length != 0) {
            return false;
        }
    }
    return true;
}
class BrowserDevEnvironment {
    constructor() {
        this.errorMessages = [];
    }
    markTier(sheet, row, col, tier) { }
    markComment(sheet, row, col) { }
    markHeader(sheet, row, col, tier) { }
    markCommand(sheet, row, col) { }
    markSymbol(sheet, row, col) { }
    setColor(tierName, color) { }
    markError(sheet, row, col, msg, level) {
        this.errorMessages.push([sheet, row, col, msg, level]);
    }
    highlight() {
        var errors = [];
        for (const error of this.errorMessages) {
            const rowStr = (error[1] == -1) ? "unknown" : (error[1] + 1).toString();
            const colStr = (error[2] == -1) ? "unknown" : (error[2] + 1).toString();
            errors.push(error[4].toUpperCase() +
                ": " + error[0] +
                ", row " + rowStr +
                ", column " + colStr +
                ": " + error[3]);
        }
        if (errors.length > 0) {
            alert("ERRORS: \n" + errors.join("\n"));
        }
    }
    alert(msg) {
        alert(msg);
    }
}
exports.BrowserDevEnvironment = BrowserDevEnvironment;
class TextDevEnvironment {
    constructor() {
        this.errorMessages = [];
    }
    markTier(sheet, row, col, tier) { }
    markComment(sheet, row, col) { }
    markHeader(sheet, row, col, tier) { }
    markCommand(sheet, row, col) { }
    markSymbol(sheet, row, col) { }
    setColor(tierName, color) { }
    markError(sheet, row, col, msg, level) {
        this.errorMessages.push([sheet, row, col, msg, level]);
    }
    highlight() {
        for (const error of this.errorMessages) {
            const rowStr = (error[1] == -1) ? "unknown" : (error[1] + 1).toString();
            const colStr = (error[2] == -1) ? "unknown" : (error[2] + 1).toString();
            console.error(error[4].toUpperCase() +
                ": " + error[0] +
                ", row " + rowStr +
                ", column " + colStr +
                ": " + error[3]);
        }
    }
    alert(msg) {
        console.log(msg);
    }
}
exports.TextDevEnvironment = TextDevEnvironment;
const REQUIRED_COLORS = [
    "red", "orange", "yellow",
    "chartreuse", "green", "aqua",
    "cyan", "blue", "indigo",
    "violet", "magenta", "burgundy"
];
function isValidColor(colorName) {
    if (colorName.trim().length == 0) {
        return false;
    }
    for (let subcolor of colorName.split("-")) {
        if (REQUIRED_COLORS.indexOf(subcolor.trim()) < 0) {
            return false;
        }
    }
    return true;
}
/**
 * GFunction
 *
 * A GFunction is what is created when the programmer places text in the first column of the
 * sheet.  GFunctions guide the interpretation of following rows, both the name of the function that
 * should be executed (e.g. "add" a record to a symbol or add a "test" to a symbol) and the interpretation
 * of positional arguments (e.g. that the third column should be "text", the second column should be "down", etc.)
 */
class GFunction {
    constructor(name, symbol = undefined, params = [], columns = new Map()) {
        this.name = name;
        this.symbol = symbol;
        this.params = params;
        this.columns = columns;
    }
    addParams(cells, highlighter) {
        var cellBuffer = [];
        for (let cell of cells) {
            cellBuffer.push(cell);
            if (cell.text.length == 0) {
                continue;
            }
            for (const param of cellBuffer) {
                highlighter.markHeader(cell.sheet, cell.row, cell.col, cell.text);
                if (param.text.length == 0) {
                    continue;
                }
                this.params.push(param);
                this.columns.set(param.col, param);
            }
        }
    }
    hasColumn(col) {
        return this.columns.has(col);
    }
    getParam(col) {
        const result = this.columns.get(col);
        if (result == undefined) {
            throw new RangeError("Column index " + col + " not found");
        }
        return result;
    }
    associateParams(cells) {
        var record = [];
        for (const cell of cells) {
            const key = this.getParam(cell.col);
            record.push(new transducers_1.Literal(key, cell));
        }
        return record;
    }
    /**
     * Many functions assign or append their results to the most recently declared symbol.
     * @param GCell
     */
    setSymbol(symbol) {
        this.symbol = symbol;
    }
}
class TableFunction extends GFunction {
    constructor(name, symbol) {
        super(name);
        if (symbol == undefined) {
            return;
        }
        this.setSymbol(symbol);
    }
    call(cells, project) {
        if (this.symbol == undefined) {
            throw new Error("Attempted to call table function without active symbol");
        }
        const record = this.associateParams(cells);
        project.addRecordToSymbol(this.symbol.text, record);
    }
}
class TestFunction extends GFunction {
    constructor(name, symbol) {
        super(name);
        if (symbol == undefined) {
            return;
        }
        this.setSymbol(symbol);
    }
    call(cells, project) {
        if (this.symbol == undefined) {
            throw new Error("Attempted to call table function without active symbol");
        }
        const record = this.associateParams(cells);
        project.addTestToSymbol(this.symbol.text, record);
    }
}
function makeFunction(name, currentSymbol, highlighter) {
    if (name.text == 'add') {
        if (currentSymbol == undefined) {
            highlighter.markError(name.sheet, name.row, name.col, "This command is not preceded by a symbol. " +
                " If you don't assign it to a symbol, it will be ignored.", "warning");
        }
        return new TableFunction(name, currentSymbol);
    }
    else if (name.text == "test") {
        if (currentSymbol == undefined) {
            highlighter.markError(name.sheet, name.row, name.col, "This test command is not preceded by a symbol. " +
                " Tests without a symbol will not execute", "warning");
        }
        return new TestFunction(name, currentSymbol);
    }
    // it's not a reserved word, so it's a new symbol
    return new TableFunction(name, name);
}
const BUILT_IN_FUNCTIONS = [
    "add",
    "test"
];
function toObj(table) {
    return table.map(record => {
        return record.map(entry => {
            return { tier: entry.tier.text,
                text: entry.value.text,
                sheet: entry.value.sheet,
                row: entry.value.row.toString(),
                column: entry.value.col.toString() };
        });
    });
}
function objToTable(obj) {
    const record = [];
    for (const key in obj) {
        record.push(new transducers_1.Literal(new tierParser_1.Tier(key), new transducers_1.GCell(obj[key])));
    }
    return [record];
}
function objToEtcTable(obj) {
    const record = [];
    for (const key in obj) {
        record.push(new transducers_1.Literal(new tierParser_1.Tier(key), new transducers_1.GCell(obj[key])));
        record.push(new transducers_1.Etcetera(new tierParser_1.Tier(key)));
    }
    return [record];
}
/**
 * Project
 *
 * A project represents a possibly multi-sheet program (e.g. one that exists across
 * multiple worksheets inside a single spreadsheet).  You pass unstructured sheets to it
 * (in the form of string[][] representing the cells of that sheet) and it parses them into
 * parsers and manages the symbol table.
 *
 * It also serves as an Edifice (in the
 * design pattern sense) for clients: rather than asking for a parser object and calling parse()
 * on it directly, you just have a Project instance and call parse(symbolName, input).
 */
class Project {
    constructor() {
        this.currentFunction = undefined;
        this.currentSymbol = undefined;
        this.symbolTable = new Map();
        this.testTable = new Map();
        this.transducerTable = new Map();
    }
    hasSymbol(name) {
        return this.symbolTable.has(name);
    }
    allSymbols() {
        return [...this.symbolTable.keys()];
    }
    addRecordToSymbol(name, record) {
        getTableOrThrow(this.symbolTable, name).push(record);
    }
    addTestToSymbol(name, record) {
        getTableOrThrow(this.testTable, name, `Cannot find symbol ${name} in test table`).push(record);
    }
    getTransducer(name) {
        const result = this.transducerTable.get(name);
        if (result == undefined) {
            throw new Error(`Could not find symbol: ${name}`);
        }
        return result;
    }
    complete(input, symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        const table = objToEtcTable(input);
        const transducer = this.getTransducer(symbolName);
        const results = [...transducer.transduceFinal(table, this.transducerTable, randomize, maxResults, accelerate)];
        return toObj(results);
    }
    completeFlatten(input, symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        return this.flatten(this.complete(input, symbolName, randomize, maxResults, accelerate));
    }
    parse(input, symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        const table = objToTable(input);
        const transducer = this.getTransducer(symbolName);
        const results = [...transducer.transduceFinal(table, this.transducerTable, randomize, maxResults, accelerate)];
        return toObj(results);
    }
    parseFlatten(input, symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        return this.flatten(this.parse(input, symbolName, randomize, maxResults, accelerate));
    }
    generate(symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        const transducer = this.getTransducer(symbolName);
        const results = [...transducer.generate(this.transducerTable, randomize, maxResults, accelerate)];
        return toObj(results);
    }
    generateFlatten(symbolName = 'MAIN', randomize = false, maxResults = -1, accelerate = true) {
        return this.flatten(this.generate(symbolName, randomize, maxResults, accelerate));
    }
    sample(symbolName = 'MAIN', maxResults = 1, accelerate = true) {
        const transducer = this.getTransducer(symbolName);
        const results = [...transducer.sample(this.transducerTable, maxResults, accelerate)];
        return toObj(results);
    }
    sampleFlatten(symbolName = 'MAIN', maxResults = -1, accelerate = true) {
        return this.flatten(this.sample(symbolName, maxResults, accelerate));
    }
    flatten(input) {
        return input.map(record => {
            var result = {};
            for (const entry of record) {
                if (entry.tier in result) {
                    result[entry.tier] += entry.text;
                }
                else {
                    result[entry.tier] = entry.text;
                }
            }
            return result;
        });
    }
    containsResult(resultTable, target) {
        for (const resultMap of resultTable) {
            for (const key in resultMap) {
                if (key != target.tier.text) {
                    continue;
                }
                if (resultMap[key] == target.value.text) {
                    return true;
                }
            }
        }
        if (target.value.text.length == 0) {
            return true; // if there's no output, and no output is expected, we're good!
        }
        return false;
    }
    equalsResult(resultTable, target) {
        var found = false;
        for (const resultMap of resultTable) {
            for (const key in resultMap) {
                if (key != target.tier.text) {
                    continue;
                }
                if (resultMap[key] == target.value.text) {
                    found = true;
                    continue;
                }
                return false;
            }
        }
        if (!found && target.value.text.length == 0) {
            return true; // if there's no output, and no output is expected, we're good!
        }
        return found;
    }
    runTests(highlighter) {
        for (const [symbolName, testTable] of this.testTable.entries()) {
            for (const record of testTable) {
                const inputRecord = {};
                const containsRecord = [];
                const equalsRecord = [];
                for (const entry of record) {
                    var parts = entry.tier.text.split(" ");
                    if (parts.length != 2) {
                        highlighter.markError(entry.tier.sheet, entry.tier.row, entry.tier.col, "Invalid test tier: " + entry.tier.text, "error");
                        continue;
                    }
                    const command = parts[0].trim();
                    const tier = parts[1].trim();
                    if (command == "input") {
                        inputRecord[tier] = entry.value.text;
                    }
                    else if (command == "contains") {
                        containsRecord.push(new transducers_1.Literal(new tierParser_1.Tier(tier), entry.value));
                    }
                    else if (command == "equals") {
                        equalsRecord.push(new transducers_1.Literal(new tierParser_1.Tier(tier), entry.value));
                    }
                }
                const result = this.parse(inputRecord, symbolName, false, -1);
                const resultFlattened = this.flatten(result);
                for (const target of containsRecord) {
                    if (!this.containsResult(resultFlattened, target)) {
                        highlighter.markError(target.value.sheet, target.value.row, target.value.col, "Result does not contain specified value. " +
                            "Actual value: \n" + resultFlattened, "error");
                    }
                    else {
                        highlighter.markError(target.value.sheet, target.value.row, target.value.col, "Result contains specified value: \n" + resultFlattened, "info");
                    }
                }
                for (const target of equalsRecord) {
                    if (!this.equalsResult(resultFlattened, target)) {
                        highlighter.markError(target.value.sheet, target.value.row, target.value.col, "Result does not equal specified value. " +
                            "Actual value: \n" + resultFlattened, "error");
                    }
                    else {
                        highlighter.markError(target.value.sheet, target.value.row, target.value.col, "Result equals specified value: \n" + resultFlattened, "info");
                    }
                }
            }
        }
    }
    addRow(cellTexts, sheetName, rowIdx, devEnv) {
        if (isLineEmpty(cellTexts)) {
            return;
        }
        const cells = [];
        for (const [colIdx, text] of cellTexts.entries()) {
            const cell = new transducers_1.GCell(text.trim(), { sheet: sheetName, row: rowIdx, col: colIdx });
            cells.push(cell);
        }
        let firstCell = cells[0];
        let firstCellText = firstCell.text;
        if (firstCellText.startsWith('#')) { // the row's a comment
            for (const cell of cells) {
                if (cell.text.length == 0) {
                    continue;
                }
                devEnv.markComment(cell.sheet, cell.row, cell.col);
            }
            return;
        }
        if (firstCellText.length > 0) {
            if (BUILT_IN_FUNCTIONS.indexOf(firstCellText) < 0) {
                // it's not a built-in function/keyword, so treat it as a new symbol
                this.currentSymbol = firstCell;
                this.symbolTable.set(firstCellText, []);
                this.testTable.set(firstCellText, []);
                devEnv.markSymbol(firstCell.sheet, firstCell.row, firstCell.col);
            }
            else {
                devEnv.markCommand(firstCell.sheet, firstCell.row, firstCell.col);
            }
            this.currentFunction = makeFunction(firstCell, this.currentSymbol, devEnv);
            this.currentFunction.addParams(cells.slice(1), devEnv);
            return;
        }
        // if none of the above are true, this row represents args to the previous function
        // first make sure there IS a function active
        if (this.currentFunction == undefined) {
            // shouldn't have args when there's no function.  mark them all as errors
            for (const cell of cells.slice(1)) {
                if (cell.text.length > 0) {
                    devEnv.markError(cell.sheet, cell.row, cell.col, "Unclear what this cell is here for. " +
                        "Did you forget a function?", "warning");
                }
            }
            return;
        }
        var args = []; // a place to hold valid args; don't want to call the function
        // with args that (e.g.) don't correspond to a parameter
        for (const cell of cells.slice(1)) {
            if (!this.currentFunction.hasColumn(cell.col)) {
                if (cell.text.length > 0) {
                    devEnv.markError(cell.sheet, cell.row, cell.col, "This cell does not appear to belong to a column. " +
                        "Did you forget a column header above?", "warning");
                }
                continue;
            }
            const param = this.currentFunction.getParam(cell.col);
            devEnv.markTier(cell.sheet, cell.row, cell.col, param.text);
            args.push(cell);
        }
        this.currentFunction.call(args, this);
    }
    addSheet(sheetName, cells, devEnv) {
        for (var [rowIdx, row] of cells.entries()) {
            this.addRow(row, sheetName, rowIdx, devEnv);
        }
        this.compile(devEnv);
        return this;
    }
    compile(devEnv) {
        for (const [name, table] of this.symbolTable.entries()) {
            const transducer = transducers_1.transducerFromTable(table, this.transducerTable, devEnv);
            this.transducerTable.set(name, transducer);
        }
        for (const transducer of this.transducerTable.values()) {
            transducer.sanityCheck(this.transducerTable, devEnv);
        }
        return this;
    }
}
exports.Project = Project;
/**
 * Utility: fetch the item from the table or throw the appropriate error.
 *
 * @param msg the error message to print
 */
function getTableOrThrow(table, name, msg = `Cannot find symbol ${name} in symbol table`) {
    const maybeTable = table.get(name);
    if (maybeTable == undefined) {
        throw new Error(msg);
    }
    return maybeTable;
}

},{"./tierParser":5,"./transducers":6}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTier = exports.BinaryTier = exports.UnaryTier = exports.CommentTier = exports.Tier = void 0;
class Tier {
    constructor(text, pos = { sheet: "", row: -1, col: -1 }) {
        this.text = text;
        this.sheet = pos.sheet;
        this.row = pos.row;
        this.col = pos.col;
    }
}
exports.Tier = Tier;
class CommentTier extends Tier {
}
exports.CommentTier = CommentTier;
class UnaryTier extends Tier {
    constructor(name, pos, child) {
        super(name, pos);
        this.child = child;
    }
}
exports.UnaryTier = UnaryTier;
class BinaryTier extends Tier {
    constructor(name, pos, child1, child2) {
        super(name, pos);
        this.child1 = child1;
        this.child2 = child2;
    }
}
exports.BinaryTier = BinaryTier;
const SYMBOL = ["(", ")", "%", "/"];
const UNARY_RESERVED = ["maybe", "require", "before", "after", "final", "alt", "not"];
const ONE_TIER_RESERVED = ["join", "shift", "upward", "downward"];
const ALL_RESERVED = SYMBOL.concat(UNARY_RESERVED).concat(ONE_TIER_RESERVED);
const SUBEXPR = AltTierParser([Identifier, ParensTierParser]);
const NON_COMMENT_EXPR = AltTierParser([UnaryTierParser, OneTierParser, SlashTierParser, SUBEXPR]);
const EXPR = AltTierParser([CommentTierParser, NON_COMMENT_EXPR]);
function* Identifier(input, pos) {
    if (input.length == 0 || ALL_RESERVED.indexOf(input[0]) != -1) {
        return;
    }
    yield [new Tier(input[0], pos), input.slice(1)];
}
function AltTierParser(children) {
    return function* (input, pos) {
        for (const child of children) {
            yield* child(input, pos);
        }
    };
}
function* OneTierParser(input, pos) {
    if (input.length == 0 || ONE_TIER_RESERVED.indexOf(input[0]) == -1) {
        return;
    }
    for (const [t, rem] of Identifier(input.slice(1), pos)) {
        yield [new UnaryTier(input[0], pos, t), rem];
    }
}
function* UnaryTierParser(input, pos) {
    if (input.length == 0 || UNARY_RESERVED.indexOf(input[0]) == -1) {
        return;
    }
    for (const [t, rem] of NON_COMMENT_EXPR(input.slice(1), pos)) {
        yield [new UnaryTier(input[0], pos, t), rem];
    }
}
function* ParensTierParser(input, pos) {
    if (input.length == 0 || input[0] != "(") {
        return;
    }
    for (const [t, rem] of NON_COMMENT_EXPR(input.slice(1), pos)) {
        if (rem.length == 0 || rem[0] != ")") {
            return;
        }
        yield [t, rem.slice(1)];
    }
}
function* SlashTierParser(input, pos) {
    if (input.length == 0) {
        return;
    }
    for (const [t1, rem1] of SUBEXPR(input, pos)) {
        if (rem1.length == 0 || rem1[0] != "/") {
            return;
        }
        for (const [t2, rem2] of NON_COMMENT_EXPR(rem1.slice(1), pos)) {
            yield [new BinaryTier("/", pos, t1, t2), rem2];
        }
    }
}
function* CommentTierParser(input, pos) {
    if (input.length == 0 || input[0] != "%") {
        return;
    }
    yield [new CommentTier("%", pos), []];
}
function parseTier(s, pos) {
    var pieces = s.split(/\s+|(\(|\)|\/)/);
    pieces = pieces.filter((s) => s !== undefined && s !== '');
    var result = [...EXPR(pieces, pos)];
    result = result.filter(([t, r]) => r.length == 0);
    if (result.length == 0) {
        throw new Error(`Cannot parse tier: ${s}`);
    }
    if (result.length > 1) {
        // shouldn't happen with this grammar, but just in case
        throw new Error(`Ambiguous tier description: ${s}`);
    }
    return result[0][0];
}
exports.parseTier = parseTier;

},{}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTable = exports.makeRecord = exports.makeEntry = exports.transducerFromTable = exports.transducerFromEntry = exports.Etcetera = exports.Literal = exports.NullTransducer = exports.getTierAsString = exports.mapKeys = exports.GCell = exports.ParseOptions = void 0;
const util_1 = require("./util");
const tierParser_1 = require("./tierParser");
class ParseOptions {
    constructor(symbolTable, randomize = false, maxResults = -1, parseLeftToRight = true, accelerate = false) {
        this.symbolTable = symbolTable;
        this.randomize = randomize;
        this.maxResults = maxResults;
        this.parseLeftToRight = parseLeftToRight;
        this.accelerate = accelerate;
    }
}
exports.ParseOptions = ParseOptions;
/**
 * Cell
 *
 * You can think of a Cell as a string with extra information about where it belongs in a
 * spreadsheet.  We have to keep that information around for the purposes of syntax highlighting,
 * debugging, etc.
 *
 * When a table is transformed (e.g. where it represents code that has itself undergone transformation),
 * the positional information represents that of the original table.  That way we can highlight that
 * cell during debugging.
 */
class GCell {
    constructor(text, pos = { sheet: "", row: -1, col: -1 }) {
        this.text = text;
        this.sheet = pos.sheet;
        this.row = pos.row;
        this.col = pos.col;
    }
    toString() { return this.text + "(" + this.row + ")"; }
}
exports.GCell = GCell;
function mapKeys(items, inKey, outKey) {
    return items.map(entry => {
        if (entry.tier.text != inKey) {
            return entry;
        }
        return new Literal(new tierParser_1.Tier(outKey, entry.tier), entry.value);
    });
}
exports.mapKeys = mapKeys;
/*
export function tableToJSON(table: GTable): [string, string, string, number, number][][] {
    return table.map((record) => {
        return record.map(([key, value]) => {
            return [key.text, value.text, value.sheet, value.row, value.col];
        });
    });
} */
/*
export function tableToMap(table: GTable): Map<string, string>[] {
    return table.map((record) => {
        const result: Map<string, string> = new Map();
        for (const [key, value] of record) {
            if (result.has(key.text)) {
                result.set(key.text, result.get(key.text) + value.text)
            } else {
                result.set(key.text, value.text);
            }
        }
        return result;
    });
} */
/*
export function tableToObjs(table: GTable): {[key: string]: string}[] {
    return table.map((record) => {
        const result: {[key: string]: string} = {};
        for (const [key, value] of record) {
            if (key.text in result) {
                result[key.text] += value.text;
            } else {
                result[key.text] = value.text;
            }
        }
        return result;
    });
} */
/*
export function flattenToJSON(table: GTable): string {
    return JSON.stringify(tableToObjs(table));
} */
/*
export function flattenToText(table: GTable): string {
    const results : string[] = [];
    for (const map of tableToMap(table)) {
        const subResults : string[] = [];
        for (const [key, value] of map.entries()) {
            subResults.push(key + ": " + value);
        }
        results.push(subResults.join(", "));
    }
    return results.join("\n");
} */
function getTierAsString(table, tier, delim = ", ") {
    const results = table.map(record => {
        var result = "";
        for (const entry of record) {
            if (entry.tier.text == tier) {
                result = result + entry.value.text;
            }
        }
        return result;
    });
    return results.join(delim);
}
exports.getTierAsString = getTierAsString;
class NullTransducer {
    /*
    public transduce(input: GParse, options: ParseOptions): GParse[] {
        return [...this.transduceGen(input, options)];
    } */
    *transduce(input, options) {
        yield input;
    }
    getProb() {
        return 1.0;
    }
    getRelevantTiers() {
        return [];
    }
    validateResult(pastOutput, futureOutput, symbolTable, accelerate) {
        return true;
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        return undefined;
    }
    sanityCheck(symbolTable, devEnv) { }
    /*
    public transduceMany(inputs: GParse[], randomize=false, maxResults=-1): GParse[] {
        const results : GParse[] = [];
        for (const input of inputs) {
            for (const result of this.transduce(input, randomize, maxResults)) {
                results.push(result);
            }
        }
        return results;
    } */
    /**
     * This is the main function that interfaces will call; it takes an
     * input table and, at the end, discards results with unconsumed input.
     *
     * @param input
     * @returns parse
     */
    *transduceFinal(input, symbolTable, randomize = false, maxResults = -1, accelerate = true) {
        //var results: GTable = [];
        var options = new ParseOptions(symbolTable, randomize, maxResults, true, accelerate);
        for (var inputRecord of input) {
            var inputParse = [inputRecord, 0.0, []];
            for (const [remnant, logprob, output] of this.transduce(inputParse, options)) {
                if (remnant.some(entry => !entry.isEmpty())) {
                    continue; // if there's leftovers, keep going
                }
                if (!this.validateOutput(output, symbolTable, accelerate)) {
                    continue; // if the output failed validation (e.g. had a failing "before"), keep going
                }
                const filteredOutput = output.filter(entry => !entry.isEmpty());
                var prob = Math.exp(logprob).toPrecision(3);
                filteredOutput.push(new Literal(new tierParser_1.Tier("p"), new GCell(prob)));
                yield filteredOutput;
            }
        }
    }
    validateOutput(output, symbolTable, accelerate) {
        for (var i = 0; i < output.length; i++) {
            const pastOutput = output.slice(0, i);
            const op = output[i];
            const futureOutput = output.slice(i + 1);
            if (!op.validateResult(pastOutput, futureOutput, symbolTable, accelerate)) {
                return false;
            }
        }
        return true;
    }
    *generate(symbolTable, randomize = false, maxResults = -1, accelerate = true) {
        const input = makeTable([[["", ""]]]); // make an empty input to transduce from
        yield* this.transduceFinal(input, symbolTable, randomize, maxResults, accelerate);
    }
    *sample(symbolTable, maxResults = 1, accelerate = true) {
        if (maxResults == -1) {
            maxResults = 1;
        }
        var numFailures = 0;
        var maxFailures = 100 * maxResults;
        var resultsFound = 0;
        while (resultsFound < maxResults) {
            const sampleResult = [...this.generate(symbolTable, true, 1, accelerate)];
            if (sampleResult.length == 0) {
                numFailures++;
            }
            if (numFailures > maxFailures) {
                throw new Error("Failing to sample from grammar; try generating to see if has any output at all.");
            }
            resultsFound++;
            yield* sampleResult;
        }
    }
}
exports.NullTransducer = NullTransducer;
class CellTransducer extends NullTransducer {
    constructor(tier, value) {
        super();
        this.tier = tier;
        this.value = value;
    }
}
class CommentTransducer extends CellTransducer {
}
class UnaryTransducer extends CellTransducer {
    constructor(tier, value) {
        super(tier, value);
        const childTier = tier.child;
        this.child = transducerFromTier(childTier, value);
    }
    sanityCheck(symbolTable, devEnv) {
        this.child.sanityCheck(symbolTable, devEnv);
    }
    getRelevantTiers() {
        return this.child.getRelevantTiers();
    }
}
class RequireTransducer extends UnaryTransducer {
    compatibleWithFirstChar(tier, c, symbolTable) {
        return this.child.compatibleWithFirstChar(tier, c, symbolTable);
    }
    /*
    public transduce([input, logprob, pastOutput]: GParse, options: ParseOptions): GParse[] {

        const results : GParse[] = [];
        for (const [rem, newprob, output] of this.child.transduce([input, logprob, []], options)) {
            const newInput: GRecord = [...output, ...rem];
            results.push([newInput, logprob, pastOutput]);
        }

        return results;
    } */
    *transduce([input, logprob, pastOutput], options) {
        for (const [rem, newprob, output] of this.child.transduce([input, logprob, []], options)) {
            const newInput = [...output, ...rem];
            yield [newInput, logprob, pastOutput];
        }
    }
}
class FinalTransducer extends UnaryTransducer {
    compatibleWithFirstChar(tier, c, symbolTable) {
        return true;
    }
    /*
    public transduce(inputParse: GParse, options: ParseOptions): GParse[] {
        return this.child.transduce(inputParse, options).filter(([remnant, p, o]) => {
            return !remnant.some(([key, value]) => value.text.length > 0 );
        });
    } */
    *transduce(inputParse, options) {
        for (const [remnant, p, output] of this.child.transduce(inputParse, options)) {
            if (remnant.some(entry => !entry.isEmpty())) {
                continue;
            }
            yield [remnant, p, output];
        }
    }
}
class BeforeTransducer extends UnaryTransducer {
    constructor() {
        super(...arguments);
        this.value = new GCell("*");
    }
    testChar(index, c) {
        return false;
    }
    length() {
        return 0;
    }
    slice(start, end) {
        return this;
    }
    isEmpty() {
        return true;
    }
    validateResult(pastOutput, futureOutput, symbolTable, accelerate) {
        const childOptions = {
            symbolTable: symbolTable,
            randomize: false,
            maxResults: 1,
            parseLeftToRight: true,
            accelerate: accelerate
        };
        const input = [futureOutput, 0.0, pastOutput];
        const results = [...this.child.transduce(input, childOptions)];
        if (results.length > 0) {
            return true;
        }
        return false;
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        return this.child.compatibleWithFirstChar(tier, c, symbolTable);
    }
    *transduce([input, logprob, pastOutput], options) {
        /* if (this.child instanceof Literal) {
            for (const [rem, newprob, output] of this.child.transduce([input, logprob, []], options)) {
                const newInput: GRecord = [...output, ...rem];
                for (const tier in this.getRelevantTiers()) {
                    if (record_has_key(input, tier)) {
                        continue;
                    }
                    newInput.push(new Etcetera(new Tier(tier)));
                }
                yield [newInput, logprob, pastOutput];
            }
        } else { */
        const output = [...pastOutput, this];
        yield [input, logprob, output];
        /* } */
    }
}
class BeforeTransducer2 extends UnaryTransducer {
    constructor(tier, value) {
        super(tier, value);
        const relevantTiers = this.child.getRelevantTiers();
        if (relevantTiers.length < 1) {
            throw new Error("Before transducers must affect one tier; " +
                "this before transducer does not appear to affect any tiers");
        }
        if (relevantTiers.length > 1) {
            throw new Error("Before transducers can only affect one tier. " +
                `This before transducer can potentially affect multiple tiers: ${relevantTiers.join(", ")}`);
        }
        this.affectedTier = relevantTiers[0];
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        return this.child.compatibleWithFirstChar(tier, c, symbolTable);
    }
    /*
    public transduce(inputParse: GParse, options: ParseOptions): GParse[] {
        const childOptions: ParseOptions = {
            randomize: false,
            maxResults: 1,
            parseLeftToRight: true,
            accelerate: options.accelerate
        }
        const results = this.child.transduce(inputParse, options);
        if (results.length > 0) {
            return [inputParse];
        }
        return [];
    } */
    *transduce(inputParse, options) {
        const childOptions = {
            symbolTable: options.symbolTable,
            randomize: false,
            maxResults: 1,
            parseLeftToRight: true,
            accelerate: options.accelerate
        };
        const [input, logprob, pastOutput] = inputParse;
        // The behavior of a Before transducer depends on whether the relevant tier is in the input
        // (in which case the material to parse is already present, go ahead and parse it) or whether 
        // it's not (in which case it doesn't yet exist, put a new requirement into the input)
        if (record_has_key(input, this.affectedTier)) {
            const results = [...this.child.transduce(inputParse, options)];
            if (results.length > 0) {
                yield inputParse;
            }
            return;
        }
        // it's not in the input, add a requirement to the input 
    }
}
function recordToString(record) {
    return record.map(entry => entry.toString()).join(", ");
}
class AfterTransducer extends UnaryTransducer {
    compatibleWithFirstChar(tier, c, symbolTable) {
        //return this.child.compatibleWithFirstChar(tier, c, symbolTable);
        return undefined;
    }
    /*
    public transduce(inputParse: GParse, options: ParseOptions): GParse[] {
        const [input, logprob, pastOutput] = inputParse;
        const childParse: GParse = [[...pastOutput], 1.0, []];
        const childOptions: ParseOptions = {
            randomize: false,
            maxResults: 1,
            parseLeftToRight: false,
            accelerate: options.accelerate
        }
        const results = this.child.transduce(childParse, childOptions);
        if (results.length > 0) {
            return [inputParse];
        }
        return [];
    } */
    *transduce(inputParse, options) {
        const [input, logprob, pastOutput] = inputParse;
        const childParse = [[...pastOutput], 1.0, []];
        const childOptions = {
            symbolTable: options.symbolTable,
            randomize: false,
            maxResults: 1,
            parseLeftToRight: false,
            accelerate: false,
        };
        const results = [...this.child.transduce(childParse, childOptions)];
        if (results.length > 0) {
            yield inputParse;
        }
    }
}
class NotTransducer extends UnaryTransducer {
    constructor(tier, value) {
        super(tier, value);
        this.trivial = false;
        if (value.text.length == 0) {
            this.trivial = true;
        }
    }
    sanityCheck(symbolTable, devEnv) {
        this.child.sanityCheck(symbolTable, devEnv);
        if (this.child instanceof BeforeTransducer) {
            devEnv.markError(this.tier.sheet, this.tier.row, this.tier.col, "To negate a before transducer, use 'before not' rather than 'not before'.", "error");
        }
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        var result = this.child.compatibleWithFirstChar(tier, c, symbolTable);
        if (result == false) {
            return true;
        }
        return undefined;
    }
    /*
    public transduce(inputParse: GParse, options: ParseOptions): GParse[] {
        if (this.trivial) {
            return [inputParse];
        }
        const results = this.child.transduce(inputParse, options);
        if (results.length > 0) {
            return [];
        }
        return [inputParse];
    } */
    *transduce(inputParse, options) {
        if (this.trivial) {
            yield inputParse;
            return;
        }
        const results = [...this.child.transduce(inputParse, options)];
        if (results.length > 0) {
            return;
        }
        yield inputParse;
    }
}
class AlternationTransducer extends NullTransducer {
    constructor(children) {
        super();
        this.childrenAndWeights = [];
        this.relevantChildren = new Map();
        var weights = children.map(child => child.getProb());
        const weightSum = weights.reduce((a, b) => a + b, 0);
        weights = weights.map(w => w / weightSum);
        this.childrenAndWeights = children.map((child, i) => [child, weights[i]]);
    }
    getRelevantTiers() {
        var results = [];
        for (const [child, weight] of this.childrenAndWeights) {
            results = results.concat(child.getRelevantTiers());
        }
        return results;
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        var canBeUndefined = false;
        for (const [child, weight] of this.childrenAndWeights) {
            var result = child.compatibleWithFirstChar(tier, c, symbolTable);
            if (result == true) {
                return true;
            }
            if (result == undefined) {
                canBeUndefined = true;
            }
        }
        if (canBeUndefined) {
            return undefined;
        }
        return false;
    }
    sanityCheck(symbolTable, devEnv) {
        for (const [child, weight] of this.childrenAndWeights) {
            child.sanityCheck(symbolTable, devEnv);
        }
    }
    firstCharOfInput(input) {
        for (const entry of input) {
            if (entry.value.text == "") {
                continue;
            }
            return [entry.tier.text, entry.value.text[0]];
        }
        return undefined;
    }
    *transduce(input, options) {
        var relevantChildrenAndWeights = this.childrenAndWeights;
        if (options.accelerate) {
            const [inputRecord, logprob, previousOutput] = input;
            const firstCharPair = this.firstCharOfInput(inputRecord);
            if (firstCharPair != undefined) {
                var firstCharStr = firstCharPair.join(":::");
                relevantChildrenAndWeights = this.relevantChildren.get(firstCharStr);
                if (relevantChildrenAndWeights == undefined) {
                    relevantChildrenAndWeights = [];
                    const [tier, c] = firstCharPair;
                    for (const [child, weight] of this.childrenAndWeights) {
                        if (child.compatibleWithFirstChar(tier, c, options.symbolTable) == false) {
                            continue;
                        }
                        relevantChildrenAndWeights.push([child, weight]);
                    }
                    this.relevantChildren.set(firstCharStr, relevantChildrenAndWeights);
                }
            }
        }
        if (options.randomize) {
            var items = new util_1.RandomPicker([...relevantChildrenAndWeights]);
        }
        else {
            var items = relevantChildrenAndWeights;
        }
        var resultsFound = 0;
        for (var item of items) {
            if (item == undefined) {
                throw new Error("Received an undefined output from RandomPicker.");
            }
            const [child, prob] = item;
            for (var [remnant, logprob, output] of child.transduce(input, options)) {
                logprob += Math.log(prob);
                yield [remnant, logprob, output];
                resultsFound++;
                if (options.maxResults > 0 && resultsFound == options.maxResults) {
                    return;
                }
            }
        }
    }
}
class MaybeTransducer extends UnaryTransducer {
    constructor(tier, value) {
        super(tier, value);
        this.alternation = new AlternationTransducer([this.child, new NullTransducer()]);
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        const result = this.alternation.compatibleWithFirstChar(tier, c, symbolTable);
        if (result == true) {
            return true;
        }
        return undefined;
    }
    /*
    public transduce(input: GParse, options: ParseOptions): GParse[] {
        return this.alternation.transduce(input, options);
    } */
    *transduce(input, options) {
        yield* this.alternation.transduce(input, options);
    }
}
/***********************
 * One-tier transducers
 *
 * These are unary transducers whose only argument can be an atomic tier name,
 * e.g. "shift text", rather than a potentially complex tier name (e.g.
 * "shift text/gloss" or "shift maybe text").
 *
 * Their constructors take a tier cell, a value cell, and a symbol table.
 */
class UpdownTransducer extends CellTransducer {
    constructor(tier, value, direction) {
        super(tier, value);
        this.direction = direction;
        this.childTier = tier.child;
        if (direction == "upward") {
            this.inputTier = "down";
            this.outputTier = "up";
        }
        else {
            this.inputTier = "up";
            this.outputTier = "down";
        }
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        if (this.direction == "downward") {
            return undefined;
        }
        if (this.value.text.length == 0) {
            return undefined;
        }
        const transducer = symbolTable.get(this.value.text);
        if (transducer == undefined) {
            throw new Error(`Could not find symbol: ${this.value.text}`);
        }
        const result = transducer.compatibleWithFirstChar(tier, c, symbolTable);
        if (result == false) {
            return undefined;
        }
        return result;
    }
    sanityCheck(symbolTable, devEnv) {
        if (this.value.text == '') {
            return;
        }
        if (!symbolTable.has(this.value.text)) {
            devEnv.markError(this.value.sheet, this.value.row, this.value.col, `${this.value.text} is in a var column, but there is no variable of this name.`, "error");
        }
    }
    applyConversion(parse, options) {
        const [input, logprob, pastOutput] = parse;
        const recordIsComplete = !input.some(entry => {
            if (entry.tier.text != this.inputTier) {
                return false;
            }
            if (entry.length() == Number.POSITIVE_INFINITY) {
                return false;
            }
            return entry.value.text.length > 0;
        });
        if (recordIsComplete) { // only parse incomplete ones, or else recurse forever
            return [parse];
        }
        const transducer = options.symbolTable.get(this.value.text);
        if (transducer == undefined) {
            throw new Error(`Could not find symbol: ${this.value.text}`);
        }
        var outputs = [...transducer.transduce(parse, options)];
        if (outputs.length == 0) {
            outputs = [stepOneCharacter(parse, this.inputTier, this.outputTier)];
        }
        var results = outputs.map(output => this.applyConversion(output, options));
        return Array.prototype.concat.apply([], results);
    }
    /*
    public transduce(parse: GParse, options: ParseOptions): GParse[] {

        if (this.value.text.length == 0) {
            return [parse];
        }
        var [input, logprob, pastOutput] = parse;

        var wheat: GRecord = [];
        var chaff: GRecord = [];
        var inputSource =  this.direction == "upward" ? input : pastOutput;
        for (const [key, value] of inputSource) {
            if (key.text == this.key.text) {
                wheat.push([new GCell(this.inputTier), value]);
                continue;
            }
            chaff.push([key, value]);
        }

        
        var results: GParse[] = [];

        for (var [remnant, newprob, output] of this.applyConversion([wheat, logprob, []], options)) {
            const result = [...chaff];
            for (const [key, value] of output) {
                if (key.text == this.outputTier) {
                    result.push([this.key, value]); // probably want to change this to the original key eventually,
                                                    // so that phonology doesn't mess up origin tracing.
                }
            }

            if (this.direction == "upward") {
                results.push([result, newprob, pastOutput]);
            } else {
                results.push([input, newprob, result]);
            }
        }
        return results;
    } */
    *transduce(parse, options) {
        if (this.value.text.length == 0) {
            yield parse;
            return;
        }
        var [input, logprob, pastOutput] = parse;
        var wheat = [];
        var chaff = [];
        var inputSource = this.direction == "upward" ? input : pastOutput;
        for (const entry of inputSource) {
            if (entry.tier.text == this.childTier.text) {
                wheat.push(new Literal(new tierParser_1.Tier(this.inputTier), entry.value));
                continue;
            }
            chaff.push(entry);
        }
        var results = [];
        for (var [remnant, newprob, output] of this.applyConversion([wheat, logprob, []], options)) {
            const result = [...chaff];
            for (const entry of output) {
                if (entry.tier.text == this.outputTier) {
                    result.push(new Literal(this.childTier, entry.value));
                    // probably want to change this to the original key eventually,
                    // so that phonology doesn't mess up origin tracing.
                }
            }
            if (this.direction == "upward") {
                yield [result, newprob, pastOutput];
            }
            else {
                yield [input, newprob, result];
            }
        }
    }
}
class UpTransducer extends UpdownTransducer {
    constructor(tier, value) {
        super(tier, value, "upward");
    }
}
class DownTransducer extends UpdownTransducer {
    constructor(tier, value) {
        super(tier, value, "downward");
    }
}
class JoinTransducer extends CellTransducer {
    constructor(tier, value) {
        super(tier, value);
        this.childTier = tier.child;
    }
    compatibleWithFirstChar(tier, c) {
        return true;
    }
    /*
    public transduce([input, logprob, pastOutput]: GParse, options: ParseOptions): GParse[] {
        const parts: string[] = [];
        const output = pastOutput.filter(([key, value]) => {
            if (key.text == this.key.text) {
                parts.push(value.text);
                return false;
            }
            return true;
        });
        const flattenedString = parts.join(this.value.text);
        const flattenedCell = new GCell(flattenedString, this.value);
        output.push([this.key, flattenedCell]);
        return [[input, logprob, output]];
    } */
    *transduce([input, logprob, pastOutput], options) {
        const parts = [];
        const output = pastOutput.filter(entry => {
            if (entry.tier.text == this.childTier.text) {
                parts.push(entry.value.text);
                return false;
            }
            return true;
        });
        const flattenedString = parts.join(this.value.text);
        const flattenedCell = new GCell(flattenedString, this.value);
        output.push(new Literal(this.childTier, flattenedCell));
        yield [input, logprob, output];
    }
}
/**
 * ShiftTransducer
 *
 * "shift" is a unary transducer that simply copies the value on an input tier into an output tier.
 * E.g., "shift surf":"gloss" would copy "gloss" tier of the input into the "gloss" tier of the output.
 * Often will be used for the same tier, e.g. "shift surf":"surf".
 */
class ShiftTransducer extends CellTransducer {
    constructor(tier, value) {
        super(tier, value);
        const childTier = tier.child;
    }
    compatibleWithFirstChar(tier, c) {
        return true;
    }
    /*
    public transduce([input, logprob, pastOutput]: GParse, options: ParseOptions): GParse[] {
        var [output, remnant] = winnow(input, ([key, value]) => key.text == this.value.text); // split entries into relevant and irrelevant
        output = mapKeys(output, this.value.text, this.tier.text);
        return [[remnant, logprob, [...pastOutput, ...output]]];
    } */
    *transduce([input, logprob, pastOutput], options) {
        var [output, remnant] = util_1.winnow(input, entry => entry.tier.text == this.value.text); // split entries into relevant and irrelevant
        output = mapKeys(output, this.value.text, this.tier.text);
        yield [remnant, logprob, [...pastOutput, ...output]];
    }
}
/******************
 * Atomic transducers
 *
 */
class Literal extends CellTransducer {
    constructor(tier, value) {
        super(tier, value);
    }
    testChar(index, c) {
        //if (index >= this.value.text.length) {
        //    throw new Error(`Index ${index} out of range for string ${this.value.text}.`)
        //}
        return this.value.text[index] == c;
    }
    length() {
        return this.value.text.length;
    }
    slice(start, end) {
        const remnantCell = new GCell(this.value.text.slice(start, end), this.value);
        return new Literal(this.tier, remnantCell);
    }
    isEmpty() {
        return this.value.text.length == 0;
    }
    toString() {
        return this.tier.text + ":" + this.value.text;
    }
    compatibleWithFirstChar(tier, c) {
        if (this.value.text == "") {
            return undefined;
        }
        if (this.tier.text != tier) {
            return undefined;
        }
        if (this.value.text.startsWith(c)) {
            return true;
        }
        return false;
    }
    *transduce(parse, options) {
        const [input, logprob, pastOutput] = parse;
        if (this.value.text.length == 0) {
            var output = [...pastOutput];
            if (options.parseLeftToRight) {
                output.push(this);
            }
            else {
                output.unshift(this);
            }
            yield [input, logprob, output];
            return;
        }
        var consumedInput = [];
        var tierFoundInInput = false;
        var needle = this.value.text;
        const inputEntries = options.parseLeftToRight ? input : input.reverse();
        for (const entry of inputEntries) {
            if (entry.tier.text != this.tier.text) { // not what we're looking for, move along
                consumedInput.push(entry);
                continue;
            }
            tierFoundInInput = true;
            if (options.parseLeftToRight) {
                for (var i = 0; i < entry.length(); i++) {
                    if (needle.length == 0) {
                        break;
                    }
                    if (!entry.testChar(i, needle[0])) {
                        return;
                    }
                    needle = needle.slice(1);
                }
                if (needle.length == 0) {
                    consumedInput.push(entry.slice(i, undefined));
                }
            }
            else {
                for (var i = entry.length() - 1; i >= 0; i--) {
                    if (needle.length == 0) {
                        break;
                    }
                    if (!entry.testChar(i, needle[needle.length - 1])) {
                        return;
                    }
                    needle = needle.slice(0, needle.length - 1);
                }
                if (needle.length == 0) {
                    consumedInput.unshift(entry.slice(0, i + 1));
                }
            }
        }
        if (tierFoundInInput && needle.length > 0) {
            return;
        }
        /* if (!options.parseLeftward) {
            consumedInput = consumedInput.reverse();
        } */
        var output = [...pastOutput];
        if (options.parseLeftToRight) {
            output.push(this);
        }
        else {
            output.unshift(this);
        }
        yield [consumedInput, logprob, output];
    }
}
exports.Literal = Literal;
class ProbTransducer extends CellTransducer {
    constructor(tier, value) {
        super(tier, value);
        if (value.text == "") {
            this.p = 1.0;
        }
        try {
            this.p = parseFloat(value.text);
        }
        catch (err) {
            throw new Error(`${value.text} is not a valid value for p; only numbers can be p values.`);
        }
        if (this.p < 0) {
            throw new Error(`${value.text} is not a valid value for p; only positive numbers can be p values.`);
        }
    }
    getProb() {
        return this.p;
    }
}
class VarTransducer extends CellTransducer {
    //private transducer : Transducer | undefined = undefined;
    constructor(tier, value) {
        super(tier, value);
    }
    sanityCheck(symbolTable, devEnv) {
        if (this.value.text == '') {
            return;
        }
        if (!symbolTable.has(this.value.text)) {
            if (this.value.text.indexOf("|") != -1) {
                devEnv.markError(this.value.sheet, this.value.row, this.value.col, `${this.value.text} is in a var column, but there is no variable of this name.  ` +
                    "Did you mean 'alt var' above?", "error");
                return;
            }
            devEnv.markError(this.value.sheet, this.value.row, this.value.col, `${this.value.text} is in a var column, but there is no variable of this name.`, "error");
        }
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        if (this.value.text.length == 0) {
            return undefined;
        }
        const transducer = symbolTable.get(this.value.text);
        if (transducer == undefined) {
            throw new Error(`Could not find symbol: ${this.value.text}`);
        }
        return transducer.compatibleWithFirstChar(tier, c, symbolTable);
    }
    /*
    public transduce(input: GParse, options: ParseOptions): GParse[] {
        if (this.value.text.length == 0) {
            return [input];
        }
        const transducer = this.symbolTable.get(this.value.text);
        if (transducer == undefined) {
            throw new Error(`Could not find symbol: ${this.value.text}`);
        }
        return transducer.transduce(input, options);
    } */
    *transduce(input, options) {
        if (this.value.text.length == 0) {
            yield input;
            return;
        }
        const transducer = options.symbolTable.get(this.value.text);
        if (transducer == undefined) {
            throw new Error(`Could not find symbol: ${this.value.text}`);
        }
        yield* transducer.transduce(input, options);
    }
}
class Etcetera {
    constructor(tier) {
        this.tier = tier;
        this.value = new GCell("*");
    }
    testChar(index, c) {
        return true;
    }
    length() {
        return Number.POSITIVE_INFINITY;
    }
    slice(start, end) {
        return this;
    }
    isEmpty() {
        return true;
    }
    validateResult(pastOutput, futureOutput, symbolTable, accelerate) {
        return true;
    }
}
exports.Etcetera = Etcetera;
class ConcatenationTransducer extends NullTransducer {
    constructor(children) {
        super();
        this.children = children;
    }
    compatibleWithFirstChar(tier, c, symbolTable) {
        for (const child of this.children) {
            var result = child.compatibleWithFirstChar(tier, c, symbolTable);
            if (result != undefined) {
                return result;
            }
        }
        return true;
    }
    getRelevantTiers() {
        var results = [];
        for (const child of this.children) {
            results = results.concat(child.getRelevantTiers());
        }
        return results;
    }
    sanityCheck(symbolTable, devEnv) {
        for (const child of this.children) {
            child.sanityCheck(symbolTable, devEnv);
        }
    }
    *transduce(input, options) {
        var results = [input];
        var children = options.parseLeftToRight ? this.children : this.children.reverse();
        for (const child of children) {
            var newResults = [];
            midloop: for (const result1 of results) {
                for (const result2 of child.transduce(result1, options)) {
                    newResults.push(result2);
                    if (options.maxResults > 0 && newResults.length > options.maxResults) {
                        break midloop;
                    }
                }
            }
            results = newResults;
        }
        for (const result of results) {
            yield result;
        }
    }
    getProb() {
        return this.children.reduce((prod, child) => prod * child.getProb(), 1.0);
    }
}
class SlashTransducer extends ConcatenationTransducer {
    constructor(tier, value) {
        const child1Tier = tier.child1;
        const child2Tier = tier.child2;
        const child1Transducer = transducerFromTier(child1Tier, value);
        const child2Transducer = transducerFromTier(child2Tier, value);
        super([child1Transducer, child2Transducer]);
    }
}
class AltTransducer extends AlternationTransducer {
    constructor(tier, value) {
        const childTier = tier.child;
        const childTransducers = [];
        for (var s of value.text.split("|")) {
            s = s.trim();
            const childValue = new GCell(s, value);
            const childTransducer = transducerFromTier(childTier, childValue);
            childTransducers.push(childTransducer);
        }
        super(childTransducers);
    }
}
const TRANSDUCER_CONSTRUCTORS = {
    "maybe": MaybeTransducer,
    "require": RequireTransducer,
    "before": BeforeTransducer,
    "after": AfterTransducer,
    "final": FinalTransducer,
    "shift": ShiftTransducer,
    "join": JoinTransducer,
    "upward": UpTransducer,
    "downward": DownTransducer,
    "alt": AltTransducer,
    "not": NotTransducer,
    "%": CommentTransducer,
    "p": ProbTransducer,
    "var": VarTransducer,
    "/": SlashTransducer
};
function transducerFromTier(tier, value) {
    if (TRANSDUCER_CONSTRUCTORS[tier.text] != undefined) {
        const constructor = TRANSDUCER_CONSTRUCTORS[tier.text];
        return new constructor(tier, value);
    }
    return new Literal(tier, value);
}
function transducerFromEntry(entry, symbolTable, devEnv) {
    try {
        var tierStructure = tierParser_1.parseTier(entry.tier.text, entry.tier);
        return transducerFromTier(tierStructure, entry.value);
    }
    catch (err) {
        devEnv.markError(entry.tier.sheet, entry.tier.row, entry.tier.col, err.toString(), "error");
        return new NullTransducer(); // if the tier is erroneous, return a trivial parser
        // so that the grammar can still execute
    }
}
exports.transducerFromEntry = transducerFromEntry;
function transducerFromRecord(record, symbolTable, devEnv) {
    const children = record.map(entry => transducerFromEntry(entry, symbolTable, devEnv));
    return new ConcatenationTransducer(children);
}
function transducerFromTable(table, symbolTable, devEnv) {
    const children = table.map(record => transducerFromRecord(record, symbolTable, devEnv));
    return new AlternationTransducer(children);
}
exports.transducerFromTable = transducerFromTable;
function stepOneCharacter([input, logprob, pastOutput], inTier, outTier) {
    var consumedInput = [];
    var output = [...pastOutput];
    var charFound = false;
    for (const entry of input) {
        if (!charFound && entry.tier.text == inTier && entry.value.text.length > 0) {
            const c = entry.value.text[0];
            const remnant = new GCell(entry.value.text.slice(1), entry.value);
            consumedInput.push(new Literal(entry.tier, remnant));
            const newOutputEntry = new Literal(new tierParser_1.Tier(outTier), new GCell(c, entry.value));
            output.push(newOutputEntry);
            charFound = true;
            continue;
        }
        consumedInput.push(entry);
    }
    return [consumedInput, logprob, output];
}
function makeEntry(key, value) {
    return new Literal(new tierParser_1.Tier(key), new GCell(value));
}
exports.makeEntry = makeEntry;
function makeRecord(cells) {
    return cells.map(([key, value]) => makeEntry(key, value));
}
exports.makeRecord = makeRecord;
function makeTable(cells) {
    return cells.map(makeRecord);
}
exports.makeTable = makeTable;
function record_has_key(record, key) {
    for (const entry of record) {
        if (entry.tier.text == key) {
            return true;
        }
    }
    return false;
}

},{"./tierParser":5,"./util":7}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.winnow = exports.RandomPicker = exports.NULL_POS = void 0;
exports.NULL_POS = { sheet: "", row: -1, col: -1 };
class RandomPicker {
    constructor(items) {
        this.items = items;
        this.sum_of_weights = 0;
        this.sum_of_weights = this.items.reduce((total, n) => total + n[1], 0);
    }
    [Symbol.iterator]() {
        return this;
    }
    push(item, weight) {
        this.items.push([item, weight]);
        this.sum_of_weights += weight;
    }
    pop() {
        if (this.items.length == 0) {
            return undefined;
        }
        if (this.items.length == 1) {
            return this.items.pop();
        }
        var n = Math.random() * this.sum_of_weights;
        for (var i = 0; i < this.items.length; i++) {
            n -= this.items[i][1];
            if (n < 0) {
                this.sum_of_weights -= this.items[i][1];
                const result = this.items[i];
                this.items.splice(i, 1);
                return result;
            }
        }
        throw new Error("Somehow didn't pick an item; something's wrong.");
    }
    next() {
        if (this.items.length == 0) {
            return { done: true, value: undefined };
        }
        const popped = this.pop();
        if (popped == undefined) {
            throw new Error("Somehow didn't pick an item; something's wrong.");
        }
        return { done: false, value: popped };
    }
}
exports.RandomPicker = RandomPicker;
/*
function shuffle<T>(ar: T[]): T[] {
    ar = [...ar];
    var currentIndex = ar.length;
    var temporaryValue: T;
    var randomIndex: number;
  
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
  
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
  
      // And swap it with the current element.
      temporaryValue = ar[currentIndex];
      ar[currentIndex] = ar[randomIndex];
      ar[randomIndex] = temporaryValue;
    }
  
    return ar;
}
*/
function winnow(items, f) {
    const trueResults = [];
    const falseResults = [];
    for (const item of items) {
        if (f(item)) {
            trueResults.push(item);
            continue;
        }
        falseResults.push(item);
        continue;
    }
    return [trueResults, falseResults];
}
exports.winnow = winnow;

},{}]},{},[3])(3)
});
