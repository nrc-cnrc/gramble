import { ConcatState, Empty, Join, Lit, Semijoin, Seq, State, Uni } from "../src/stateMachine";

function poisson(mean: number): number {
    const L = Math.exp(-mean);
    let p = 1.0;
    let k = 0;
    
    do {
        k++;
        p *= Math.random();
    } while (p > L);
    
    return k - 1;
}

function randomChoice<T>(choices: T[]) {
    var index = Math.floor(Math.random() * choices.length);
    return choices[index];
}

function range(length: number): number[] {
    return [...Array(length).keys()];
}

function poissonRange(mean: number): number[] {
    return range(poisson(mean));
}

const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");

function randomString(): string {
    const letters = poissonRange(4).map(_ => randomChoice(LETTERS));
    return letters.join("");
}

type randomConstr = (t: string[], n: number) => State;
const RANDOM_CONSTRUCTORS: [randomConstr, number][] = [
    [ randomLit, 0.4 ],
    [ randomSeq, 0.25 ],
    [ randomUnion, 0.25 ],
    [ randomEmpty, 0.1 ],
]

function randomEmpty(possibleTapes: string[], allowedDepth: number = 5): State {
    return Empty();
}

function randomGrammar(): State {
    const length = poisson(3)+1;  // always has to be at least one tape
    const tapes = range(length).map(n => `T${n+1}`);
    return randomState(tapes, 5);
}

function randomState(possibleTapes: string[], allowedDepth: number = 5): State {
    if (allowedDepth <= 1) {
        return randomLit(possibleTapes, 1);
    } 
    const rand = Math.random();
    var totalP = 0.0;
    for (const [constr, p] of RANDOM_CONSTRUCTORS) {
        totalP += p;
        if (rand <= totalP) {
            return constr(possibleTapes, allowedDepth-1);
        }
    }
    return Empty();
}

function randomLit(possibleTapes: string[], allowedDepth: number = 5): State {
    const tape = randomChoice(possibleTapes);
    const text = randomString();
    return Lit(tape, text);
}

function randomSeq(possibleTapes: string[], allowedDepth: number = 5): State {
    const children = poissonRange(3).map(_ => randomState(possibleTapes, allowedDepth));
    return Seq(...children);
}

function randomUnion(possibleTapes: string[], allowedDepth: number = 5): State {
    const children = poissonRange(3).map(_ => randomState(possibleTapes, allowedDepth));
    return Uni(...children);
}

import * as path from 'path';
import { StringDict } from "../src/util";
import { removeHiddenFields } from "./testUtils";
import { expect } from "chai";


const TRIALS = 100;
const MAX_RECURSION = 4;
const MAX_CHARS = 1000;

function getOutputs(grammar: State): StringDict[] {
    const outputs = [...grammar.generate(false, MAX_RECURSION, MAX_CHARS)];
    return removeHiddenFields(outputs);
}


export function testOutputEquals(grammar1: State, grammar2: State): void {
    // Check that the output dictionaries of State.generate() match the expected
    // outputs.
    //
    // Outputs can be in any order.
    
    const outputs1 = getOutputs(grammar1);
    const outputs2 = getOutputs(grammar2);

    for (var o1 of outputs1) {
        try {
            expect(outputs2).to.deep.include(o1);
        } catch (e) {
            console.log(`An output from ${grammar1.id} was not generated by ${grammar2.id}:\n${JSON.stringify(o1)}`);
            throw e;
        }
    }
    for (var o2 of outputs2) {
        try {
            expect(outputs1).to.deep.include(o2);
        } catch (e) {
            console.log(`An output from ${grammar2.id} was not generated by ${grammar1.id}:\n${JSON.stringify(o2)}`);
            throw e;
        }
    }
}


/*

PROPERTIES WE TEST


# PROPERTIES YOU MIGHT THINK SHOULD WORK, BUT DON'T

## Join(X, X) = X

You might think that any grammar joined with itself has the same outputs 
it originally did, but this isn't the case.  The following simple grammar has two
outputs, [{A:a}, {B:b}]

   A:a | B:b

but when joined with itself, it has three outputs: [{A:a}, {B:b}, {A:a, B:b}]

*/
/*
describe(`${path.basename(module.filename)}`, function() {

    describe(`${TRIALS} random grammars`, function() {

        const grammars = range(TRIALS).map(_ => randomGrammar());

        it('Semijoin(X, X) = X', function() {
            for (const g of grammars) {
                const gJoinG = Semijoin(g, g);
                testOutputEquals(g, gJoinG);
            }
        });
    });

});
*/