"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6334],{9574:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var n=s(5893),r=s(1151);const o={id:"gs4",title:"Adding more fields",sidebar_label:"Adding more fields"},i=void 0,d={id:"tutorial/gs4",title:"Adding more fields",description:"The program in on the previous page only had one field, text.  It's not very useful with just one field!",source:"@site/docs/tutorial/gs4.md",sourceDirName:"tutorial",slug:"/tutorial/gs4",permalink:"/gramble/docs/tutorial/gs4",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"gs4",title:"Adding more fields",sidebar_label:"Adding more fields"},sidebar:"tutorialSidebar",previous:{title:"A simple Gramble program",permalink:"/gramble/docs/tutorial/gs3"},next:{title:"From transducer to database",permalink:"/gramble/docs/tutorial/gs5"}},a={},l=[{value:"From acceptor to transducer",id:"from-acceptor-to-transducer",level:2},{value:"Trying out a transduction",id:"trying-out-a-transduction",level:2}];function c(e){const t={code:"code",em:"em",h2:"h2",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["The program in on the previous page only had one field, ",(0,n.jsx)(t.code,{children:"text"}),".  It's not very useful with just one field!"]}),"\n",(0,n.jsxs)(t.p,{children:["But it's still ",(0,n.jsx)(t.em,{children:"someone"}),' useful!  If you had a lot more forms, you could make a spellchecker from it.  The client program could go through every word in a document, ask "Is this word in my database?", and if yes, it leaves it alone, and if no it underlines it with a red squiggle.']}),"\n",(0,n.jsx)(t.p,{children:'In "finite-state automata" terms we\'d call a program like this an "acceptor".  It doesn\'t turn something into something else (that would be a ``transducer\'\'), it can only say "yes that\'s one of the words I cover" or "nope not one of mine".'}),"\n",(0,n.jsx)(t.p,{children:'(Side note: You\'ll probably often hear us call fields \'tapes\'.  This is using the metaphors of a Turing Machine, picturing computer programs as reading and writing to long strips of tape.  In the finite-state machine world, we often use this metaphor, speaking of our programs as "reading a symbol from the input tape" or "writing a symbol to the output tape".  An acceptor is a "one-tape automaton", it can only read from one tape; a transducer is a "two-tape automaton" reading from one and writing to another.)'}),"\n",(0,n.jsx)(t.p,{children:"So let's add another field and turn this into a transducer."}),"\n",(0,n.jsx)(t.h2,{id:"from-acceptor-to-transducer",children:"From acceptor to transducer"}),"\n",(0,n.jsxs)(t.p,{children:["Let's take the previous program and add another field, ",(0,n.jsx)(t.code,{children:"gloss"}),'.  (By the way, if you don\'t know this word, "gloss" is what linguists call a labeled breakdown of the parts of a word, like ',(0,n.jsx)(t.code,{children:"1-past-pend"}),".)"]}),"\n",(0,n.jsxs)(t.p,{children:["We have to decide what our gloss is going to look like, so let's say ",(0,n.jsx)(t.code,{children:"jumps"})," comes out as ",(0,n.jsx)(t.code,{children:"jump-3SG.PRES"}),", ",(0,n.jsx)(t.code,{children:"jumped"})," comes out as ",(0,n.jsx)(t.code,{children:"jump-PAST"}),", etc.  (But there's nothing special about these labels.  I chose linguist-y labels, but you could use any labels you want.  Gramble doesn't understand what what ",(0,n.jsx)(t.code,{children:"text"})," or ",(0,n.jsx)(t.code,{children:"gloss"})," or ",(0,n.jsx)(t.code,{children:"jump"})," or ",(0,n.jsx)(t.code,{children:"3SG.PRES"})," mean.)"]}),"\n",(0,n.jsxs)(t.p,{children:["We add the gloss field to each table, associating each piece of ",(0,n.jsx)(t.code,{children:"text"})," with the appropriate piece of ",(0,n.jsx)(t.code,{children:"gloss"}),".  (If you're following along in the interface, this is Example 2 in the Gramble menu.)"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"call"}),(0,n.jsx)(t.td,{children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"jump"}),(0,n.jsx)(t.td,{children:"jump"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Suffix ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"gloss"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"s"}),(0,n.jsx)(t.td,{children:"-3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ed"}),(0,n.jsx)(t.td,{children:"-PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ing"}),(0,n.jsx)(t.td,{children:"-PRES.PROG"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Verb ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"Suffix"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"(There's nothing special about that hyphen either, by the way.  It's a character like any other, and I'm just putting it there to split up the gloss because we decided that was how glosses are going to be split up.)"}),"\n",(0,n.jsxs)(t.p,{children:["Also, there's a shorthand we can use when a table like ",(0,n.jsx)(t.code,{children:"Root"})," has two fields that are exactly the same, we can join them with a forward slash like so:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text/gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"jump"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"That means we don't have to write the same thing twice.  (Writing things twice can be bad because the two version sometimes go out-of-sync with each other.  This makes sure they're always the same.)  After all, not-writing-things-a-bunch-of-times is the whole reason we're writing a program!"}),"\n",(0,n.jsx)(t.h2,{id:"trying-out-a-transduction",children:"Trying out a transduction"}),"\n",(0,n.jsx)(t.p,{children:'Let\'s put that into your sheet.  Then hit "Sync & Validate" in the sidebar, which makes the sidebar interface update to use your latest changes.'}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"<YourSheetName>.Verb"})," should still be selected in the dropdown menu, but if not, select it again.  Now if you sample you'll see there are ",(0,n.jsx)(t.em,{children:"two"})," fields in the results.  Make sure you're generating all six forms, and that the correct gloss is matching up with the correct text!"]}),"\n",(0,n.jsxs)(t.p,{children:["Now let's look at another part of that interface that we haven't used yet.  Below ",(0,n.jsx)(t.code,{children:"<YourSheetName>.Verb"})," but before the buttons, you can see text input areas labeled with ",(0,n.jsx)(t.code,{children:"Verb"}),"'s possible field names.  Anything you type into these restricts the generation/sampling -- or put another way, it lets you make a database query."]}),"\n",(0,n.jsxs)(t.p,{children:["So type ",(0,n.jsx)(t.code,{children:"called"})," into the ",(0,n.jsx)(t.code,{children:"text"})," field.  Now it you sample or generate, the only possible result is ",(0,n.jsx)(t.code,{children:"{text:called, gloss:call-PAST}"}),".  We've done a transduction!"]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>d,a:()=>i});var n=s(7294);const r={},o=n.createContext(r);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);