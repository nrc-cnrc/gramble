"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5290],{4666:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=s(5893),r=s(1151);const i={id:"gs5",title:"From transducer to database",sidebar_label:"From transducer to database"},d=void 0,o={id:"tutorial/gs5",title:"From transducer to database",description:'Let\'s go one further -- not just transducing from an input to an output, but expressing a database with multiple "fields".',source:"@site/docs/tutorial/gs5.md",sourceDirName:"tutorial",slug:"/tutorial/gs5",permalink:"/gramble/docs/tutorial/gs5",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"gs5",title:"From transducer to database",sidebar_label:"From transducer to database"},sidebar:"tutorialSidebar",previous:{title:"Adding more fields",permalink:"/gramble/docs/tutorial/gs4"},next:{title:"Flat vs. nested",permalink:"/gramble/docs/tutorial/gs6"}},a={},l=[{value:"Adding even more tapes",id:"adding-even-more-tapes",level:2},{value:"&quot;Wildcard&quot; queries",id:"wildcard-queries",level:2},{value:"Remember that queries don&#39;t just return single outputs, but a list of outputs",id:"remember-that-queries-dont-just-return-single-outputs-but-a-list-of-outputs",level:2},{value:"But I also want a gloss!",id:"but-i-also-want-a-gloss",level:2}];function h(e){const t={code:"code",em:"em",h2:"h2",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:'Let\'s go one further -- not just transducing from an input to an output, but expressing a database with multiple "fields".'}),"\n",(0,n.jsxs)(t.p,{children:["Why?  Well, look at our previous transducer.  Say we want to know what the past-tense form of ",(0,n.jsx)(t.code,{children:"call"})," is.  In order to query the transducer, we have to assemble a gloss that expresses this, in this case ",(0,n.jsx)(t.code,{children:"call-PAST"})," -- that is, we have to already know how the pieces are going to fit together."]}),"\n",(0,n.jsxs)(t.p,{children:["That's easy enough in English; they're all suffixes and there are only one of them.  But what if you wanted to know the 1st singular subject, 2nd singular object, past tense, applicative form of the verb ",(0,n.jsx)(t.code,{children:"pend"})," in Swahili.  Do you know what order those are supposed to come in?"]}),"\n",(0,n.jsx)(t.p,{children:"In order to make that query, the client program (e.g. the verb conjugator interface) has to know how to put those things in order, and that can actually get rather complicated.  (And it can get much more complicated than Swahili, but in some languages some things come in different orders depending on other factors, like the 3rd person subject might be expressed as a suffix and the 1st and 2nd persons a prefix.  Or in languages that express persons as circumfixes, do you express this in the prefix part, the suffix part, or both?)"}),"\n",(0,n.jsxs)(t.p,{children:["So you end up writing a little sub-program in the client that exists solely to put these things in the correct order... and in doing so recapitulate knowledge that's already in the grammar.  That's a big part of what a grammar ",(0,n.jsx)(t.em,{children:"does"})," is tell you what order things come in.   Information that ",(0,n.jsx)(t.em,{children:"should"})," be in one place, in the grammar, is duplicated, and as we've said before duplication is a recipe for bugs."]}),"\n",(0,n.jsxs)(t.p,{children:["It also happens in the other direction.  Say we want to parse ",(0,n.jsx)(t.code,{children:"nilipenda"})," and learn things like its tense and person.  But in a transducer, your output is a string -- it's ",(0,n.jsx)(t.code,{children:"1-PAST-pend"})," -- and so you have to parse it, and your parser has to know where the different parts are.  Again, it's knowledge that ",(0,n.jsx)(t.em,{children:"should"})," be expressed in the grammar, but you have to duplicate it in the client program just to be able to work with the grammar."]}),"\n",(0,n.jsxs)(t.p,{children:["Now, you might say, \"This isn't a huge deal in my situation\", and that's totally fine.  You can still make a ",(0,n.jsx)(t.code,{children:"nilipenda <-> 1-PAST-pend"})," transducer just like before and it's fine.  All I'm saying is that Gramble doesn't ",(0,n.jsx)(t.em,{children:"require"})," you to express everything as a ",(0,n.jsx)(t.code,{children:"input <-> output"})," transduction like that, we can be more flexible."]}),"\n",(0,n.jsx)(t.h2,{id:"adding-even-more-tapes",children:"Adding even more tapes"}),"\n",(0,n.jsxs)(t.p,{children:["In the previous chapter, we added a new field to each tape, and it was the same field each time.  But if we wanted, we could make them different, we could have separate ",(0,n.jsx)(t.code,{children:"root"})," and ",(0,n.jsx)(t.code,{children:"tense"})," fields instead."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"root"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"call"}),(0,n.jsx)(t.td,{children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"jump"}),(0,n.jsx)(t.td,{children:"jump"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Suffix ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"tense"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"s"}),(0,n.jsx)(t.td,{children:"3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ed"}),(0,n.jsx)(t.td,{children:"PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ing"}),(0,n.jsx)(t.td,{children:"PRES.PROG"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Verb ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"Suffix"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["(I've gone back to putting ",(0,n.jsx)(t.code,{children:"text"})," and ",(0,n.jsx)(t.code,{children:"root"})," in separate columns just for illustrative clarity, but you're still welcome to do one column with a ",(0,n.jsx)(t.code,{children:"text/root"})," header.)"]}),"\n",(0,n.jsxs)(t.p,{children:["This is now a three-field database, and you can look things up in any direction.  Try it out in the interface (Gramble -> Tutorial sheets -> Tutorial 3).  You could put ",(0,n.jsx)(t.code,{children:"called"})," in the ",(0,n.jsx)(t.code,{children:"text"})," field and you'll get back all the other fields, or you could put ",(0,n.jsx)(t.code,{children:"call"})," in the ",(0,n.jsx)(t.code,{children:"root"})," field and ",(0,n.jsx)(t.code,{children:"PAST"})," in the ",(0,n.jsx)(t.code,{children:"text"})," field, or any direction you want."]}),"\n",(0,n.jsx)(t.p,{children:"If this is confusing you, just remember that this program is equivalent to the following database:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"root"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"tense"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"calls"}),(0,n.jsx)(t.td,{children:"call"}),(0,n.jsx)(t.td,{children:"3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"called"}),(0,n.jsx)(t.td,{children:"call"}),(0,n.jsx)(t.td,{children:"PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"calling"}),(0,n.jsx)(t.td,{children:"call"}),(0,n.jsx)(t.td,{children:"PRES.PROG"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"jumps"}),(0,n.jsx)(t.td,{children:"jump"}),(0,n.jsx)(t.td,{children:"3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"jumped"}),(0,n.jsx)(t.td,{children:"jump"}),(0,n.jsx)(t.td,{children:"PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"jumping"}),(0,n.jsx)(t.td,{children:"jump"}),(0,n.jsx)(t.td,{children:"PRES.PROG"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:'Your input can consist of material on any of these fields, and the output will just be "any entry whose fields match every field in the input".'}),"\n",(0,n.jsx)(t.h2,{id:"wildcard-queries",children:'"Wildcard" queries'}),"\n",(0,n.jsxs)(t.p,{children:["That also means you can do queries that ",(0,n.jsx)(t.em,{children:"don't"})," uniquely identify any single form.  You can just give a query with ",(0,n.jsx)(t.code,{children:"jump"})," on ",(0,n.jsx)(t.code,{children:"root"})," and it'll return all three forms with ",(0,n.jsx)(t.code,{children:"jump"}),".  (This could be useful in, for example, a dictionary app that wants to show the user all the possible conjugations of a verb root.)  You could give a completely empty query, and it would return all six forms."]}),"\n",(0,n.jsxs)(t.p,{children:["These are actually quite difficult to do in two-tape transducer languages like XFST.  If you're familiar with that language, imagine putting in a gloss like ",(0,n.jsx)(t.code,{children:"jump-*"}),'.  It wouldn\'t return any outputs, because the input has to be a "sentence" of the gloss language, and ',(0,n.jsx)(t.code,{children:"*"})," simply isn't a part of that language.  In order to generate the whole paradigm, the client program has to generate every possible gloss and then query the system once for each of them.  In order to do that, it needs to know things like what morphemes are possible and what co-occurence restrictions there are -- again, duplicating knowledge that should ideally only be in the grammar."]}),"\n",(0,n.jsx)(t.h2,{id:"remember-that-queries-dont-just-return-single-outputs-but-a-list-of-outputs",children:"Remember that queries don't just return single outputs, but a list of outputs"}),"\n",(0,n.jsx)(t.p,{children:"It's common for people to expect that every input should have one output.  That's what we're used to in regex substitutions in Python, or in \"sequence to sequence\" neural models.  But that's not true of Gramble, or of related languages like XFST or SQL: in these languages, queries can have multiple results, or no results."}),"\n",(0,n.jsxs)(t.p,{children:['And it\'s not just "wildcard" queries like the above; we need multiple results to handle ambiguous inputs.  For example, imagine a grammar that has both English nouns and verbs, and the client program asks for an analysis of ',(0,n.jsx)(t.code,{children:"calls"}),'.  This could be the plural noun -- "I received a lot of calls" -- or the 3rd singular present form of the verb -- "She calls the office every day."  Because both of these are possible analyses of the text, this grammar would return both entries.']}),"\n",(0,n.jsx)(t.h2,{id:"but-i-also-want-a-gloss",children:"But I also want a gloss!"}),"\n",(0,n.jsxs)(t.p,{children:["You can do that; you can have as many fields as you want.  You can put ",(0,n.jsx)(t.code,{children:"root/gloss"})," and ",(0,n.jsx)(t.code,{children:"tense/gloss"})," and that material will be added to ",(0,n.jsx)(t.em,{children:"both"})," fields."]}),"\n",(0,n.jsxs)(t.p,{children:["The only little snag is that we have to decide what to do about hyphenization.  (E.g., when we were constructing a gloss we used ",(0,n.jsx)(t.code,{children:"-PAST"}),", because we wanted to separate it from what came before, whereas when we were just putting it in the tense field we used ",(0,n.jsx)(t.code,{children:"PAST"}),", because it would be really annoying to have to remember to prefix PAST with a hyphen when querying tense.)"]}),"\n",(0,n.jsxs)(t.p,{children:["One thing you could do is just have these be separate fields; another thing you could do is just put the hyphen in a ",(0,n.jsx)(t.code,{children:"gloss"})," field of its own like so:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Suffix ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"gloss"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"tense/gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"s"}),(0,n.jsx)(t.td,{children:"-"}),(0,n.jsx)(t.td,{children:"3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ed"}),(0,n.jsx)(t.td,{children:"-"}),(0,n.jsx)(t.td,{children:"PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ing"}),(0,n.jsx)(t.td,{children:"-"}),(0,n.jsx)(t.td,{children:"PRES.PROG"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Neither of those is my preference, though; I think it gets a little hard to maintain.  My preference is to do all such morphemes as ",(0,n.jsx)(t.code,{children:"[PAST]"}),".  There's nothing special about the brackets, they're just normal characters just like the hyphens, but they serve to separate the morpheme from the surrounding ones, while also not feeling weird to type into queries the way ",(0,n.jsx)(t.code,{children:"-PAST"})," does."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Suffix ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"tense"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"s"}),(0,n.jsx)(t.td,{children:"[3SG.PRES]"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ed"}),(0,n.jsx)(t.td,{children:"[PAST]"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ing"}),(0,n.jsx)(t.td,{children:"[PRES.PROG]"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"If you'd like to see a full example to play around with, there's one in Gramble -> Tutorial sheets -> Tutorial 4."})]})}function c(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>d});var n=s(7294);const r={},i=n.createContext(r);function d(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);