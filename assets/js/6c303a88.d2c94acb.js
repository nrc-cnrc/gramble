"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3843],{928:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var r=n(4848),s=n(8453);const t={id:"regex",title:"Regular Expressions",sidebar_label:"Regular Expressions"},i=void 0,o={id:"reference/regex",title:"Regular Expressions",description:"Gramble's regular expression operators",source:"@site/docs/reference/regex.md",sourceDirName:"reference",slug:"/reference/regex",permalink:"/gramble/docs/reference/regex",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"regex",title:"Regular Expressions",sidebar_label:"Regular Expressions"},sidebar:"docSidebar",previous:{title:"Characters",permalink:"/gramble/docs/reference/characters"},next:{title:"Gramble for Programmers",permalink:"/gramble/docs/category/gramble-for-programmers"}},l={},c=[{value:"Gramble&#39;s regular expression operators",id:"grambles-regular-expression-operators",level:2},{value:"Basic vs. extended regular expressions",id:"basic-vs-extended-regular-expressions",level:2},{value:"Notes about negation",id:"notes-about-negation",level:2},{value:"What is the negation of a grammar?",id:"what-is-the-negation-of-a-grammar",level:3},{value:"What is the alphabet of a negation?",id:"what-is-the-alphabet-of-a-negation",level:3},{value:"Single-character negation",id:"single-character-negation",level:3}];function h(e){const a={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"grambles-regular-expression-operators",children:"Gramble's regular expression operators"}),"\n",(0,r.jsxs)(a.p,{children:["Some header operators -- ",(0,r.jsx)(a.code,{children:"equals"}),", ",(0,r.jsx)(a.code,{children:"starts"}),", ",(0,r.jsx)(a.code,{children:"ends"}),", ",(0,r.jsx)(a.code,{children:"contains"}),", ",(0,r.jsx)(a.code,{children:"from"}),", and ",(0,r.jsx)(a.code,{children:"context"})," -- cause the cells below them to be interpreted as regular expressions."]}),"\n",(0,r.jsx)(a.p,{children:"Gramble supports the following regex operations:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:["Match any single character ",(0,r.jsx)(a.code,{children:"."})]}),"\n",(0,r.jsxs)(a.li,{children:["Match zero or more characters ",(0,r.jsx)(a.code,{children:"*"})]}),"\n",(0,r.jsxs)(a.li,{children:["Match one or more characters ",(0,r.jsx)(a.code,{children:"+"})]}),"\n",(0,r.jsxs)(a.li,{children:["Match zero or one character ",(0,r.jsx)(a.code,{children:"?"})]}),"\n",(0,r.jsxs)(a.li,{children:["Negation ",(0,r.jsx)(a.code,{children:"~"})]}),"\n",(0,r.jsxs)(a.li,{children:["Single-character negation ",(0,r.jsx)(a.code,{children:"!"})]}),"\n",(0,r.jsxs)(a.li,{children:["Alternation ",(0,r.jsx)(a.code,{children:"|"})]}),"\n",(0,r.jsxs)(a.li,{children:["Intersection ",(0,r.jsx)(a.code,{children:"&"})]}),"\n",(0,r.jsxs)(a.li,{children:["Parentheses ",(0,r.jsx)(a.code,{children:"("}),", ",(0,r.jsx)(a.code,{children:")"})]}),"\n"]}),"\n",(0,r.jsxs)(a.p,{children:["Gramble also allows embedding an existing symbol via the syntax ",(0,r.jsx)(a.code,{children:"{X}"}),".  For example, rather than type ",(0,r.jsx)(a.code,{children:"a|e|i|o|u"})," all the time, you could define a symbol ",(0,r.jsx)(a.code,{children:"Vowels"})," with this denotation and then embed it as ",(0,r.jsx)(a.code,{children:"{Vowels}"}),'.  However, this only works with symbols containing only a single field -- these are only single-"tape" regular expressions, and it would not make sense to embed a multi-field grammar in them.']}),"\n",(0,r.jsx)(a.h2,{id:"basic-vs-extended-regular-expressions",children:"Basic vs. extended regular expressions"}),"\n",(0,r.jsxs)(a.p,{children:['Many programming languages allow "regular expressions" with additional operators such as lookahead.  These are more properly termed ',(0,r.jsx)(a.em,{children:"extended"})," regular expressions (EREs); the languages they denote are not regular in Kleene's sense.  Gramble does not yet support these."]}),"\n",(0,r.jsx)(a.h2,{id:"notes-about-negation",children:"Notes about negation"}),"\n",(0,r.jsx)(a.h3,{id:"what-is-the-negation-of-a-grammar",children:"What is the negation of a grammar?"}),"\n",(0,r.jsxs)(a.p,{children:["The negation of grammars can be counter-intuitive.  Remember that a grammar denotes some language (in the formal sense, so just a set of strings), and the negation of a language is\r\nits complement -- the set of strings ",(0,r.jsx)(a.em,{children:"not"})," in that language.  So the complement of ",(0,r.jsx)(a.code,{children:"{a}"})," isn't just ",(0,r.jsx)(a.code,{children:"{b,c,d,...}"})," etc., it also contains ",(0,r.jsx)(a.code,{children:"aa"}),", ",(0,r.jsx)(a.code,{children:"aaaaaaa"}),", the empty string, etc."]}),"\n",(0,r.jsxs)(a.p,{children:["It's important to remember that the empty string can be part of a negated language.  For example, you may want to write a regular expression that means \"doesn't start with 'a'\", and your first attempt is ",(0,r.jsx)(a.code,{children:"~a.*"}),'  But upon running this, this regex lets through words like "apple".  Why?  Well, it\'s because ',(0,r.jsx)(a.code,{children:"~a"})," includes the empty string, meaning that this will end up matching ",(0,r.jsx)(a.code,{children:".*"})," -- any string at all!  The appropriate regex was ",(0,r.jsx)(a.code,{children:"~(a.*)"})," where the negation scopes over the whole thing: \"the complement of the set of strings that start with 'a'\" rather than \"the set of strings that starts with the complement of 'a'.\""]}),"\n",(0,r.jsxs)(a.p,{children:["(Because this is such a common need in grammars, the ",(0,r.jsx)(a.code,{children:"starts"}),", ",(0,r.jsx)(a.code,{children:"ends"}),", and ",(0,r.jsx)(a.code,{children:"contains"})," headers actually do this switch for you.  If you put ",(0,r.jsx)(a.code,{children:"~a"})," under a ",(0,r.jsx)(a.code,{children:"starts"})," header, it creates the regex ",(0,r.jsx)(a.code,{children:"~(a.*)"})," for you; it doesn't just naively construct ",(0,r.jsx)(a.code,{children:"~a.*"}),".)"]}),"\n",(0,r.jsx)(a.h3,{id:"what-is-the-alphabet-of-a-negation",children:"What is the alphabet of a negation?"}),"\n",(0,r.jsxs)(a.p,{children:["The alphabet of a negated grammar is the same as that grammar -- that is, if the alphabet of the field in question is ",(0,r.jsx)(a.code,{children:"{a,b,c}"}),", then only these characters will occur in its negation.  For example, if we have a grammar ",(0,r.jsx)(a.code,{children:"ab|aba|cb"}),", which has an alphabet containing only ",(0,r.jsx)(a.code,{children:"{a,b,c}"}),", then its negation will contain strings like ",(0,r.jsx)(a.code,{children:"aaaa"})," and ",(0,r.jsx)(a.code,{children:"b"})," and ",(0,r.jsx)(a.code,{children:"abcabc"}),", but won't contain ",(0,r.jsx)(a.code,{children:"d"})," or ",(0,r.jsx)(a.code,{children:"xyz"}),"."]}),"\n",(0,r.jsx)(a.h3,{id:"single-character-negation",children:"Single-character negation"}),"\n",(0,r.jsxs)(a.p,{children:["Gramble also does provide an operator where you can negate single characters (e.g., where the negation of ",(0,r.jsx)(a.code,{children:"a"})," really does result in ",(0,r.jsx)(a.code,{children:"{b,c,d,...}"}),"); it's ",(0,r.jsx)(a.code,{children:"!a"}),".  (This is equivalent to ",(0,r.jsx)(a.code,{children:".&~a"})," -- the intersection of a single character and the complement of ",(0,r.jsx)(a.code,{children:"a"}),".)"]}),"\n",(0,r.jsxs)(a.p,{children:["The syntax is the same as for regular negation -- e.g., you say ",(0,r.jsx)(a.code,{children:"!(a|b|c)"}),", not ",(0,r.jsx)(a.code,{children:"[!abc]"})," or ",(0,r.jsx)(a.code,{children:"[^abc]"}),", like you might be used to from other regular expression languages.   The reason for this more explicit syntax is because, unlike the ASCII characters these regex languages were intended for, it's easier to make a mistake about what counts as a single Gramble character.  If were were to say [^p\u02b0a\u02d0t\u0361\u0283], are you the programmer sure that Gramble is dividing that up into single characters the same way you intended?  Gramble's character-tokenization algorithm is deterministic, but we don't want to rely on the programmer having a complete understanding of it just to use single-character negation.  So we chose a syntax with explicit dividers so there are no surprises.  Gramble will warn you if the thing you seperated out as a \"single character\" here actually isn't."]})]})}function d(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>o});var r=n(6540);const s={},t=r.createContext(s);function i(e){const a=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:a},e.children)}}}]);