"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[736],{7878:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>h});var n=s(4848),o=s(8453);const r={id:"multiTier",title:"Why multiple tiers?",sidebar_label:"Multiple tiers"},a=void 0,i={id:"programmers/multiTier",title:"Why multiple tiers?",description:"A lot of the original motivation for Gramble (or, to be precise, the systems that preceded Gramble) is that we needed systems that could express relationships between more than two tiers.",source:"@site/docs/programmers/multiTier.md",sourceDirName:"programmers",slug:"/programmers/multiTier",permalink:"/gramble/docs/programmers/multiTier",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"multiTier",title:"Why multiple tiers?",sidebar_label:"Multiple tiers"},sidebar:"docSidebar",previous:{title:"Gramble for Programmers",permalink:"/gramble/docs/category/gramble-for-programmers"}},l={},h=[{value:"Case study #1",id:"case-study-1",level:2},{value:"Case study #2",id:"case-study-2",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"A lot of the original motivation for Gramble (or, to be precise, the systems that preceded Gramble) is that we needed systems that could express relationships between more than two tiers."}),"\n",(0,n.jsx)(t.h2,{id:"case-study-1",children:"Case study #1"}),"\n",(0,n.jsx)(t.p,{children:"For example, we were once writing a pre-processing system for the Uyghur language (for the system described in Littell et al. 2017), but other teams of people wanted to use the output, and each team wanted a different kind of output representation."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The machine translation team just wanted the root of each word (so that a word like ",(0,n.jsx)(t.code,{children:"kishilerning"})," would come out as ",(0,n.jsx)(t.code,{children:"kishi"}),".  (They also sometimes wanted all the word parts, like ",(0,n.jsx)(t.code,{children:"kishi"}),", ",(0,n.jsx)(t.code,{children:"ler"}),", and ",(0,n.jsx)(t.code,{children:"ning"}),".)"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The event detection team (who wanted to know things like whether the event was currently happening or in the past) wanted all the component parts with labels, like ",(0,n.jsx)(t.code,{children:"people"}),", ",(0,n.jsx)(t.code,{children:"PLURAL"}),", ",(0,n.jsx)(t.code,{children:"GENITIVE"}),".  That way they could just look for things like ",(0,n.jsx)(t.code,{children:"PAST"})," without having to know exactly how the past tense looks in this language."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["A team of humans, overseeing the whole process and wanting to make sure that all system outputs were basically reasonable, wanted a rough, human-readable English rendering like ",(0,n.jsx)(t.code,{children:"of multiple people"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["This caused a dilemma, because a conventional finite state transducer (FST) system only allows for the specification of two levels of representation.  One of these has to be the actual text form (like ",(0,n.jsx)(t.code,{children:"kishilerning"}),"), but what should the second form be?"]}),"\n",(0,n.jsxs)(t.p,{children:["We could have built four systems, one for each output.  Or we could build a chain of three systems: one system that turns ",(0,n.jsx)(t.code,{children:"kishilerning"})," into ",(0,n.jsx)(t.code,{children:"kishi, ler, ning"}),", one that turns that into ",(0,n.jsx)(t.code,{children:"people, PLURAL, GENITIVE"}),", and one that turns that into ",(0,n.jsx)(t.code,{children:"of multiple people"}),".  But that would involve a lot of duplication of knowledge: what parts mean what, how they can be ordered with respect to each other, etc., and this was a system that was ",(0,n.jsx)(t.em,{children:"very rapidly"})," evolving in a chaotic work environment.  (We only had about 36 hours to develop the first iteration of this system!)  There was basically no way to engineer four systems at once and keep them in sync."]}),"\n",(0,n.jsx)(t.p,{children:"So instead, we wrote a system from scratch (that is, without any pre-existing parser library) that could generate multiple different kinds of outputs at once."}),"\n",(0,n.jsx)(t.h2,{id:"case-study-2",children:"Case study #2"}),"\n",(0,n.jsx)(t.p,{children:"Going in the other direction, let's consider a verb conjugator app, like the one described in Kazantseva et al. 2018.  The user has to choose several pieces of information: what verb they want to conjugate, its tense/mood (e.g., past, habitual, etc.), and who the subject and object are (e.g., first person subject, second person object)."}),"\n",(0,n.jsx)(t.p,{children:"Underneath the app, there's an FST that converts a gloss (for example, go-2OBJ-PAST-3SUB) into a real word in the target language.  However, there's one slight snag, in that the FST expects that gloss to be in a specific order, but the user of the app has input several unordered pieces of information.  This means that the app has to know how to order them in the way that the FST expects, or else the FST simply won't have any output."}),"\n",(0,n.jsxs)(t.p,{children:["The order that the FST expects these elements isn't something that we can usually specify to be universal across all languages; it depends on the language and how the FST's author decided to order the elements in their code.  (Often that's the order in which they occur in the target language, but not always.)  So in practice, the user interface has to know, ",(0,n.jsx)(t.em,{children:"for a particular language model"}),", what order the morphemes should come in.  That's usually fairly straightforward, but not necessarily: there are languages where, for example, 3rd singular subjects are expressed as suffixes while 1st and 2nd subjects are expressed as prefixes, or languages where particular combinations of subject and object combine into one unit."]}),"\n",(0,n.jsxs)(t.p,{children:["You can probably see the issue: to order the input units, the user interface has to have some kind of language-specific ordering model that's potentially almost as complex as the FST itself.  But ideally, we shouldn't have to model the language ",(0,n.jsx)(t.em,{children:"twice"}),"... that information about morpheme ordering is already in the FST!  It's just that the FST software itself expects just one input representation and one output representation."]}),"\n",(0,n.jsxs)(t.p,{children:["What we really need here is a system that allows ",(0,n.jsx)(t.em,{children:"multiple"})," input representations, un-ordered with respect to each other.  For example, we input ",(0,n.jsx)(t.code,{children:"go"})," on the root tier, ",(0,n.jsx)(t.code,{children:"2"})," on the object tier, ",(0,n.jsx)(t.code,{children:"PAST"})," on the tense tier, and ",(0,n.jsx)(t.code,{children:"3"})," on the subject tier.  We don't specify the relative order that these will actually occur in; we don't have to know in advance.  We just ask the system, \"Give me the possible words where these elements occur on the appropriate tiers, whatever order they happen to come in.\""]}),"\n",(0,n.jsxs)(t.p,{children:["In conclusion, a lot of linguistic modeling tasks are inherently between multiple levels of representation.  When this is the case, but we can only choose two levels of representation to build into the FST, we often end up in a situation where aspects of the target language have to be modeled ",(0,n.jsx)(t.em,{children:"outside"})," of the FST, whereas ideally everything about the language should be modeled in a single place."]}),"\n",(0,n.jsxs)(t.p,{children:["In Gramble, the multiple tiers are implemented using ",(0,n.jsx)(t.em,{children:"typed transducer combinators"}),"."]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>i});var n=s(6540);const o={},r=n.createContext(o);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);