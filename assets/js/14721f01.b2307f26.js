"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4059],{2219:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=r(5893),n=r(1151);const i={id:"starts",title:"starts",sidebar_label:"starts"},a="starts",o={id:"reference/starts",title:"starts",description:"The starts operator lets you filter a grammar so that only forms where the field starting with a particular string/regex are generated.",source:"@site/docs/reference/starts.md",sourceDirName:"reference",slug:"/reference/starts",permalink:"/gramble/docs/reference/starts",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"starts",title:"starts",sidebar_label:"starts"},sidebar:"tutorialSidebar",previous:{title:"rename (>)",permalink:"/gramble/docs/reference/rename"},next:{title:"table",permalink:"/gramble/docs/reference/table"}},d={},l=[{value:"Usage examples",id:"usage-examples",level:2},{value:"Details",id:"details",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"starts",children:"starts"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"starts"})," operator lets you filter a grammar so that only forms where the field starting with a particular string/regex are generated."]}),"\n",(0,s.jsxs)(t.p,{children:["Like ",(0,s.jsx)(t.code,{children:"equals"}),"/",(0,s.jsx)(t.code,{children:"ends"}),"/",(0,s.jsx)(t.code,{children:"contains"}),", ",(0,s.jsx)(t.code,{children:"rename"})," and hide, ",(0,s.jsx)(t.code,{children:"starts"})," applies to the content immediately to its left, but can be chained."]}),"\n",(0,s.jsx)(t.h2,{id:"usage-examples",children:"Usage examples"}),"\n",(0,s.jsxs)(t.p,{children:["For example, we could filter ",(0,s.jsx)(t.strong,{children:"A"}),' only to entries where the text starts with "p", "t", or "k":']}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"B ="})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"embed"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"starts text"})})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"A"}),(0,s.jsx)(t.td,{children:"p|t|k"})]})})]}),"\n",(0,s.jsxs)(t.p,{children:["Like ",(0,s.jsx)(t.code,{children:"equals"}),", content below ",(0,s.jsx)(t.code,{children:"starts"})," is interpreted as a regex."]}),"\n",(0,s.jsxs)(t.p,{children:["For a negative example, the following filters ",(0,s.jsx)(t.strong,{children:"A"})," only to those entries where the text ",(0,s.jsx)(t.em,{children:"doesn't"}),' start with "p", "t", or "k".']}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"B ="})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"embed"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"starts text"})})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"A"}),(0,s.jsx)(t.td,{children:"~(p|t|k)"})]})})]}),"\n",(0,s.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"starts"})," operator is a convenience version of the ",(0,s.jsx)(t.code,{children:"equals"})," operator, that converts the regex given into a more complex one.  For example, in the first example above, it is converted to ",(0,s.jsx)(t.code,{children:"(p|t|k).*"}),".  In the second example, it is converted to ",(0,s.jsx)(t.code,{children:"~((p|t|k).*)"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Note the scope of the negation and the dot-star in the latter example.  The ",(0,s.jsx)(t.code,{children:"starts"})," operator does not simply tack on a dot-star to the programmer's original regex, because this would not give the meaning that the programmer probably expects.  ",(0,s.jsx)(t.code,{children:"~p.*"}),' means "Starts with the complement of p", but that\'s not actually what we want.  The complement of ',(0,s.jsx)(t.code,{children:"p"})," is ",(0,s.jsx)(t.em,{children:"any"})," string that isn't ",(0,s.jsx)(t.code,{children:"p"}),", and this includes strings like ",(0,s.jsx)(t.code,{children:"pp"})," and the empty string.  Every string starts with the empty string, so filtering with ",(0,s.jsx)(t.code,{children:"~p.*"})," wouldn't do anything.  Instead, the appropriate regex is ",(0,s.jsx)(t.code,{children:"~(p.*)"}),' -- "The complement of [strings starting with p]" rather than "Strings starting with [the complement of p]".']}),"\n",(0,s.jsxs)(t.p,{children:["If you put a complex regex under ",(0,s.jsx)(t.code,{children:"starts"}),", it's possible that the result of this transformation does not mean exactly what you expect it to.  In that case, we suggest using the ",(0,s.jsx)(t.code,{children:"equals"})," operator instead and writing the regex filter that you really want, rather than relying on this convenience operator."]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>a});var s=r(7294);const n={},i=s.createContext(n);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);