"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9658],{7415:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>d,metadata:()=>a,toc:()=>h});var n=s(5893),r=s(1151);const d={id:"rename",title:"rename (>)",sidebar_label:"rename (>)"},i="rename (>)",a={id:"reference/rename",title:"rename (>)",description:"The rename operator (which is expressed using >) is a header operator that causes a field inside its scope to have a different name outside its scope.",source:"@site/docs/reference/rename.md",sourceDirName:"reference",slug:"/reference/rename",permalink:"/gramble/docs/reference/rename",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"rename",title:"rename (>)",sidebar_label:"rename (>)"},sidebar:"tutorialSidebar",previous:{title:"Regular Expressions",permalink:"/gramble/docs/reference/regex"},next:{title:"starts",permalink:"/gramble/docs/reference/starts"}},o={},h=[{value:"Usage examples",id:"usage-examples",level:2},{value:"Why would we want to use this?",id:"why-would-we-want-to-use-this",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"rename-",children:"rename (>)"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"rename"})," operator (which is expressed using ",(0,n.jsx)(t.code,{children:">"}),") is a header operator that causes a field inside its scope to have a different name outside its scope."]}),"\n",(0,n.jsxs)(t.p,{children:["Like ",(0,n.jsx)(t.code,{children:"equals"}),"/",(0,n.jsx)(t.code,{children:"starts"}),"/",(0,n.jsx)(t.code,{children:"ends"}),"/",(0,n.jsx)(t.code,{children:"contains"})," and ",(0,n.jsx)(t.code,{children:"hide"}),", ",(0,n.jsx)(t.code,{children:"rename"})," applies to the content immediately to its left, but can be chained."]}),"\n",(0,n.jsx)(t.h2,{id:"usage-examples",children:"Usage examples"}),"\n",(0,n.jsxs)(t.p,{children:["Say, for example, that the ",(0,n.jsx)(t.strong,{children:"A"})," symbol defines the fields ",(0,n.jsx)(t.code,{children:"text"}),", ",(0,n.jsx)(t.code,{children:"gloss"}),", and ",(0,n.jsx)(t.code,{children:"class"}),".  The following code creates a symbol ",(0,n.jsx)(t.strong,{children:"B"})," that has the ",(0,n.jsx)(t.code,{children:"text"})," and ",(0,n.jsx)(t.code,{children:"gloss"})," fields of ",(0,n.jsx)(t.strong,{children:"A"}),", but where the ",(0,n.jsx)(t.code,{children:"class"})," field is now called ",(0,n.jsx)(t.code,{children:"type"}),"."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"B ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:">type"})})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"A"}),(0,n.jsx)(t.td,{children:"class"})]})})]}),"\n",(0,n.jsx)(t.h2,{id:"why-would-we-want-to-use-this",children:"Why would we want to use this?"}),"\n",(0,n.jsxs)(t.p,{children:["Renaming is useful when taking different symbols/modules (especially from different programmers) and making them work together.  For example, we might have two symbols that mean something different by the field ",(0,n.jsx)(t.code,{children:"class"}),", and we don't want them just joined/concatenated as if they mean the same thing.  Renaming at least one of them to something else would make it so you can combine these symbols without worrying about the conflation of their ",(0,n.jsx)(t.code,{children:"class"})," fields.  (You could also, in this instance, ",(0,n.jsx)(t.a,{href:"hide",children:"hide"})," them.  Hiding is really just renaming to a unique secret name.)"]}),"\n",(0,n.jsxs)(t.p,{children:["You might also use this to massage the field names to something required by a client program.  For example, say we have a client program that expects a morpheme breakdown field to be called ",(0,n.jsx)(t.code,{children:"morph"}),", but the programmer called it ",(0,n.jsx)(t.code,{children:"breakdown"}),".  Do we have to go through the entire program to rename ",(0,n.jsx)(t.code,{children:"breakdown"})," to ",(0,n.jsx)(t.code,{children:"morph"}),"?  We don't; we can just rename ",(0,n.jsx)(t.code,{children:"breakdown"})," to ",(0,n.jsx)(t.code,{children:"morph"})," at the very end.  (This is especially useful when we write one grammar that's going to be used with ",(0,n.jsx)(t.em,{children:"multiple"})," client programs that don't agree on what fields need to be named.)"]}),"\n",(0,n.jsxs)(t.p,{children:["Finally, there's a special pattern known as the Skyra Pattern, after a pair of Gramble programmers (Skyler and Kendra) who first used it.  The idea is that you may have unpredictable suppletive text forms that you want to keep in a table, but you don't yet know which is going to be used in the text.  For example, we might have an A and B form of a verb root that occur when different suffixes are added.  We can keep them in the table as different fields, and rename that field to ",(0,n.jsx)(t.code,{children:"text"})," as necessary:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"formA"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"formB"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"gar"}),(0,n.jsx)(t.td,{children:"gr"}),(0,n.jsx)(t.td,{children:"run"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"kapa"}),(0,n.jsx)(t.td,{children:"kap"}),(0,n.jsx)(t.td,{children:"jump"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"sil"}),(0,n.jsx)(t.td,{children:"sl"}),(0,n.jsx)(t.td,{children:"climb"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Stem ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:">text"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"text"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"formA"}),(0,n.jsx)(t.td,{children:"-ti"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"formB"}),(0,n.jsx)(t.td,{children:"-as"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"formB"}),(0,n.jsx)(t.td,{children:"-i"})]})]})]})]})}function c(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>i});var n=s(7294);const r={},d=n.createContext(r);function i(e){const t=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(d.Provider,{value:t},e.children)}}}]);