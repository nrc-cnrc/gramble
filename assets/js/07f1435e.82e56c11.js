"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1446],{6490:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=s(4848),r=s(8453);const l={id:"gs4",title:"Adding more fields",sidebar_label:"Adding more fields"},i=void 0,o={id:"tutorial/gs4",title:"Adding more fields",description:"Acceptor",source:"@site/docs/tutorial/gs4.md",sourceDirName:"tutorial",slug:"/tutorial/gs4",permalink:"/gramble/docs/tutorial/gs4",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"gs4",title:"Adding more fields",sidebar_label:"Adding more fields"},sidebar:"docSidebar",previous:{title:"A simple Gramble program",permalink:"/gramble/docs/tutorial/gs3"},next:{title:"From transducer to database",permalink:"/gramble/docs/tutorial/gs5"}},d={},c=[{value:"Acceptor",id:"acceptor",level:2},{value:"From acceptor to transducer",id:"from-acceptor-to-transducer",level:2},{value:"Trying out a transduction",id:"trying-out-a-transduction",level:2}];function a(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"acceptor",children:"Acceptor"}),"\n",(0,n.jsxs)(t.p,{children:["The program on the ",(0,n.jsx)(t.a,{href:"/gramble/docs/tutorial/gs3",children:"previous page"})," only had one field, ",(0,n.jsx)(t.code,{children:"text"}),".  It's not very useful with just one field!"]}),"\n",(0,n.jsxs)(t.p,{children:["But it's still ",(0,n.jsx)(t.em,{children:"somewhat"}),' useful!  If you had a lot more forms, you could make a spellchecker from it.  The client program could go through every word in a document and ask, "Is this word in my database?", and if yes, it leaves it alone, and if no it underlines it with a red squiggle.']}),"\n",(0,n.jsx)(t.p,{children:'In "finite-state automata" terms we\'d call a program like this an "acceptor".  It doesn\'t turn something into something else (that would be a "transducer"); it can only say, "Yes, that\'s one of the words I cover," or "Nope, not one of mine."'}),"\n",(0,n.jsx)(t.p,{children:'(Side note: You\'ll probably often hear us call fields "tapes".  This is using the metaphor of a Turing Machine, picturing computer programs as reading and writing to long strips of tape.  In the finite-state machine world, we often use this metaphor, speaking of our programs as "reading a symbol from the input tape" or "writing a symbol to the output tape".  An acceptor is a "one-tape automaton", it can only read from one tape; a transducer is a "two-tape automaton" reading from one tape and writing to another.)'}),"\n",(0,n.jsx)(t.p,{children:"So let's add another field and turn this into a transducer."}),"\n",(0,n.jsx)(t.h2,{id:"from-acceptor-to-transducer",children:"From acceptor to transducer"}),"\n",(0,n.jsxs)(t.p,{children:["Let's take the previous program and add another field, ",(0,n.jsx)(t.code,{children:"gloss"}),'.  (By the way, if you don\'t know this word, "gloss" is what linguists call a labeled breakdown of the parts of a word, like ',(0,n.jsx)(t.code,{children:"1-past-pend"}),".)"]}),"\n",(0,n.jsxs)(t.p,{children:["We have to decide what our gloss is going to look like, so let's say ",(0,n.jsx)(t.code,{children:"jumps"})," comes out as ",(0,n.jsx)(t.code,{children:"jump-3SG.PRES"}),", ",(0,n.jsx)(t.code,{children:"jumped"})," comes out as ",(0,n.jsx)(t.code,{children:"jump-PAST"}),", etc.  (But there's nothing special about these labels.  I chose linguist-y labels, but you could use any labels you want.  Gramble doesn't understand what ",(0,n.jsx)(t.code,{children:"text"})," or ",(0,n.jsx)(t.code,{children:"gloss"})," or ",(0,n.jsx)(t.code,{children:"jump"})," or ",(0,n.jsx)(t.code,{children:"3SG.PRES"})," mean.)"]}),"\n",(0,n.jsxs)(t.p,{children:["(If you're following along in the interface, this is the second example, ",(0,n.jsx)(t.code,{children:"2:\xa0text<->gloss"}),", in the ",(0,n.jsx)(t.code,{children:"Gramble"}),"->",(0,n.jsx)(t.code,{children:"Tutorial\xa0sheets"})," menu.)"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"call"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"jump"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"jump"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\xa0"}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"}})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"Suffix =\xa0"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"gloss"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"s"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"-3SG.PRES"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"ed"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"-PAST"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"ing"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"-PRES.PROG"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\xa0"}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"}})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"Verb ="})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"embed"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"Root"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"Suffix"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["We added the ",(0,n.jsx)(t.code,{children:"gloss"})," field to each of the ",(0,n.jsx)(t.code,{children:"Root"})," and ",(0,n.jsx)(t.code,{children:"Suffix"})," tables above, associating each piece of ",(0,n.jsx)(t.code,{children:"text"})," with the appropriate piece of ",(0,n.jsx)(t.code,{children:"gloss"}),". So, for example, in the ",(0,n.jsx)(t.code,{children:"Root"})," table, ",(0,n.jsx)(t.code,{children:"call"})," in the ",(0,n.jsx)(t.code,{children:"text"})," field is associated with ",(0,n.jsx)(t.code,{children:"call"})," in the ",(0,n.jsx)(t.code,{children:"gloss"})," field (",(0,n.jsx)(t.code,{children:"{text:call, gloss:call}"}),"), and in the ",(0,n.jsx)(t.code,{children:"Suffix"})," table, ",(0,n.jsx)(t.code,{children:"ing"})," in the text field is associated with ",(0,n.jsx)(t.code,{children:"-PRES.PROG"})," in the ",(0,n.jsx)(t.code,{children:"gloss"})," field (",(0,n.jsx)(t.code,{children:"{text:ing, gloss:-PRES.PROG}"}),"); the ",(0,n.jsx)(t.code,{children:"Verb"})," table contentenates entries from the ",(0,n.jsx)(t.code,{children:"Root"})," and ",(0,n.jsx)(t.code,{children:"Suffix"})," tables, so one of its results would be ",(0,n.jsx)(t.code,{children:"calling"})," in the ",(0,n.jsx)(t.code,{children:"text"})," field, and ",(0,n.jsx)(t.code,{children:"call-PRES.PROG"})," in the ",(0,n.jsx)(t.code,{children:"gloss"})," field (",(0,n.jsx)(t.code,{children:"{text:calling, gloss:call-PRES.PROG}"}),")."]}),"\n",(0,n.jsx)(t.p,{children:"(There's nothing special about that hyphen either, by the way.  It's a character like any other, and I'm just putting it there to split up the gloss because we decided that was how glosses are going to be split up.)"}),"\n",(0,n.jsxs)(t.p,{children:["Also, there's a shorthand we can use when a table like ",(0,n.jsx)(t.code,{children:"Root"})," has two fields that are exactly the same, we can join them with a forward slash like so:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root =\xa0"})}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:(0,n.jsx)(t.strong,{children:"text/gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"jump"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"That means we don't have to write the same thing twice.  (Writing things twice can be bad because the two versions can sometimes get out-of-sync with each other.  This makes sure they're always the same.)  After all, not-writing-things-a-bunch-of-times is the whole reason we're writing a program!"}),"\n",(0,n.jsx)(t.h2,{id:"trying-out-a-transduction",children:"Trying out a transduction"}),"\n",(0,n.jsxs)(t.p,{children:["Let's put that into your sheet.  After doing so, remember to first ",(0,n.jsx)(t.strong,{children:"click any cell other than the last cell you edited"}),".  Then click ",(0,n.jsx)(t.code,{children:"Sync & Validate"})," in the sidebar, which makes the sidebar interface update to use your latest changes."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"<YourSheetName>.Verb"})," should still be selected in the dropdown menu, but if not, select it again.  Now if you sample by clicking ",(0,n.jsx)(t.code,{children:"Sample here"}),", you'll see there are ",(0,n.jsx)(t.em,{children:"two"})," fields in the results.  Check that you're generating all six forms, and that the correct gloss is matching up with the correct text!"]}),"\n",(0,n.jsxs)(t.p,{children:["Now let's look at another part of that interface that we haven't used yet.  Below ",(0,n.jsx)(t.code,{children:"<YourSheetName>.Verb"})," but before the buttons, you can see coloured text input areas labeled with the field names of ",(0,n.jsx)(t.code,{children:"Verb"}),": ",(0,n.jsx)(t.code,{children:"gloss"})," and ",(0,n.jsx)(t.code,{children:"text"}),".  Anything you type into these restricts the generation/sampling -- or put another way, it lets you make a database query."]}),"\n",(0,n.jsxs)(t.p,{children:["So type ",(0,n.jsx)(t.code,{children:"called"})," into the coloured input area labelled ",(0,n.jsx)(t.code,{children:"text"}),".  Now if you sample or generate, the only possible result is ",(0,n.jsx)(t.code,{children:"{text:called, gloss:call-PAST}"}),".  We've done a transduction!"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var n=s(6540);const r={},l=n.createContext(r);function i(e){const t=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(l.Provider,{value:t},e.children)}}}]);