"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2890],{721:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var s=t(5893),i=t(1151);const a={id:"gs2",title:"Linguistic programs as databases",sidebar_label:"Linguistic programs as databases"},r=void 0,d={id:"tutorial/gs2",title:"Linguistic programs as databases",description:"A Gramble program is a way of specifying a linguistic database in an efficient manner, without having to list out every possible entry.  This is useful for very complex languages like Swahili or Kanyen'keha (in which there are millions of possible verb forms), or for syntactic phenomena like sentences (where we can't possibly list every possible sentence), or for procedures like Romanization where you want to produce a Roman-alphabet version of any user input, even if it's not a word you've ever seen before.",source:"@site/docs/tutorial/gs2.md",sourceDirName:"tutorial",slug:"/tutorial/gs2",permalink:"/gramble/docs/tutorial/gs2",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"gs2",title:"Linguistic programs as databases",sidebar_label:"Linguistic programs as databases"},sidebar:"tutorialSidebar",previous:{title:"What is Gramble?",permalink:"/gramble/docs/tutorial/gs1"},next:{title:"A simple Gramble program",permalink:"/gramble/docs/tutorial/gs3"}},o={},l=[{value:"What&#39;s a database?",id:"whats-a-database",level:2},{value:"I thought this was basically a finite-state transducer language like XFST, that takes an input string and gives you an output string.  This seems more like a database language like SQL.",id:"i-thought-this-was-basically-a-finite-state-transducer-language-like-xfst-that-takes-an-input-string-and-gives-you-an-output-string--this-seems-more-like-a-database-language-like-sql",level:2},{value:"How do we make one?",id:"how-do-we-make-one",level:2}];function h(e){const n={code:"code",em:"em",h2:"h2",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A Gramble program is a way of specifying a ",(0,s.jsx)(n.em,{children:"linguistic database"})," in an efficient manner, without having to list out every possible entry.  This is useful for very complex languages like Swahili or Kanyen'keha (in which there are millions of possible verb forms), or for syntactic phenomena like sentences (where we can't possibly list every possible sentence), or for procedures like Romanization where you want to produce a Roman-alphabet version of any user input, even if it's not a word you've ever seen before."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"There are lots of programming languages in which we could specify this, from special-purpose languages like XFST to general-purpose programming languages like Python."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"We think that Gramble is the easiest and fastest way to do it, though; that's why we made it.  (Fastest in terms of development time, at least, and amount of time learning the programming language.  The actual database queries might be faster or slower, depending on a lot of factors.)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"whats-a-database",children:"What's a database?"}),"\n",(0,s.jsx)(n.p,{children:'In the abstract sense, a database is an organized collection of entries, stored on a computer, that you can access ("query") in various ways.'}),"\n",(0,s.jsxs)(n.p,{children:["For example, imagine the following ",(0,s.jsx)(n.em,{children:"very"}),' simple and incomplete database of Swahili verb conjugations, along with the tense (past, present), person (first, second, or third), and verb root that they express.  ("Penda" means "love", if you\'re wondering, and "on" means "see".  "Ninapenda" means "I love him/her/it".)']}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"verb"}),(0,s.jsx)(n.th,{children:"person"}),(0,s.jsx)(n.th,{children:"tense"}),(0,s.jsx)(n.th,{children:"root"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ninapenda"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"unapenda"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"anapenda"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nilipenda"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ulipenda"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"alipenda"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nimependa"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"umependa"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"amependa"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ninaona"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"unaona"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"anaona"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"present"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"niliona"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uliona"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"aliona"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nimeona"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"umeona"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ameona"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"perfect"}),(0,s.jsx)(n.td,{children:"on"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["With a database like this, if you know the verb ",(0,s.jsx)(n.em,{children:"nilipenda"})," exists and want to know its details, you could make a query like ",(0,s.jsx)(n.code,{children:"verb: nilipenda"}),".  What you'd receive in response is a list of entries that are compatible with it; in this database, one entry is compatible with it:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"verb"}),(0,s.jsx)(n.th,{children:"person"}),(0,s.jsx)(n.th,{children:"tense"}),(0,s.jsx)(n.th,{children:"root"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nilipenda"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Or say you ",(0,s.jsx)(n.em,{children:"didn't"})," know that word, but you want to know the 1st person past form of the root ",(0,s.jsx)(n.em,{children:"pend"}),".  You can make a more complex query consisting of ",(0,s.jsx)(n.code,{children:"person: 1"}),", ",(0,s.jsx)(n.code,{children:"tense: past"}),", and ",(0,s.jsx)(n.code,{children:"root: pend"}),".  What you'd receive in response is a list of entries that are compatible with that -- in this case, the same entry as above."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"verb"}),(0,s.jsx)(n.th,{children:"person"}),(0,s.jsx)(n.th,{children:"tense"}),(0,s.jsx)(n.th,{children:"root"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nilipenda"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["So you could use a database like this to ",(0,s.jsx)(n.em,{children:"parse"})," a known word into meaningful components, or also ",(0,s.jsx)(n.em,{children:"generate"})," an unknown word from its meaningful components.  You can also make queries that give you multiple results, like asking for all the past-tense forms by just asking ",(0,s.jsx)(n.code,{children:"tense: past"}),", and receiving:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"verb"}),(0,s.jsx)(n.th,{children:"person"}),(0,s.jsx)(n.th,{children:"tense"}),(0,s.jsx)(n.th,{children:"root"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"nilipenda"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ulipenda"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"alipenda"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"pend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"niliona"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uliona"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"aliona"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"past"}),(0,s.jsx)(n.td,{children:"on"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"i-thought-this-was-basically-a-finite-state-transducer-language-like-xfst-that-takes-an-input-string-and-gives-you-an-output-string--this-seems-more-like-a-database-language-like-sql",children:"I thought this was basically a finite-state transducer language like XFST, that takes an input string and gives you an output string.  This seems more like a database language like SQL."}),"\n",(0,s.jsx)(n.p,{children:"(If you don't understand this question, that's okay, move on to the next question.  This is just to address a common question we get.)"}),"\n",(0,s.jsx)(n.p,{children:"Yes, you can kind of think of Gramble as the baby of XFST and SQL."}),"\n",(0,s.jsx)(n.p,{children:"But stepping back a little further, you can think of any transducer as a (potentially infinite) database, just a database with only two fields.  In FST-land we often refer to the input as 'up' and 'down', so I'll use that convention here."}),"\n",(0,s.jsxs)(n.p,{children:["Say you made an FST from a gloss like ",(0,s.jsx)(n.code,{children:"1-past-pend"})," to a word like ",(0,s.jsx)(n.code,{children:"nilipenda"}),".  When making an FST we often think of that as a process, but you could also think of that as a giant database, like:"]}),"\n",(0,s.jsx)(n.p,{children:"| up | down |\n|-----------|\n| 1-past-pend | nilipenda |\n| 2-past-pend | ulipenda |\n| 3-past-pend | alipenda |\n| etc... |"}),"\n",(0,s.jsxs)(n.p,{children:['And then instead of saying "I put in ',(0,s.jsx)(n.code,{children:"1-past-pend"})," and got ",(0,s.jsx)(n.code,{children:"nilipenda"}),'", in database terms we might say "I made a query to select all rows where ',(0,s.jsx)(n.code,{children:"up='1-past-pend"}),", and got one result: ",(0,s.jsx)(n.code,{children:"{up:1-past-pend, down:nilipenda}"}),".\"  Same information in, same information out, we're just thinking about it in a different way."]}),"\n",(0,s.jsx)(n.p,{children:'Why would we want to think more like a database?  Well, it\'s quite frequent that we want to ask for more complex queries, like "Give me everything with the root \'pend\', but only in past or present tense, and only in this dialect".  Or we want more information in the result.  Or, when making the database in the first place, we are trying to program complex linguistic phenomena, where this suffix has a particular form only when the mood is subjunctive and the subject is first-singular.  All of those can get complicated to do when we limit the number of "fields" in our database to two.'}),"\n",(0,s.jsx)(n.p,{children:"So Gramble is like XFST, except it doesn't have the two-field restriction; it lets you do transductions, but isn't limited to things with one input field and one output field.  That sort of \"generalized transduction\" already has a whole rich vocabulary associated with it -- it's a database query! -- and so we often use database language when talking about Gramble programs.  But it's not a fundamentally different thing than a transduction, a transduction is just a special case of a bigger idea."}),"\n",(0,s.jsx)(n.h2,{id:"how-do-we-make-one",children:"How do we make one?"}),"\n",(0,s.jsx)(n.p,{children:"That's all well and good, but in reality there are so many possible Swahili verbs forms (thousands of them for every verb) that writing this database by hand would be effectively impossble.  There aren't just three persons and three tenses, there are more than a dozen persons (for both subjects and objects) and more than a dozen tenses, and thousands of verb roots, as well as a lot of other verb suffixes.  You simply can't specify them all, not by writing out each possible form."}),"\n",(0,s.jsxs)(n.p,{children:["So what you really need to do is write a ",(0,s.jsx)(n.em,{children:"program"}),' that generates Swahili verbs from their component parts ("ni" and "u" and "a" and "li" etc.), while associating the parts with their appropriate labels/meanings, specifying any changes that they undergo during combination, etc.']}),"\n",(0,s.jsx)(n.p,{children:'A lot of linguistic phenomena are like that, not just verb conjugation.  For another example, we might want to convert words between different writing systems (like converting "\u14c4\u14c7\u1557\u1466" from Canadian Aboriginal Syllabics into its Roman form "nunavut"), or words into their pronunciation in the International Phonetic Alphabet.  You can\'t specify every possible Canadian Aboriginal Syllabics word as a list; the user might input a word you\'ve never even heard of.  Rather, you have to write a program for how to do it.'})]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>r});var s=t(7294);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);