"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7995],{5827:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>r,metadata:()=>l,toc:()=>h});var i=s(4848),n=s(8453);const r={id:"hide",title:"hide",sidebar_label:"hide"},d=void 0,l={id:"reference/headerOps/hide",title:"hide",description:"Description",source:"@site/docs/reference/headerOps/hide.md",sourceDirName:"reference/headerOps",slug:"/reference/headerOps/hide",permalink:"/gramble/docs/reference/headerOps/hide",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"hide",title:"hide",sidebar_label:"hide"},sidebar:"docSidebar",previous:{title:"equals",permalink:"/gramble/docs/reference/headerOps/equals"},next:{title:"optional",permalink:"/gramble/docs/reference/headerOps/optional"}},o={},h=[{value:"Description",id:"description",level:2},{value:"Usage examples",id:"usage-examples",level:2},{value:"Why would you want to use this?",id:"why-would-you-want-to-use-this",level:2},{value:"Details",id:"details",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"hide"})," is a header operator that makes one or more fields invisible outside of its scope."]}),"\n",(0,i.jsxs)(t.p,{children:["Like ",(0,i.jsx)(t.code,{children:"equals"}),"/",(0,i.jsx)(t.code,{children:"starts"}),"/",(0,i.jsx)(t.code,{children:"ends"}),"/",(0,i.jsx)(t.code,{children:"contains"})," and ",(0,i.jsx)(t.code,{children:"rename"}),", ",(0,i.jsx)(t.code,{children:"hide"})," applies to the content immediately to its left, but can be chained."]}),"\n",(0,i.jsx)(t.h2,{id:"usage-examples",children:"Usage examples"}),"\n",(0,i.jsxs)(t.p,{children:["Say, for example, that the ",(0,i.jsx)(t.strong,{children:"A"})," symbol defines the fields ",(0,i.jsx)(t.code,{children:"text"}),", ",(0,i.jsx)(t.code,{children:"gloss"}),", and ",(0,i.jsx)(t.code,{children:"class"}),".  The following code creates a symbol ",(0,i.jsx)(t.strong,{children:"B"})," that has the ",(0,i.jsx)(t.code,{children:"text"})," and ",(0,i.jsx)(t.code,{children:"gloss"})," fields of ",(0,i.jsx)(t.strong,{children:"A"})," but not the ",(0,i.jsx)(t.code,{children:"class"})," field."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"B =\xa0"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"embed"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"hide"})})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"}}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"A"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"class"})]})})]}),"\n",(0,i.jsxs)(t.p,{children:["You can also hide multiple fields using a forward slash (",(0,i.jsx)(t.code,{children:"/"}),")."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"B =\xa0"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"embed"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"hide"})})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"}}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"A"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"gloss/class"})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"why-would-you-want-to-use-this",children:"Why would you want to use this?"}),"\n",(0,i.jsxs)(t.p,{children:['Hiding fields is one of the mechanisms that Gramble uses to provide "encapsulation": the ability for different modules to contain content that is calculated within that module, but which is not visible/accessible outside of it.  We might, for example, have a ',(0,i.jsx)(t.code,{children:"class"})," field in the root, and use that to make decisions about which classes of suffixes to add to it, but this field is irrelevant outside of the verb module.  Hiding ",(0,i.jsx)(t.code,{children:"class"})," outside of the verb module is a way to make sure that this irrelevant information doesn't get misused for some other purpose (e.g., being conflated with some other ",(0,i.jsx)(t.code,{children:"class"})," field elsewhere), or just \"cleans up\" the programmer's view of the verb output so that it doesn't contain dozens of special purpose fields."]}),"\n",(0,i.jsxs)(t.p,{children:["This is also useful when there is some property that can vary as the word is built.  Transitivity is a good example: a verb root might have a field ",(0,i.jsx)(t.code,{children:"transitivity: trans"}),", but when you add a reflexive suffix it needs to become ",(0,i.jsx)(t.code,{children:"transitivity: intrans"}),".  And say we don't want to call these two different fields (e.g., ",(0,i.jsx)(t.code,{children:"rootTransitivity"})," vs ",(0,i.jsx)(t.code,{children:"stemTransitivity"}),"), because you have other operations later that only care about transitivity and don't care how it got there."]}),"\n",(0,i.jsxs)(t.p,{children:["How do we do that?  Fields aren't ",(0,i.jsx)(t.em,{children:"variables"}),", you can't re-assign to them.  Instead, we need to think of that root and the reflexive stem as having two different ",(0,i.jsx)(t.code,{children:"transitivity"}),' fields: one "inside" and describing the root, and one "outside" and describing the whole stem.  In order to not have these two fields be confused, we have to hide the one inside.']}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"Stem =\xa0"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"embed"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"equals transitivity"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"hide"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"text"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"gloss"})}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:(0,i.jsx)(t.strong,{children:"transitivity"})})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"}}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"Root"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"trans"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"transitivity"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"-ba"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"-REFL"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"intrans"})]})})]}),"\n",(0,i.jsxs)(t.p,{children:["Let's step through this one in detail.  First, this suffix only applies to transitive roots, so we're filtering it with an ",(0,i.jsx)(t.code,{children:"equals"}),".  Having done that, we ",(0,i.jsx)(t.code,{children:"hide"})," that field, because we don't want it to interact with the new ",(0,i.jsx)(t.code,{children:"transitivity"})," value we're about to have.  Then we add the ",(0,i.jsx)(t.code,{children:"text"})," and ",(0,i.jsx)(t.code,{children:"gloss"})," of the reflexive morpheme, and finally we add the new ",(0,i.jsx)(t.code,{children:"transitivity"})," value."]}),"\n",(0,i.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,i.jsxs)(t.p,{children:["Within the scope of the ",(0,i.jsx)(t.code,{children:"hide"})," operator, the field still exists and is calculated like normal.  In the reflexive example above, the ",(0,i.jsx)(t.code,{children:"transitivity"})," field still exists on ",(0,i.jsx)(t.code,{children:"Root"}),"; if it didn't, we couldn't filter on it in the next cell."]}),"\n",(0,i.jsxs)(t.p,{children:["Instead, what's really happening is that the ",(0,i.jsx)(t.code,{children:"hide"})," operator is renaming this field to a unique, secret name, that won't clash with any other field names in the program, and won't be shown to the programmer.  (This is called ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Name_mangling",children:"Name Mangling"}),"; you may be familiar with it from Python.)"]})]})}function a(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>d,x:()=>l});var i=s(6540);const n={},r=i.createContext(n);function d(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);