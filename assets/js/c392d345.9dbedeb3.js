"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[746],{2940:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=s(5893),r=s(1151);const i={id:"gs3",title:"A simple Gramble program",sidebar_label:"A simple Gramble program"},d=void 0,o={id:"tutorial/gs3",title:"A simple Gramble program",description:"Enter Gramble",source:"@site/docs/tutorial/gs3.md",sourceDirName:"tutorial",slug:"/tutorial/gs3",permalink:"/gramble/docs/tutorial/gs3",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"gs3",title:"A simple Gramble program",sidebar_label:"A simple Gramble program"},sidebar:"tutorialSidebar",previous:{title:"Linguistic programs as databases",permalink:"/gramble/docs/tutorial/gs2"},next:{title:"Adding more fields",permalink:"/gramble/docs/tutorial/gs4"}},a={},l=[{value:"Enter Gramble",id:"enter-gramble",level:2},{value:"That seems like MORE work?!?",id:"that-seems-like-more-work",level:2},{value:"Let&#39;s back up and make on for English first.",id:"lets-back-up-and-make-on-for-english-first",level:2},{value:"Try it out in the Gramble sheet",id:"try-it-out-in-the-gramble-sheet",level:2}];function h(e){const t={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"enter-gramble",children:"Enter Gramble"}),"\n",(0,n.jsx)(t.p,{children:"In the previous section, we mentioned that many linguistic databases would be so large and complicated that no human could really maintain them.  Some would even be infinite!  So for some kinds of linguistic phenomena, we handle things not by listing out every possible answer, but by"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:"Gramble"})," is a tabular programming language intended to make it easy to write these kinds of programs.  The neat thing about Gramble is that the programs are both readable ",(0,n.jsx)(t.em,{children:"descriptions"})," of the phenomena in question (e.g., they look like fairly ordinary verb conjugation tables or phoneme conversion charts) as well as being the ",(0,n.jsx)(t.em,{children:"code"})," that turns a query into its correct answers."]}),"\n",(0,n.jsx)(t.p,{children:"You interact with a Gramble program just like you would interact with a database, by inputting queries and getting answers in return."}),"\n",(0,n.jsx)(t.p,{children:"For example, the following little Gramble program has the same effect as the Swahili database above:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Subject ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"person"})}),(0,n.jsx)(t.th,{})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ni"}),(0,n.jsx)(t.td,{children:"1"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"u"}),(0,n.jsx)(t.td,{children:"2"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"a"}),(0,n.jsx)(t.td,{children:"3"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Tense ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"tense"})}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"na"}),(0,n.jsx)(t.td,{children:"present"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"li"}),(0,n.jsx)(t.td,{children:"past"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"me"}),(0,n.jsx)(t.td,{children:"perfect"}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"text/root"})}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"pend"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ona"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Verb ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Subject"}),(0,n.jsx)(t.td,{children:"Tense"}),(0,n.jsx)(t.td,{children:"Root"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"that-seems-like-more-work",children:"That seems like MORE work?!?"}),"\n",(0,n.jsx)(t.p,{children:"Yes, maybe, if the database only had 18 forms total.  But these databases tend to grow exponentially."}),"\n",(0,n.jsxs)(t.p,{children:["Right now we only have 2 roots, 3 tenses, and 3 subjects, and 2 x 3 x 3 = 18.  Swahili has a LOT more than those -- it has about a dozen tenses, many more subject person markers AND object markers, negation, voices, etc.  Every time you add a new category the size of the database tends to double (or more).  Kawenn\xf3n",":nis",", the verb conjugator for the Kanyen'keha (Mohawk) language, quickly grew from a few hundred forms to about 2.4 million."]}),"\n",(0,n.jsx)(t.p,{children:'If we were maintaining that all as a giant, human-curated list, adding anything at all would be prohibitively expensive.  Someone might say "Oh, we need to add a new verb root!" and that might add another 10,000 entries!  Or they\'d say "We need to add the yes no question form!" and that means another 2.4 million entries.'}),"\n",(0,n.jsxs)(t.p,{children:["But when you're dealing with the parts, you just add the new parts.  Like if I needed to add a new root to the Swahili database above, I don't have to add all 9 forms of it, I just have to add one more line in the ",(0,n.jsx)(t.code,{children:"Root"})," table.  And this doesn't change if I have 10,000 forms of each verb, it's still just adding one more line."]}),"\n",(0,n.jsx)(t.h2,{id:"lets-back-up-and-make-on-for-english-first",children:"Let's back up and make on for English first."}),"\n",(0,n.jsx)(t.p,{children:"The above might be a little difficult to understand, because it's describing something you probably don't know (Swahili verbs).  Let's start again with English verbs."}),"\n",(0,n.jsx)(t.p,{children:"I've chosen \"regular\" verbs (those that don't change form) to make things easier for now.  Let's model these two verbs, in three conjugations:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.th,{})})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"calls"})}),(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"calling"})}),(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"called"})}),(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"jumps"})}),(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"jumping"})}),(0,n.jsx)(t.tr,{children:(0,n.jsx)(t.td,{children:"jumped"})})]})]}),"\n",(0,n.jsxs)(t.p,{children:["When we write a Gramble program, we are building a ",(0,n.jsx)(t.em,{children:"model"})," of the phenomenon in question.  There's no one way to write a model; different models might work completely differently but have the exact same outputs.  We might model the above phenomenon in one of two ways:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Just list out every possible form as-is (for example, ",(0,n.jsx)(t.code,{children:"calls"}),", ",(0,n.jsx)(t.code,{children:"calling"}),", etc.)."]}),"\n",(0,n.jsxs)(t.li,{children:['Break the words into meaningful pieces (the "roots" ',(0,n.jsx)(t.code,{children:"call"})," vs. ",(0,n.jsx)(t.code,{children:"jump"}),', and the "suffixes" ',(0,n.jsx)(t.code,{children:"s"})," vs. ",(0,n.jsx)(t.code,{children:"ing"})," vs. ",(0,n.jsx)(t.code,{children:"ed"}),"), specify in what order they occur, and specify any changes they might have to go through in the process (like changing ",(0,n.jsx)(t.code,{children:"y+s"})," to ",(0,n.jsx)(t.code,{children:"ies"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The first option is easy in the short run, because it doesn't really take any planning, but in the long run it ends up being way too much work.  (Programming is the art of being lazy in a precise way!)  You might imagine listing every single verb form for every verb in English -- that's ",(0,n.jsx)(t.em,{children:"doable"}),", at least, some dictionaries do that -- but as we saw in the last lesson it's never going to work for Swahili or other languages with long, complex verbs."]}),"\n",(0,n.jsx)(t.p,{children:"So let's do (2)."}),"\n",(0,n.jsxs)(t.p,{children:["First, let's make a table containing the verb roots, ",(0,n.jsx)(t.code,{children:"call"})," and ",(0,n.jsx)(t.code,{children:"jump"}),"."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"call"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"jump"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["By the way, there's nothing special about the field ",(0,n.jsx)(t.code,{children:"text"})," here.  I could call it anything I want.  Gramble lets you name fields almost anything you want (with a few restrictions like they can't have spaces in them, start with a symbol or number, etc)."]}),"\n",(0,n.jsxs)(t.p,{children:["Then, let's add a table containing the suffixes, ",(0,n.jsx)(t.code,{children:"s"}),", ",(0,n.jsx)(t.code,{children:"ing"}),", and ",(0,n.jsx)(t.code,{children:"ed"})]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Suffix ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"s"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ing"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"ed"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Now, we make a table that takes every form in the Root table and concatenates it to every form in the Suffix table.  There's a special command that lets you say \"every form in the Root table\" and that's ",(0,n.jsx)(t.code,{children:"embed"}),"."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Verb ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"embed"})})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"Suffix"})]})})]}),"\n",(0,n.jsx)(t.h2,{id:"try-it-out-in-the-gramble-sheet",children:"Try it out in the Gramble sheet"}),"\n",(0,n.jsx)(t.p,{children:'Go ahead and paste these into a Google Sheet where the Gramble plugin has been installed, or go up to the Gramble menu (it\'s up towards the top of the screen, to the left of File, Edit, etc.) and choose "Example pages" -> "Example 1".'}),"\n",(0,n.jsx)(t.p,{children:'To check that everything\'s working properly, go up to the Gramble menu and choose "Show sidebar".  This sidebar interface lets you interact with your Gramble grammar.'}),"\n",(0,n.jsxs)(t.p,{children:["Go to the dropdown menu at the top, it'll probably say something like ",(0,n.jsx)(t.code,{children:"YourSheetName.Root"}),".  Choose ",(0,n.jsx)(t.code,{children:"YourSheetName.Verb"}),', because we want to test whether this generates all six forms.  Now, you can generate (either to a new sheet or as a file you can download), or you can just keep clicking "Sample here" to get a single random verb.  You should be able to generate/sample all six possible forms.']}),"\n",(0,n.jsxs)(t.p,{children:["Try adding a third root, like ",(0,n.jsx)(t.code,{children:"walk"}),".  The go back to the sidebar and click \"Sync & Validate\", which will let it see your new changes.  (The sidebar is NOT able to follow your changes automatically.  For security/efficiency reasons, the sidebar doesn't anything without you clicking something; only you can ask it to look at the spreadsheet again to see that you've made changes.)"]})]})}function c(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>d});var n=s(7294);const r={},i=n.createContext(r);function d(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);