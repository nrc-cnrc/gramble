"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9826],{924:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Gramble tutorial","href":"/gramble/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"Tutorial","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"What is Gramble?","href":"/gramble/docs/tutorial/gs1","docId":"tutorial/gs1","unlisted":false},{"type":"link","label":"Linguistic programs as databases","href":"/gramble/docs/tutorial/gs2","docId":"tutorial/gs2","unlisted":false},{"type":"link","label":"A simple Gramble program","href":"/gramble/docs/tutorial/gs3","docId":"tutorial/gs3","unlisted":false},{"type":"link","label":"Adding more fields","href":"/gramble/docs/tutorial/gs4","docId":"tutorial/gs4","unlisted":false},{"type":"link","label":"From transducer to database","href":"/gramble/docs/tutorial/gs5","docId":"tutorial/gs5","unlisted":false},{"type":"link","label":"Flat vs. nested","href":"/gramble/docs/tutorial/gs6","docId":"tutorial/gs6","unlisted":false},{"type":"link","label":"Circumfixes","href":"/gramble/docs/tutorial/gs7","docId":"tutorial/gs7","unlisted":false}],"href":"/gramble/docs/category/tutorial"},{"type":"category","label":"Reference","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Characters","href":"/gramble/docs/reference/characters","docId":"reference/characters","unlisted":false},{"type":"link","label":"contains","href":"/gramble/docs/reference/contains","docId":"reference/contains","unlisted":false},{"type":"link","label":"ends","href":"/gramble/docs/reference/ends","docId":"reference/ends","unlisted":false},{"type":"link","label":"equals","href":"/gramble/docs/reference/equals","docId":"reference/equals","unlisted":false},{"type":"link","label":"hide","href":"/gramble/docs/reference/hide","docId":"reference/hide","unlisted":false},{"type":"link","label":"join","href":"/gramble/docs/reference/join","docId":"reference/join","unlisted":false},{"type":"link","label":"optional","href":"/gramble/docs/reference/optional","docId":"reference/optional","unlisted":false},{"type":"link","label":"or","href":"/gramble/docs/reference/or","docId":"reference/or","unlisted":false},{"type":"link","label":"Regular Expressions","href":"/gramble/docs/reference/regex","docId":"reference/regex","unlisted":false},{"type":"link","label":"rename (>)","href":"/gramble/docs/reference/rename","docId":"reference/rename","unlisted":false},{"type":"link","label":"starts","href":"/gramble/docs/reference/starts","docId":"reference/starts","unlisted":false},{"type":"link","label":"table","href":"/gramble/docs/reference/table","docId":"reference/table","unlisted":false}],"href":"/gramble/docs/category/reference"},{"type":"link","label":"Multiple tiers","href":"/gramble/docs/multiTier","docId":"multiTier","unlisted":false}]},"docs":{"intro":{"id":"intro","title":"Gramble tutorial","description":"Gramble is a declarative, domain-specific programming language (DSL) for linguistic parsing and generation.  (For example, you could use it to turn Swahili {text pend, tense1SG}, or vice-versa.)","sidebar":"tutorialSidebar"},"multiTier":{"id":"multiTier","title":"Why multiple tiers?","description":"A lot of the original motivation for Gramble (or, to be precise, the systems that preceded Gramble) is that we needed systems that could express relationships between more than two tiers.","sidebar":"tutorialSidebar"},"reference/characters":{"id":"reference/characters","title":"Characters","description":"Some aspects of programming languages operate on single characters (for example, the \\"dot\\" operator . of a regular expression).","sidebar":"tutorialSidebar"},"reference/contains":{"id":"reference/contains","title":"contains","description":"The contains operator lets you filter a grammar so that only forms where the field contains a particular string/regex are generated.","sidebar":"tutorialSidebar"},"reference/ends":{"id":"reference/ends","title":"ends","description":"The ends operator lets you filter a grammar so that only forms where the field ends with a particular string/regex are generated.","sidebar":"tutorialSidebar"},"reference/equals":{"id":"reference/equals","title":"equals","description":"The equals operator lets you filter a grammar so that only forms where the field matches a particular regex are generated.","sidebar":"tutorialSidebar"},"reference/hide":{"id":"reference/hide","title":"hide","description":"hide is a header operator that makes one or more fields invisible outside of its scope.","sidebar":"tutorialSidebar"},"reference/join":{"id":"reference/join","title":"join","description":"join is a table operator that performs a natural join between its sibling (the content above it) and its child (the content immediately to its right).","sidebar":"tutorialSidebar"},"reference/optional":{"id":"reference/optional","title":"optional","description":"optional is a header operator allowing the expression of \\"add \\\\ to field \\\\\\", or add nothing\\".  E.g., optional Fx with the empty grammar.","sidebar":"tutorialSidebar"},"reference/or":{"id":"reference/or","title":"or","description":"or is a table operator that creates an alternation between its sibling (the content above it) and its child (the content immediately to its right).","sidebar":"tutorialSidebar"},"reference/regex":{"id":"reference/regex","title":"Regular Expressions","description":"Some header operators -- equals, starts, ends, contains, from, and context -- cause the cells below them to be interpreted as regular expressions.","sidebar":"tutorialSidebar"},"reference/rename":{"id":"reference/rename","title":"rename (>)","description":"The rename operator (which is expressed using >) is a header operator that causes a field inside its scope to have a different name outside its scope.","sidebar":"tutorialSidebar"},"reference/starts":{"id":"reference/starts","title":"starts","description":"The starts operator lets you filter a grammar so that only forms where the field starting with a particular string/regex are generated.","sidebar":"tutorialSidebar"},"reference/table":{"id":"reference/table","title":"table","description":"table is a table operator that does not perform any semantic function (it is a \\"no-op\\"), but exists for syntactic reasons in order to prevent the mis-interpretation of other table operators as cell content.","sidebar":"tutorialSidebar"},"tutorial/gs1":{"id":"tutorial/gs1","title":"What is Gramble?","description":"Gramble is a programming language for linguistic programming: building tools that create or respond to human language words and sentences.  It\'s meant to be easier to read and write, so that people can make linguistic programs in their languages without necessarily having to have a degree in computer science.","sidebar":"tutorialSidebar"},"tutorial/gs2":{"id":"tutorial/gs2","title":"Linguistic programs as databases","description":"A Gramble program is a way of specifying a linguistic database in an efficient manner, without having to list out every possible entry.  This is useful for very complex languages like Swahili or Kanyen\'keha (in which there are millions of possible verb forms), or for syntactic phenomena like sentences (where we can\'t possibly list every possible sentence), or for procedures like Romanization where you want to produce a Roman-alphabet version of any user input, even if it\'s not a word you\'ve ever seen before.","sidebar":"tutorialSidebar"},"tutorial/gs3":{"id":"tutorial/gs3","title":"A simple Gramble program","description":"Enter Gramble","sidebar":"tutorialSidebar"},"tutorial/gs4":{"id":"tutorial/gs4","title":"Adding more fields","description":"The program in on the previous page only had one field, text.  It\'s not very useful with just one field!","sidebar":"tutorialSidebar"},"tutorial/gs5":{"id":"tutorial/gs5","title":"From transducer to database","description":"Let\'s go one further -- not just transducing from an input to an output, but expressing a database with multiple \\"fields\\".","sidebar":"tutorialSidebar"},"tutorial/gs6":{"id":"tutorial/gs6","title":"Flat vs. nested structure","description":"The previous examples used a structure where we define each morpheme (e.g. that the root can be \\"call\\" or \\"jump\\", that the suffix can be \\"s\\" or \\"ing\\" or \\"ed\\", etc.) and then at the end we concatenate all the morphemes together.  Let\'s call that a \\"flat\\" structure.  (You might also call it a \\"templatic\\" structure, but I\'m going to avoid that term here because it can mean a lot of things.  You might be modeling a language that linguists say has \\"templatic morphology\\", but you might not want to structure your grammar that way.)","sidebar":"tutorialSidebar"},"tutorial/gs7":{"id":"tutorial/gs7","title":"Circumfixes and other long-distance morphology","description":"When word formation requires you do add both a prefix and suffix at the same time, that\'s sometimes called a circumfix.  The existence of circumfixes in English are debatable, but consider something like \\"enliven\\": there\'s a root \\"live\\" and then an \\"en- -en\\" surrounding it.  This one isn\'t the greatest example because we can also say this was formed \\"live -> liven -> enliven\\", but there are languages where this step-by-step approach doesn\'t work, where BOTH affixes have to be put on together or else the word is meaningless, or where their presence together has a different meaning contribution than you\'d predict from their individual meanings.","sidebar":"tutorialSidebar"}}}}')}}]);