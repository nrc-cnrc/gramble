"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5758],{8510:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=s(4848),n=s(8453);const i={id:"starts",title:"starts",sidebar_label:"starts"},l=void 0,o={id:"reference/headerOps/starts",title:"starts",description:"Description",source:"@site/docs/reference/headerOps/starts.md",sourceDirName:"reference/headerOps",slug:"/reference/headerOps/starts",permalink:"/gramble/docs/reference/headerOps/starts",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"starts",title:"starts",sidebar_label:"starts"},sidebar:"docSidebar",previous:{title:"rename (>)",permalink:"/gramble/docs/reference/headerOps/rename"},next:{title:"Table Operators",permalink:"/gramble/docs/category/table-operators"}},a={},c=[{value:"Description",id:"description",level:2},{value:"Usage examples",id:"usage-examples",level:2},{value:"Details",id:"details",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"starts"})," operator lets you filter a grammar so that only forms where the field starting with a particular string/regex are generated."]}),"\n",(0,r.jsxs)(t.p,{children:["Like ",(0,r.jsx)(t.code,{children:"equals"}),"/",(0,r.jsx)(t.code,{children:"ends"}),"/",(0,r.jsx)(t.code,{children:"contains"}),", ",(0,r.jsx)(t.code,{children:"rename"})," and hide, ",(0,r.jsx)(t.code,{children:"starts"})," applies to the content immediately to its left, but can be chained."]}),"\n",(0,r.jsx)(t.h2,{id:"usage-examples",children:"Usage examples"}),"\n",(0,r.jsxs)(t.p,{children:["For example, we could filter ",(0,r.jsx)(t.strong,{children:"A"}),' only to entries where the text starts with "p", "t", or "k":']}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"B =\xa0"})}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"embed"})}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"starts text"})})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"}}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"A"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"p|t|k"})]})})]}),"\n",(0,r.jsxs)(t.p,{children:["Like ",(0,r.jsx)(t.code,{children:"equals"}),", content below ",(0,r.jsx)(t.code,{children:"starts"})," is interpreted as a regex."]}),"\n",(0,r.jsxs)(t.p,{children:["For a negative example, the following filters ",(0,r.jsx)(t.strong,{children:"A"})," only to those entries where the text ",(0,r.jsx)(t.em,{children:"doesn't"}),' start with "p", "t", or "k".']}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"B =\xa0"})}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"embed"})}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:(0,r.jsx)(t.strong,{children:"starts text"})})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"}}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"A"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"~(p|t|k)"})]})})]}),"\n",(0,r.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"starts"})," operator is a convenience version of the ",(0,r.jsx)(t.code,{children:"equals"})," operator, that converts the regex given into a more complex one.  For example, in the first example above, it is converted to ",(0,r.jsx)(t.code,{children:"(p|t|k).*"}),".  In the second example, it is converted to ",(0,r.jsx)(t.code,{children:"~((p|t|k).*)"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Note the scope of the negation and the dot-star in the latter example.  The ",(0,r.jsx)(t.code,{children:"starts"})," operator does not simply tack on a dot-star to the programmer's original regex, because this would not give the meaning that the programmer probably expects.  ",(0,r.jsx)(t.code,{children:"~p.*"}),' means "Starts with the complement of p", but that\'s not actually what we want.  The complement of ',(0,r.jsx)(t.code,{children:"p"})," is ",(0,r.jsx)(t.em,{children:"any"})," string that isn't ",(0,r.jsx)(t.code,{children:"p"}),", and this includes strings like ",(0,r.jsx)(t.code,{children:"pp"})," and the empty string.  Every string starts with the empty string, so filtering with ",(0,r.jsx)(t.code,{children:"~p.*"})," wouldn't do anything.  Instead, the appropriate regex is ",(0,r.jsx)(t.code,{children:"~(p.*)"}),' -- "The complement of [strings starting with p]" rather than "Strings starting with [the complement of p]".']}),"\n",(0,r.jsxs)(t.p,{children:["If you put a complex regex under ",(0,r.jsx)(t.code,{children:"starts"}),", it's possible that the result of this transformation does not mean exactly what you expect it to.  In that case, we suggest using the ",(0,r.jsx)(t.code,{children:"equals"})," operator instead and writing the regex filter that you really want, rather than relying on this convenience operator."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>o});var r=s(6540);const n={},i=r.createContext(n);function l(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);