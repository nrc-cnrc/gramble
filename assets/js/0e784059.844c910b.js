"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9333],{2:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(5893),a=r(1151);const o={id:"characters",title:"Characters",sidebar_label:"Characters"},i="Characters",s={id:"reference/characters",title:"Characters",description:'Some aspects of programming languages operate on single characters (for example, the "dot" operator . of a regular expression).',source:"@site/docs/reference/characters.md",sourceDirName:"reference",slug:"/reference/characters",permalink:"/gramble/docs/reference/characters",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"characters",title:"Characters",sidebar_label:"Characters"},sidebar:"tutorialSidebar",previous:{title:"Reference",permalink:"/gramble/docs/category/reference"},next:{title:"contains",permalink:"/gramble/docs/reference/contains"}},h={},c=[{value:"A more in-depth explanation",id:"a-more-in-depth-explanation",level:2},{value:"Unicode grapheme clusters",id:"unicode-grapheme-clusters",level:2},{value:"Differences between Gramble characters and UGCs",id:"differences-between-gramble-characters-and-ugcs",level:2},{value:"Gotcha #1",id:"gotcha-1",level:2},{value:"Gotcha #2",id:"gotcha-2",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"characters",children:"Characters"})}),"\n",(0,n.jsxs)(t.p,{children:['Some aspects of programming languages operate on single characters (for example, the "dot" operator ',(0,n.jsx)(t.code,{children:"."})," of a regular expression)."]}),"\n",(0,n.jsx)(t.p,{children:'Gramble characters can be slightly larger than the "characters" you might be used to in other programming languages.  Instead of dividing a string like "p\u02b0a\u02d0t\u0361\u0283" into seven units ("p", "\u02b0", "a", "\u02d0", "t", "\u0361", "\u0283") like (say) Python would, it divides it into three units ("p\u02b0", "a\u02d0", "t\u0361\u0283"), just like you would if dividing an IPA into phonemes.'}),"\n",(0,n.jsx)(t.p,{children:"More specifically, Gramble characters are a variant of Unicode grapheme clusters, but to explain those we need to discuss Unicode in more detail."}),"\n",(0,n.jsx)(t.h2,{id:"a-more-in-depth-explanation",children:"A more in-depth explanation"}),"\n",(0,n.jsx)(t.p,{children:'Characters (letters, numerals, punctuation marks, etc.) are represented inside computers as numbers.  For example, we might associate "A" with 65, "B" with 66, etc.  That association is called an "encoding".  If we\'re just representing English, then it\'s pretty straightforward to associate each letter with a single number, and that\'s that.  If you want to ask, "How many letters are in \'hello\'?" you can look at the sequence of numbers, count them, and respond, "Five."  If you want to ask, "What\'s the second letter of \'hello\'?" you look at the second number in that sequence, see that it\'s 69, look that up, and say, "It\'s \'e\'."'}),"\n",(0,n.jsxs)(t.p,{children:["Things get much more complicated, however, if we need to represent ",(0,n.jsx)(t.em,{children:"any"})," word in ",(0,n.jsx)(t.em,{children:"any"}),' language.  For example, we need to represent letters with diacritics, or even multiple\r\ndiacritics like Vietnamese "\u1ea7" or "\u1ec7".  We don\'t want to represent every possible combination; that would end up being too many letters.  (For example, there are something like 90,000 valid combinations of IPA letters and diacritics.)  To be able to represent any of these, we represent each of their component parts as individual numbers (U+0065, U+0323, U+0302) -- call those "codepoints" -- and the text rendering program looks up what shapes the codepoints correspond to and arranges them in an appropriate way on the screen.']}),"\n",(0,n.jsxs)(t.p,{children:['However, this raises a question.  What\'s the right answer to the question, "How many letters are in \'Vi\u1ec7t\'?"  How about "What\'s the third letter of \'Vi\u1ec7t\'?"  If we just bite the bullet and say, "One character = one codepoint," then there are six letters in "Vi\u1ec7t" and its third letter is "e", just plain "e" with no diacritics.  That might feel a bit counterintuitive, but it\'s how a lot of programming languages work.  In Python, ',(0,n.jsx)(t.code,{children:'len("Vie\u0302\u0323t")'})," equals ",(0,n.jsx)(t.code,{children:"6"})," and ",(0,n.jsx)(t.code,{children:'"Vie\u0302\u0323t"[2]'})," equals ",(0,n.jsx)(t.code,{children:'"e"'}),"."]}),"\n",(0,n.jsx)(t.p,{children:'But things get more complicated than that.  There are also composed characters; for example, there\'s a special "\u1ec7" that\'s only one codepoint (U+1EC6).  If you\'re working on a major world language like French or Vietnamese, there are probably composed versions of most or all characters.  And you can convert back and forth, so you can choose to treat "\u1ec7" as one character or three depending on your needs.'}),"\n",(0,n.jsxs)(t.p,{children:['You can see how this can lead to surprises.  Not every language has this privilege, and in order to guess whether something has a combined form -- and therefore the answer to questions like "What\'s the third letter of this word?" isn\'t easily answerable unless you know a lot about the history of encodings.  For example, "\xe0" has a one-codepoint version and a two-codepoint version, because it\'s in French and its codepoint was inherited from the old ',(0,n.jsx)(t.code,{children:"latin_1"}),' encoding; however, "\xe6\u0300" does not have a one-codepoint version, only a two-codepoint one.']}),"\n",(0,n.jsx)(t.p,{children:"Why is this important for Gramble?  Well, consider a grammar like this:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"Root ="})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"text"})}),(0,n.jsx)(t.th,{children:(0,n.jsx)(t.strong,{children:"gloss"})})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"aba"}),(0,n.jsx)(t.td,{children:"run"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"\xe0ri"}),(0,n.jsx)(t.td,{children:"eat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"X ="})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"embed"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"starts text"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Root"}),(0,n.jsx)(t.td,{children:"a"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Does this ",(0,n.jsx)(t.code,{children:"starts"}),' operator filter out "\xe0ri" or not?  If Gramble had the notion that "character = codepoint", it might or might not.  If "\xe0ri" uses the decomposed version, then "\xe0ri" still starts with "a" -- it\'s a four-character string starting with "a".  If "\xe0ri" uses the composed version, then it doesn\'t start with "a" -- it\'s a three-character string starting with "\xe0", which isn\'t the same codepoint as "a".  And this might be different for different characters -- "\xe6\u0300" would always start with "\xe6" because there\'s no composed version of that.']}),"\n",(0,n.jsx)(t.p,{children:'So Gramble doesn\'t use the idea "character = codepoint" like Python does; it uses a different notion of character.'}),"\n",(0,n.jsx)(t.h2,{id:"unicode-grapheme-clusters",children:"Unicode grapheme clusters"}),"\n",(0,n.jsx)(t.p,{children:'The Unicode standard also defines a larger unit, the "Unicode grapheme cluster" (UGC), that is meant to avoid this problem and conforms more closely to what most people think of as a "letter", even if that letter happens to consist of multiple Unicode codepoints.  "\xe0" and "\xe6\u0300" and "\u1ec7" are all just one UGC in length.  Regardless of whether we are using the one-codepoint version of "\u1ec7" or its three-codepoint version, both are exactly one UGC in length.'}),"\n",(0,n.jsx)(t.p,{children:'Gramble characters are UGCs (or strictly speaking, a variant of them), and are treated as atomic (that is, they are treated as having no further internal structure).  "a" and "\xe0" are treated as completely different letters with nothing in common.'}),"\n",(0,n.jsxs)(t.p,{children:["The algorithm for dividing a word into Gramble characters is pretty simple.  Roughly, step through a word's codepoints from the beginning to end.  If there's a letter, numeral, or punctuation, that starts a new UGC, but when you come across a diacritic, add it to the previous UGC.  (Every Unicode codepoint belongs to a class like Letter (L), Punctuation (P), etc.  Gramble doesn't know whether each codepoint is a letter or punctuation or diacritic in any particular language's orthography; all it's doing is looking at this class in the codepoint's Unicode data.  This might differ from how ",(0,n.jsx)(t.em,{children:"your"})," language thinks of a codepoint as a letter; see ",(0,n.jsx)(t.a,{href:"#gotcha-1",children:"Gotcha #1"})," below for some more discussion.)"]}),"\n",(0,n.jsx)(t.h2,{id:"differences-between-gramble-characters-and-ugcs",children:"Differences between Gramble characters and UGCs"}),"\n",(0,n.jsx)(t.p,{children:"Unicode defines a particular algorithm for UGCs, while accepting that many applications or languages might need to vary it somewhat for their particular purposes.  Gramble takes advantage of this freedom to hew somewhat closer to what a linguist would expect working with the IPA."}),"\n",(0,n.jsx)(t.p,{children:'For example, modifier letters like the superscript "\u02b7" are counted as their own UGCs, so a sequence like "k\u02b7" is two UGCs long.  This isn\'t the way a linguist would typically segment phonemes, though; they\'ll typically want to treat "k\u02b7" as one unit.  So in Gramble, modifier letters are treated as if they\'re diacritics -- added to the previous UGC rather than starting a new one.'}),"\n",(0,n.jsx)(t.p,{children:'Also, Gramble respects the IPA tie bar.  If you put a tie bar character in between two characters, like "t\u0361\u0283", Gramble will treat them as one unit.  This isn\'t part of the normal UGC algorithm; Gramble treats them specially because the normal UGC algorithm would segment this into two UGCs, "t\u0361" and "\u0283", which is a counterintuitive division given the IPA semantics of tie bars.  So Gramble departs from the normal UGC algorithm here: when it encounters a tie bar, it adds both the tie bar AND the next character to the previous unit.'}),"\n",(0,n.jsx)(t.h2,{id:"gotcha-1",children:"Gotcha #1"}),"\n",(0,n.jsx)(t.p,{children:"For convenience, many text representations of languages use punctuation characters as phonetic diacritics -- apostrophes for ejectives, colons for length, etc.  Gramble can't know that, however; as mentioned above, it just looks at the Unicode character class of each codepoint, and for apostrophes and colons it will see class P for Punctuation and treat these as new units, rather than belonging to the previous unit."}),"\n",(0,n.jsxs)(t.p,{children:['The "proper" thing to do, for punctuation-as-diacritics, is to find the corresponding actual combining/modifier letter in Unicode.  Rather than use the apostrophe on the keyboard, use ',(0,n.jsx)(t.code,{children:"\u02bc U+02BC: MODIFIER LETTER APOSTROPHE"}),".  Rather than use the colon on the keyboard, use the IPA length macron ",(0,n.jsx)(t.code,{children:"\u02d0 U+02D0: MODIFIER LETTER TRIANGULAR COLON"}),".  This lets text processing applications (Gramble included) understand your intentions better -- not adding punctuation to a word, but adding phonetic content."]}),"\n",(0,n.jsx)(t.h2,{id:"gotcha-2",children:"Gotcha #2"}),"\n",(0,n.jsxs)(t.p,{children:["Another gotcha to note is that, just like the UGC algorithm, Gramble will only combine codepoints into units when the diacritic is to the ",(0,n.jsx)(t.em,{children:"right"}),' of the main character.  Things like pre-aspiration "\u02b0t" or pre-glottalization "\u02c0n" won\'t combine into units properly -- that "\u02b0" will attach to whatever unit is before it (or, if nothing is before it, become its own unit).']}),"\n",(0,n.jsx)(t.p,{children:"What to do here?  In general, I've found it considerably easier, when working with IPA-like orthographies, to represent pre-diacritics as post-diacritics (that is, by putting all modifiers to the right of the character, even if they happen to precede it phonetically).  Not just in Gramble; I also recommend this when working in any programming language.  It's simply easier to parse unambiguously, and when it comes time to display the string to the user you can fix it up so that it's in the proper order as specified by the orthography."}),"\n",(0,n.jsxs)(t.p,{children:["For example, some languages have both ejective stops like [t\u02bc] and preglottalized resonants like [\u02bcw].  But what if you see a sequence like [t\u02bcw] -- does that represent [t\u02bc] followed by [w] or [t] followed by [\u02bcw]?  If we always put the apostrophe after the letter it modifies, this is no longer ambiguous: the former is now represented [t\u02bcw] and the latter is represented [tw\u02bc].  That latter one isn't ",(0,n.jsx)(t.em,{children:"orthographically"})," correct, but unambiguous representations like this make it easier for a computer program to make the right decisions about its processing.  We can switch the [w\u02bc] back to [\u02bcw] after everything is done to present it to the user in the orthographically-correct manner."]}),"\n",(0,n.jsx)(t.p,{children:"gramble_tutorial_characters.txt"}),"\n",(0,n.jsx)(t.p,{children:"Displaying gramble_tutorial_characters.txt."})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>s,a:()=>i});var n=r(7294);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);